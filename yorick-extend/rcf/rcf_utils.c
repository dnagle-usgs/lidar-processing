/*
 *
 *   $Id$
 *
 *   This file contains the c functions to implement the rcf.
 *   This is the intial part of the rcf.c file that is generated by the mkrcf.sh script.
 *   The contents of this file are simply copied into the rcf.c file
 *   
 *   c_fillarray is used in mode 2, to fill the winners into a yorick type array.
 *   XGetInfo is a function from std0.c, to get information on the array size
 *   
 *   Original rcf.i by W. Wright, 
 *   Converted to "C" by Conan Noronha
 */



#include "bcast.h"
#include "yio.h"
#include "defmem.h"
#include "pstdlib.h"
#include "play.h"
#include <string.h>
#include <stdio.h>
#include <errno.h>

static Member type;

/* This function is taken directly from Y_LAUNCH/std0.c 
 * to get the number of elements in the source array
 */

static DataBlock *XGetInfo(Symbol *s)
{
  DataBlock *db= 0;
  for (;;) {
    if (s->ops==&doubleScalar) {
      type.base= &doubleStruct;
      type.dims= 0;
      type.number= 1;
      break;
    } else if (s->ops==&longScalar) {
      type.base= &longStruct;
      type.dims= 0;
      type.number= 1;
      break;
    } else if (s->ops==&intScalar) {
      type.base= &intStruct;
      type.dims= 0;
      type.number= 1;
      break;
    } else if (s->ops==&dataBlockSym) {
      db= s->value.db;
      if (db->ops==&lvalueOps) {
        LValue *lvalue= (LValue *)db;
        type.base= lvalue->type.base;
        type.dims= lvalue->type.dims;
        type.number= lvalue->type.number;
      } else if (db->ops->isArray) {
        Array *array= (Array *)db;
        type.base= array->type.base;
        type.dims= array->type.dims;
        type.number= array->type.number;
      } else {
        type.base= 0;
        type.dims= 0;
        type.number= 0;
      }
      break;
    } else if (s->ops==&referenceSym) {
      s= &globTab[s->index];
    } else {
      YError("unexpected keyword argument");
    }
  }
  return type.base? 0 : db;
}

#define TBUFSIZE        32767
static unsigned int *winners, *fwinners, *cvotes, fcounter;	//Store the winners temporarily & global number of winners count.

short flag;	//Decides on the array use

unsigned int  twinners[ TBUFSIZE ], tidx[ TBUFSIZE ], tfwinners[ TBUFSIZE ], tcvotes[TBUFSIZE];	//These arrays are only used when number_elems <= TBUFSIZE


/* Used to fill a 'Yorick' array with the winners indices
 * This function is called only for mode==2
 */

void c_fillarray (unsigned int *c)
{
   memcpy ((void*)c, (void*)fwinners, ((sizeof(unsigned int))*fcounter));	//Copy fwinners into the yorick array
   if (flag)
      free (fwinners);		//fwinners not needed now
}

/** CODE BELOW INSERTED FROM rcfbase2.c **/
/*
 * $Id$
 *
 * This file contains the base code to implement the rcf algorithm
 * It is used by the mkrcf.sh script, to generate 4 versiions of 
 * the code below. ie one version each for float, double, long and 
 * int type data.
 *
 * Original rcf.i by C.W.Wright
 * Converted to "C" by Conan Noronha
 *
 */
static float * fcopy; //Global pointer to the jury
/* Function to compare index values of the jury, based on the contents of
 * that indexed location. 
 * Used by qsort for float jury. Returns -1, 0 or 1
 */
int float_compare (const void *x, const void *y)
{
   unsigned int pp,qq;
   int t;
   pp = (unsigned int)(*(unsigned int *)x);
   qq = (unsigned int)(*(unsigned int *)y);
   if (fcopy[pp] < fcopy[qq]) t = -1;
   else
   if (fcopy[pp] == fcopy[qq]) t = 0;
   else t = 1;
   return t;
}
/* rcf algorithm for mode0.
 * Returns array b
 */
void rcf_float_0 (float* a, float w, float* b)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(float)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          b[0] = a[0];
          b[1] = (float)1;
          return;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  fcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), float_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (float)counter) //Refresh the return array b, if necessary
    {
       b[1] = (float)counter;
       b[0] = a[idx[i]];
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
     free (idx); //idx array is also not needed now
  return;
}
/* rcf algorithm for mode 1.
 * Returns array b
 */
void rcf_float_1 (float *a, float w, float *b)
{
  unsigned int i, j, number_elems, counter, *idx;
  float tmp;
  DataBlock *db;
  if (w<=(float)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          b[0] = (float)a[0];
          b[1] = 1.0;
          return;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  fcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), float_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    tmp =a[idx[i]]; //The element itself will always be in the window
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        tmp += a[idx[j]];
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (float)counter) //Refresh the return array b, if necessary
    {
       b[1] = (float)counter;
       b[0] = tmp/(float)counter; //Mode 1, requests a mean
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
      free (idx); //idx array is also not needed now
  return;
}
/* rcf algorithm for mode 2.
 * Returns the number of winners
 */
unsigned int rcf_float_2 (float* a, float w)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(float)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          fwinners = tfwinners;
          fwinners[0] = 1;
          fcounter = 1;
          return fcounter;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        winners = twinners;
        fwinners = tfwinners;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        winners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        fwinners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  fcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), float_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    winners[counter-1] = idx[i]+1; //So add its index to winners...increment for yorick
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        winners[counter-1] = idx[j]+1; //In yorick, indexing starts from 1
      }
      else
         break; //Break since the array is sorted
    if (fcounter <= counter) //Refresh the return array b, if necessary
    {
       fcounter = counter; //Remember the counter value
                                                //For mode 2, store the winners 
       memcpy ((void *)fwinners, (void *)winners, ((sizeof(unsigned int))*fcounter));
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
  {
          free (winners); //Dont need winners anymore...they are in fwinners
          free (idx); //idx array is also not needed now
  }
  return fcounter;
}
/* rcf algorithm for mode 3
 * Returns a sorted version of the input array and the votes that
 * each element recieves
 */
float * csfjury, tcsfjury[TBUFSIZE];
/*This fuction fills the arrays of the appropriate size (i.e. fcounter)
 * as provided by the rcf function for mode 3
 */
void c_float_fillarray (float *sortedjury, unsigned int *votes)
{
  memcpy ((void*)sortedjury, (void*)csfjury, ((sizeof(float))*fcounter));
  memcpy ((void*)votes, (void*)cvotes, ((sizeof(unsigned int))*fcounter));
  if (flag)
  {
          free (cvotes);
          free (csfjury);
  }
}
/* This is the actual implementation of mode 3
 */
unsigned int rcf_float_3 (float* a, float w)
{
  unsigned int i, j, number_elems, *idx;
  DataBlock *db;
  if (w<=(float)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          cvotes = tcvotes;
          csfjury = tcsfjury;
          cvotes[0] = 1;
          csfjury[0] = (float)a[0];
          fcounter = 1;
          return fcounter;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        cvotes = tcvotes;
        csfjury = tcsfjury;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        cvotes = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        csfjury = (float *) malloc ((sizeof(float))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  fcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), float_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems; i++) //For each element in the copy
  {
    if (i == number_elems-1) //If its the last element,
    { //We can't look ahead, so break
            if (a[idx[i]] != a[idx[i-1]]) //Add it if its different from the previous
            {
                    csfjury[fcounter] = a[idx[i]];
                    cvotes[fcounter] = 1;
                    fcounter++; //Increment fcounter to be consistent with the case
            } //where we do not break here
            break;
    }
    else if ((i != 0) && (a[idx[i]] == a[idx[i-1]])) //If the element is not the 1st &  the same as 
    { //the previous simply continue thru a[]
            continue;
    }
    csfjury[fcounter] = a[idx[i]]; //For all other cases, copy the element
    cvotes[fcounter] = 1; //and initialize its vote to 1
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        cvotes[fcounter]++; //Count it
      }
      else
         break; //Break since the array is sorted
    fcounter++;
  }
  if (flag)
  {
          free (idx); //idx array is not needed now
  }
  return (fcounter); //fcounter is left at one more, which is good
                                                //because of the 0 indexing
}
/*
 * $Id$
 *
 * This file contains the base code to implement the rcf algorithm
 * It is used by the mkrcf.sh script, to generate 4 versiions of 
 * the code below. ie one version each for float, double, long and 
 * int type data.
 *
 * Original rcf.i by C.W.Wright
 * Converted to "C" by Conan Noronha
 *
 */
static double * dcopy; //Global pointer to the jury
/* Function to compare index values of the jury, based on the contents of
 * that indexed location. 
 * Used by qsort for float jury. Returns -1, 0 or 1
 */
int double_compare (const void *x, const void *y)
{
   unsigned int pp,qq;
   int t;
   pp = (unsigned int)(*(unsigned int *)x);
   qq = (unsigned int)(*(unsigned int *)y);
   if (dcopy[pp] < dcopy[qq]) t = -1;
   else
   if (dcopy[pp] == dcopy[qq]) t = 0;
   else t = 1;
   return t;
}
/* rcf algorithm for mode0.
 * Returns array b
 */
void rcf_double_0 (double* a, double w, double* b)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(double)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          b[0] = a[0];
          b[1] = (double)1;
          return;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  dcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), double_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (double)counter) //Refresh the return array b, if necessary
    {
       b[1] = (double)counter;
       b[0] = a[idx[i]];
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
     free (idx); //idx array is also not needed now
  return;
}
/* rcf algorithm for mode 1.
 * Returns array b
 */
void rcf_double_1 (double *a, double w, float *b)
{
  unsigned int i, j, number_elems, counter, *idx;
  double tmp;
  DataBlock *db;
  if (w<=(double)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          b[0] = (float)a[0];
          b[1] = 1.0;
          return;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  dcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), double_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    tmp =a[idx[i]]; //The element itself will always be in the window
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        tmp += a[idx[j]];
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (float)counter) //Refresh the return array b, if necessary
    {
       b[1] = (float)counter;
       b[0] = tmp/(float)counter; //Mode 1, requests a mean
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
      free (idx); //idx array is also not needed now
  return;
}
/* rcf algorithm for mode 2.
 * Returns the number of winners
 */
unsigned int rcf_double_2 (double* a, double w)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(double)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          fwinners = tfwinners;
          fwinners[0] = 1;
          fcounter = 1;
          return fcounter;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        winners = twinners;
        fwinners = tfwinners;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        winners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        fwinners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  dcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), double_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    winners[counter-1] = idx[i]+1; //So add its index to winners...increment for yorick
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        winners[counter-1] = idx[j]+1; //In yorick, indexing starts from 1
      }
      else
         break; //Break since the array is sorted
    if (fcounter <= counter) //Refresh the return array b, if necessary
    {
       fcounter = counter; //Remember the counter value
                                                //For mode 2, store the winners 
       memcpy ((void *)fwinners, (void *)winners, ((sizeof(unsigned int))*fcounter));
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
  {
          free (winners); //Dont need winners anymore...they are in fwinners
          free (idx); //idx array is also not needed now
  }
  return fcounter;
}
/* rcf algorithm for mode 3
 * Returns a sorted version of the input array and the votes that
 * each element recieves
 */
double * csdjury, tcsdjury[TBUFSIZE];
/*This fuction fills the arrays of the appropriate size (i.e. fcounter)
 * as provided by the rcf function for mode 3
 */
void c_double_fillarray (double *sortedjury, unsigned int *votes)
{
  memcpy ((void*)sortedjury, (void*)csdjury, ((sizeof(double))*fcounter));
  memcpy ((void*)votes, (void*)cvotes, ((sizeof(unsigned int))*fcounter));
  if (flag)
  {
          free (cvotes);
          free (csdjury);
  }
}
/* This is the actual implementation of mode 3
 */
unsigned int rcf_double_3 (double* a, double w)
{
  unsigned int i, j, number_elems, *idx;
  DataBlock *db;
  if (w<=(double)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          cvotes = tcvotes;
          csdjury = tcsdjury;
          cvotes[0] = 1;
          csdjury[0] = (double)a[0];
          fcounter = 1;
          return fcounter;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        cvotes = tcvotes;
        csdjury = tcsdjury;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        cvotes = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        csdjury = (double *) malloc ((sizeof(double))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  dcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), double_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems; i++) //For each element in the copy
  {
    if (i == number_elems-1) //If its the last element,
    { //We can't look ahead, so break
            if (a[idx[i]] != a[idx[i-1]]) //Add it if its different from the previous
            {
                    csdjury[fcounter] = a[idx[i]];
                    cvotes[fcounter] = 1;
                    fcounter++; //Increment fcounter to be consistent with the case
            } //where we do not break here
            break;
    }
    else if ((i != 0) && (a[idx[i]] == a[idx[i-1]])) //If the element is not the 1st &  the same as 
    { //the previous simply continue thru a[]
            continue;
    }
    csdjury[fcounter] = a[idx[i]]; //For all other cases, copy the element
    cvotes[fcounter] = 1; //and initialize its vote to 1
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        cvotes[fcounter]++; //Count it
      }
      else
         break; //Break since the array is sorted
    fcounter++;
  }
  if (flag)
  {
          free (idx); //idx array is not needed now
  }
  return (fcounter); //fcounter is left at one more, which is good
                                                //because of the 0 indexing
}
/*
 * $Id$
 *
 * This file contains the base code to implement the rcf algorithm
 * It is used by the mkrcf.sh script, to generate 4 versiions of 
 * the code below. ie one version each for float, double, long and 
 * int type data.
 *
 * Original rcf.i by C.W.Wright
 * Converted to "C" by Conan Noronha
 *
 */
static long * lcopy; //Global pointer to the jury
/* Function to compare index values of the jury, based on the contents of
 * that indexed location. 
 * Used by qsort for float jury. Returns -1, 0 or 1
 */
int long_compare (const void *x, const void *y)
{
   unsigned int pp,qq;
   int t;
   pp = (unsigned int)(*(unsigned int *)x);
   qq = (unsigned int)(*(unsigned int *)y);
   if (lcopy[pp] < lcopy[qq]) t = -1;
   else
   if (lcopy[pp] == lcopy[qq]) t = 0;
   else t = 1;
   return t;
}
/* rcf algorithm for mode0.
 * Returns array b
 */
void rcf_long_0 (long* a, long w, long* b)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(long)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          b[0] = a[0];
          b[1] = (long)1;
          return;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  lcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), long_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (long)counter) //Refresh the return array b, if necessary
    {
       b[1] = (long)counter;
       b[0] = a[idx[i]];
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
     free (idx); //idx array is also not needed now
  return;
}
/* rcf algorithm for mode 1.
 * Returns array b
 */
void rcf_long_1 (long *a, long w, float *b)
{
  unsigned int i, j, number_elems, counter, *idx;
  long tmp;
  DataBlock *db;
  if (w<=(long)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          b[0] = (float)a[0];
          b[1] = 1.0;
          return;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  lcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), long_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    tmp =a[idx[i]]; //The element itself will always be in the window
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        tmp += a[idx[j]];
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (float)counter) //Refresh the return array b, if necessary
    {
       b[1] = (float)counter;
       b[0] = tmp/(float)counter; //Mode 1, requests a mean
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
      free (idx); //idx array is also not needed now
  return;
}
/* rcf algorithm for mode 2.
 * Returns the number of winners
 */
unsigned int rcf_long_2 (long* a, long w)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(long)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          fwinners = tfwinners;
          fwinners[0] = 1;
          fcounter = 1;
          return fcounter;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        winners = twinners;
        fwinners = tfwinners;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        winners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        fwinners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  lcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), long_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    winners[counter-1] = idx[i]+1; //So add its index to winners...increment for yorick
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        winners[counter-1] = idx[j]+1; //In yorick, indexing starts from 1
      }
      else
         break; //Break since the array is sorted
    if (fcounter <= counter) //Refresh the return array b, if necessary
    {
       fcounter = counter; //Remember the counter value
                                                //For mode 2, store the winners 
       memcpy ((void *)fwinners, (void *)winners, ((sizeof(unsigned int))*fcounter));
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
  {
          free (winners); //Dont need winners anymore...they are in fwinners
          free (idx); //idx array is also not needed now
  }
  return fcounter;
}
/* rcf algorithm for mode 3
 * Returns a sorted version of the input array and the votes that
 * each element recieves
 */
long * csljury, tcsljury[TBUFSIZE];
/*This fuction fills the arrays of the appropriate size (i.e. fcounter)
 * as provided by the rcf function for mode 3
 */
void c_long_fillarray (long *sortedjury, unsigned int *votes)
{
  memcpy ((void*)sortedjury, (void*)csljury, ((sizeof(long))*fcounter));
  memcpy ((void*)votes, (void*)cvotes, ((sizeof(unsigned int))*fcounter));
  if (flag)
  {
          free (cvotes);
          free (csljury);
  }
}
/* This is the actual implementation of mode 3
 */
unsigned int rcf_long_3 (long* a, long w)
{
  unsigned int i, j, number_elems, *idx;
  DataBlock *db;
  if (w<=(long)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          cvotes = tcvotes;
          csljury = tcsljury;
          cvotes[0] = 1;
          csljury[0] = (long)a[0];
          fcounter = 1;
          return fcounter;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        cvotes = tcvotes;
        csljury = tcsljury;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        cvotes = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        csljury = (long *) malloc ((sizeof(long))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  lcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), long_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems; i++) //For each element in the copy
  {
    if (i == number_elems-1) //If its the last element,
    { //We can't look ahead, so break
            if (a[idx[i]] != a[idx[i-1]]) //Add it if its different from the previous
            {
                    csljury[fcounter] = a[idx[i]];
                    cvotes[fcounter] = 1;
                    fcounter++; //Increment fcounter to be consistent with the case
            } //where we do not break here
            break;
    }
    else if ((i != 0) && (a[idx[i]] == a[idx[i-1]])) //If the element is not the 1st &  the same as 
    { //the previous simply continue thru a[]
            continue;
    }
    csljury[fcounter] = a[idx[i]]; //For all other cases, copy the element
    cvotes[fcounter] = 1; //and initialize its vote to 1
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        cvotes[fcounter]++; //Count it
      }
      else
         break; //Break since the array is sorted
    fcounter++;
  }
  if (flag)
  {
          free (idx); //idx array is not needed now
  }
  return (fcounter); //fcounter is left at one more, which is good
                                                //because of the 0 indexing
}
/*
 * $Id$
 *
 * This file contains the base code to implement the rcf algorithm
 * It is used by the mkrcf.sh script, to generate 4 versiions of 
 * the code below. ie one version each for float, double, long and 
 * int type data.
 *
 * Original rcf.i by C.W.Wright
 * Converted to "C" by Conan Noronha
 *
 */
static int * icopy; //Global pointer to the jury
/* Function to compare index values of the jury, based on the contents of
 * that indexed location. 
 * Used by qsort for float jury. Returns -1, 0 or 1
 */
int int_compare (const void *x, const void *y)
{
   unsigned int pp,qq;
   int t;
   pp = (unsigned int)(*(unsigned int *)x);
   qq = (unsigned int)(*(unsigned int *)y);
   if (icopy[pp] < icopy[qq]) t = -1;
   else
   if (icopy[pp] == icopy[qq]) t = 0;
   else t = 1;
   return t;
}
/* rcf algorithm for mode0.
 * Returns array b
 */
void rcf_int_0 (int* a, int w, int* b)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(int)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          b[0] = a[0];
          b[1] = (int)1;
          return;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  icopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), int_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (int)counter) //Refresh the return array b, if necessary
    {
       b[1] = (int)counter;
       b[0] = a[idx[i]];
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
     free (idx); //idx array is also not needed now
  return;
}
/* rcf algorithm for mode 1.
 * Returns array b
 */
void rcf_int_1 (int *a, int w, float *b)
{
  unsigned int i, j, number_elems, counter, *idx;
  int tmp;
  DataBlock *db;
  if (w<=(int)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          b[0] = (float)a[0];
          b[1] = 1.0;
          return;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  icopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), int_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    tmp =a[idx[i]]; //The element itself will always be in the window
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        tmp += a[idx[j]];
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (float)counter) //Refresh the return array b, if necessary
    {
       b[1] = (float)counter;
       b[0] = tmp/(float)counter; //Mode 1, requests a mean
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
      free (idx); //idx array is also not needed now
  return;
}
/* rcf algorithm for mode 2.
 * Returns the number of winners
 */
unsigned int rcf_int_2 (int* a, int w)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(int)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          fwinners = tfwinners;
          fwinners[0] = 1;
          fcounter = 1;
          return fcounter;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        winners = twinners;
        fwinners = tfwinners;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        winners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        fwinners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  icopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), int_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    winners[counter-1] = idx[i]+1; //So add its index to winners...increment for yorick
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        winners[counter-1] = idx[j]+1; //In yorick, indexing starts from 1
      }
      else
         break; //Break since the array is sorted
    if (fcounter <= counter) //Refresh the return array b, if necessary
    {
       fcounter = counter; //Remember the counter value
                                                //For mode 2, store the winners 
       memcpy ((void *)fwinners, (void *)winners, ((sizeof(unsigned int))*fcounter));
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
  {
          free (winners); //Dont need winners anymore...they are in fwinners
          free (idx); //idx array is also not needed now
  }
  return fcounter;
}
/* rcf algorithm for mode 3
 * Returns a sorted version of the input array and the votes that
 * each element recieves
 */
int * csijury, tcsijury[TBUFSIZE];
/*This fuction fills the arrays of the appropriate size (i.e. fcounter)
 * as provided by the rcf function for mode 3
 */
void c_int_fillarray (int *sortedjury, unsigned int *votes)
{
  memcpy ((void*)sortedjury, (void*)csijury, ((sizeof(int))*fcounter));
  memcpy ((void*)votes, (void*)cvotes, ((sizeof(unsigned int))*fcounter));
  if (flag)
  {
          free (cvotes);
          free (csijury);
  }
}
/* This is the actual implementation of mode 3
 */
unsigned int rcf_int_3 (int* a, int w)
{
  unsigned int i, j, number_elems, *idx;
  DataBlock *db;
  if (w<=(int)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems == 1) //For the special 1 element array
  {
          cvotes = tcvotes;
          csijury = tcsijury;
          cvotes[0] = 1;
          csijury[0] = (int)a[0];
          fcounter = 1;
          return fcounter;
  }
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        cvotes = tcvotes;
        csijury = tcsijury;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        cvotes = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        csijury = (int *) malloc ((sizeof(int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  icopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), int_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems; i++) //For each element in the copy
  {
    if (i == number_elems-1) //If its the last element,
    { //We can't look ahead, so break
            if (a[idx[i]] != a[idx[i-1]]) //Add it if its different from the previous
            {
                    csijury[fcounter] = a[idx[i]];
                    cvotes[fcounter] = 1;
                    fcounter++; //Increment fcounter to be consistent with the case
            } //where we do not break here
            break;
    }
    else if ((i != 0) && (a[idx[i]] == a[idx[i-1]])) //If the element is not the 1st &  the same as 
    { //the previous simply continue thru a[]
            continue;
    }
    csijury[fcounter] = a[idx[i]]; //For all other cases, copy the element
    cvotes[fcounter] = 1; //and initialize its vote to 1
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        cvotes[fcounter]++; //Count it
      }
      else
         break; //Break since the array is sorted
    fcounter++;
  }
  if (flag)
  {
          free (idx); //idx array is not needed now
  }
  return (fcounter); //fcounter is left at one more, which is good
                                                //because of the 0 indexing
}
