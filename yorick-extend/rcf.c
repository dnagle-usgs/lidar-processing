/*
 *
 *   $Id$
 *
 *   This file contains the c functions to implement the rcf.
 *   This is the intial part of the rcf.c file that is generated by the mkrcf.sh script.
 *   The contents of this file are simply copied into the rcf.c file
 *   
 *   c_fillarray is used in mode 2, to fill the winners into a yorick type array.
 *   XGetInfo is a function from std0.c, to get information on the array size
 *   
 *   Original rcf.i by W. Wright, 
 *   Converted to "C" by Conan Noronha
 */



#include "bcast.h"
#include "yio.h"
#include "defmem.h"
#include "pstdlib.h"
#include "play.h"
#include <string.h>
#include <stdio.h>
#include <errno.h>

static Member type;

/* This function is taken directly from Y_LAUNCH/std0.c 
 * to get the number of elements in the source array
 */

static DataBlock *XGetInfo(Symbol *s)
{
  DataBlock *db= 0;
  for (;;) {
    if (s->ops==&doubleScalar) {
      type.base= &doubleStruct;
      type.dims= 0;
      type.number= 1;
      break;
    } else if (s->ops==&longScalar) {
      type.base= &longStruct;
      type.dims= 0;
      type.number= 1;
      break;
    } else if (s->ops==&intScalar) {
      type.base= &intStruct;
      type.dims= 0;
      type.number= 1;
      break;
    } else if (s->ops==&dataBlockSym) {
      db= s->value.db;
      if (db->ops==&lvalueOps) {
        LValue *lvalue= (LValue *)db;
        type.base= lvalue->type.base;
        type.dims= lvalue->type.dims;
        type.number= lvalue->type.number;
      } else if (db->ops->isArray) {
        Array *array= (Array *)db;
        type.base= array->type.base;
        type.dims= array->type.dims;
        type.number= array->type.number;
      } else {
        type.base= 0;
        type.dims= 0;
        type.number= 0;
      }
      break;
    } else if (s->ops==&referenceSym) {
      s= &globTab[s->index];
    } else {
      YError("unexpected keyword argument");
    }
  }
  return type.base? 0 : db;
}

#define TBUFSIZE        32767
static unsigned int *winners, *fwinners, fcounter;	//Store the winners temporarily & global number of winners count.

short flag;	//Decides on the array use

unsigned int  twinners[ TBUFSIZE ], tidx[ TBUFSIZE ], tfwinners[ TBUFSIZE ];	//These arrays are only used when number_elems <= TBUFSIZE


/* Used to fill a 'Yorick' array with the winners indices
 * This function is called only for mode==2
 */

void c_fillarray (unsigned int *c)
{
   memcpy ((void*)c, (void*)fwinners, ((sizeof(unsigned int))*fcounter));	//Copy fwinners into the yorick array
   if (flag)
      free (fwinners);		//fwinners not needed now
}

/** CODE BELOW INSERTED FROM rcfbase2.c **/
/*
 * $Id$
 *
 * This file contains the base code to implement the rcf algorithm
 * It is used by the mkrcf.sh script, to generate 4 versiions of 
 * the code below. ie one version each for float, double, long and 
 * int type data.
 *
 * Original rcf.i by C.W.Wright
 * Converted to "C" by Conan Noronha
 *
 */
static float * fcopy; //Global pointer to the jury
/* Function to compare index values of the jury, based on the contents of
 * that indexed location. 
 * Used by qsort for float jury. Returns -1, 0 or 1
 */
int float_compare (const void *x, const void *y)
{
   unsigned int pp,qq;
   int t;
   pp = (unsigned int)(*(unsigned int *)x);
   qq = (unsigned int)(*(unsigned int *)y);
   if (fcopy[pp] < fcopy[qq]) t = -1;
   else
   if (fcopy[pp] == fcopy[qq]) t = 0;
   else t = 1;
   return t;
}
/* rcf algorithm for mode0.
 * Returns array b
 */
void rcf_float_0 (float* a, float w, float* b)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(float)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  fcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), float_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (float)counter) //Refresh the return array b, if necessary
    {
       b[1] = (float)counter;
       b[0] = a[idx[i]];
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
     free (idx); //idx array is also not needed now
}
/* rcf algorithm for mode 1.
 * Returns array b
 */
void rcf_float_1 (float *a, float w, float *b)
{
  unsigned int i, j, number_elems, counter, *idx;
  float tmp;
  DataBlock *db;
  if (w<=(float)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  fcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), float_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    tmp =a[idx[i]]; //The element itself will always be in the window
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        tmp += a[idx[j]];
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (float)counter) //Refresh the return array b, if necessary
    {
       b[1] = (float)counter;
       b[0] = tmp/(float)counter; //Mode 1, requests a mean
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
      free (idx); //idx array is also not needed now
}
/* rcf algorithm for mode 2.
 * Returns the number of winners
 */
unsigned int rcf_float_2 (float* a, float w)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(float)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        winners = twinners;
        fwinners = tfwinners;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        winners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        fwinners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  fcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), float_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    winners[counter-1] = idx[i]+1; //So add its index to winners...increment for yorick
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        winners[counter-1] = idx[j]+1; //In yorick, indexing starts from 1
      }
      else
         break; //Break since the array is sorted
    if (fcounter <= counter) //Refresh the return array b, if necessary
    {
       fcounter = counter; //Remember the counter value
                                                //For mode 2, store the winners 
       memcpy ((void *)fwinners, (void *)winners, ((sizeof(unsigned int))*fcounter));
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
  {
          free (winners); //Dont need winners anymore...they are in fwinners
          free (idx); //idx array is also not needed now
  }
  return fcounter;
}
void rcf_float_3 (float* a, float w, float* sorteda, unsigned int* votes)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(float)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-3); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  fcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), float_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    sorteda[i] = a[idx[i]]; //Fill the sorted a array
    votes[i]=1; //Each element starts with 1 vote
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        votes[i]++; //Count it
      }
      else
         break; //Break since the array is sorted
  }
  sorteda[number_elems-1]=a[idx[number_elems-1]];
  votes[number_elems-1]=1;
  if (flag)
  {
          free (idx); //idx array is also not needed now
  }
  return;
}
/*
 * $Id$
 *
 * This file contains the base code to implement the rcf algorithm
 * It is used by the mkrcf.sh script, to generate 4 versiions of 
 * the code below. ie one version each for float, double, long and 
 * int type data.
 *
 * Original rcf.i by C.W.Wright
 * Converted to "C" by Conan Noronha
 *
 */
static double * dcopy; //Global pointer to the jury
/* Function to compare index values of the jury, based on the contents of
 * that indexed location. 
 * Used by qsort for float jury. Returns -1, 0 or 1
 */
int double_compare (const void *x, const void *y)
{
   unsigned int pp,qq;
   int t;
   pp = (unsigned int)(*(unsigned int *)x);
   qq = (unsigned int)(*(unsigned int *)y);
   if (dcopy[pp] < dcopy[qq]) t = -1;
   else
   if (dcopy[pp] == dcopy[qq]) t = 0;
   else t = 1;
   return t;
}
/* rcf algorithm for mode0.
 * Returns array b
 */
void rcf_double_0 (double* a, double w, double* b)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(double)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  dcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), double_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (double)counter) //Refresh the return array b, if necessary
    {
       b[1] = (double)counter;
       b[0] = a[idx[i]];
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
     free (idx); //idx array is also not needed now
}
/* rcf algorithm for mode 1.
 * Returns array b
 */
void rcf_double_1 (double *a, double w, float *b)
{
  unsigned int i, j, number_elems, counter, *idx;
  double tmp;
  DataBlock *db;
  if (w<=(double)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  dcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), double_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    tmp =a[idx[i]]; //The element itself will always be in the window
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        tmp += a[idx[j]];
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (float)counter) //Refresh the return array b, if necessary
    {
       b[1] = (float)counter;
       b[0] = tmp/(float)counter; //Mode 1, requests a mean
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
      free (idx); //idx array is also not needed now
}
/* rcf algorithm for mode 2.
 * Returns the number of winners
 */
unsigned int rcf_double_2 (double* a, double w)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(double)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        winners = twinners;
        fwinners = tfwinners;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        winners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        fwinners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  dcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), double_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    winners[counter-1] = idx[i]+1; //So add its index to winners...increment for yorick
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        winners[counter-1] = idx[j]+1; //In yorick, indexing starts from 1
      }
      else
         break; //Break since the array is sorted
    if (fcounter <= counter) //Refresh the return array b, if necessary
    {
       fcounter = counter; //Remember the counter value
                                                //For mode 2, store the winners 
       memcpy ((void *)fwinners, (void *)winners, ((sizeof(unsigned int))*fcounter));
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
  {
          free (winners); //Dont need winners anymore...they are in fwinners
          free (idx); //idx array is also not needed now
  }
  return fcounter;
}
void rcf_double_3 (double* a, double w, double* sorteda, unsigned int* votes)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(double)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-3); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  dcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), double_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    sorteda[i] = a[idx[i]]; //Fill the sorted a array
    votes[i]=1; //Each element starts with 1 vote
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        votes[i]++; //Count it
      }
      else
         break; //Break since the array is sorted
  }
  sorteda[number_elems-1]=a[idx[number_elems-1]];
  votes[number_elems-1]=1;
  if (flag)
  {
          free (idx); //idx array is also not needed now
  }
  return;
}
/*
 * $Id$
 *
 * This file contains the base code to implement the rcf algorithm
 * It is used by the mkrcf.sh script, to generate 4 versiions of 
 * the code below. ie one version each for float, double, long and 
 * int type data.
 *
 * Original rcf.i by C.W.Wright
 * Converted to "C" by Conan Noronha
 *
 */
static long * lcopy; //Global pointer to the jury
/* Function to compare index values of the jury, based on the contents of
 * that indexed location. 
 * Used by qsort for float jury. Returns -1, 0 or 1
 */
int long_compare (const void *x, const void *y)
{
   unsigned int pp,qq;
   int t;
   pp = (unsigned int)(*(unsigned int *)x);
   qq = (unsigned int)(*(unsigned int *)y);
   if (lcopy[pp] < lcopy[qq]) t = -1;
   else
   if (lcopy[pp] == lcopy[qq]) t = 0;
   else t = 1;
   return t;
}
/* rcf algorithm for mode0.
 * Returns array b
 */
void rcf_long_0 (long* a, long w, long* b)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(long)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  lcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), long_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (long)counter) //Refresh the return array b, if necessary
    {
       b[1] = (long)counter;
       b[0] = a[idx[i]];
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
     free (idx); //idx array is also not needed now
}
/* rcf algorithm for mode 1.
 * Returns array b
 */
void rcf_long_1 (long *a, long w, float *b)
{
  unsigned int i, j, number_elems, counter, *idx;
  long tmp;
  DataBlock *db;
  if (w<=(long)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  lcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), long_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    tmp =a[idx[i]]; //The element itself will always be in the window
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        tmp += a[idx[j]];
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (float)counter) //Refresh the return array b, if necessary
    {
       b[1] = (float)counter;
       b[0] = tmp/(float)counter; //Mode 1, requests a mean
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
      free (idx); //idx array is also not needed now
}
/* rcf algorithm for mode 2.
 * Returns the number of winners
 */
unsigned int rcf_long_2 (long* a, long w)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(long)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        winners = twinners;
        fwinners = tfwinners;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        winners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        fwinners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  lcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), long_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    winners[counter-1] = idx[i]+1; //So add its index to winners...increment for yorick
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        winners[counter-1] = idx[j]+1; //In yorick, indexing starts from 1
      }
      else
         break; //Break since the array is sorted
    if (fcounter <= counter) //Refresh the return array b, if necessary
    {
       fcounter = counter; //Remember the counter value
                                                //For mode 2, store the winners 
       memcpy ((void *)fwinners, (void *)winners, ((sizeof(unsigned int))*fcounter));
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
  {
          free (winners); //Dont need winners anymore...they are in fwinners
          free (idx); //idx array is also not needed now
  }
  return fcounter;
}
void rcf_long_3 (long* a, long w, long* sorteda, unsigned int* votes)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(long)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-3); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  lcopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), long_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    sorteda[i] = a[idx[i]]; //Fill the sorted a array
    votes[i]=1; //Each element starts with 1 vote
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        votes[i]++; //Count it
      }
      else
         break; //Break since the array is sorted
  }
  sorteda[number_elems-1]=a[idx[number_elems-1]];
  votes[number_elems-1]=1;
  if (flag)
  {
          free (idx); //idx array is also not needed now
  }
  return;
}
/*
 * $Id$
 *
 * This file contains the base code to implement the rcf algorithm
 * It is used by the mkrcf.sh script, to generate 4 versiions of 
 * the code below. ie one version each for float, double, long and 
 * int type data.
 *
 * Original rcf.i by C.W.Wright
 * Converted to "C" by Conan Noronha
 *
 */
static int * icopy; //Global pointer to the jury
/* Function to compare index values of the jury, based on the contents of
 * that indexed location. 
 * Used by qsort for float jury. Returns -1, 0 or 1
 */
int int_compare (const void *x, const void *y)
{
   unsigned int pp,qq;
   int t;
   pp = (unsigned int)(*(unsigned int *)x);
   qq = (unsigned int)(*(unsigned int *)y);
   if (icopy[pp] < icopy[qq]) t = -1;
   else
   if (icopy[pp] == icopy[qq]) t = 0;
   else t = 1;
   return t;
}
/* rcf algorithm for mode0.
 * Returns array b
 */
void rcf_int_0 (int* a, int w, int* b)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(int)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  icopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), int_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (int)counter) //Refresh the return array b, if necessary
    {
       b[1] = (int)counter;
       b[0] = a[idx[i]];
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
     free (idx); //idx array is also not needed now
}
/* rcf algorithm for mode 1.
 * Returns array b
 */
void rcf_int_1 (int *a, int w, float *b)
{
  unsigned int i, j, number_elems, counter, *idx;
  int tmp;
  DataBlock *db;
  if (w<=(int)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-2); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  icopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), int_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    tmp =a[idx[i]]; //The element itself will always be in the window
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        tmp += a[idx[j]];
      }
      else
         break; //Break since the array is sorted
    if (b[1] <= (float)counter) //Refresh the return array b, if necessary
    {
       b[1] = (float)counter;
       b[0] = tmp/(float)counter; //Mode 1, requests a mean
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
      free (idx); //idx array is also not needed now
}
/* rcf algorithm for mode 2.
 * Returns the number of winners
 */
unsigned int rcf_int_2 (int* a, int w)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(int)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-1); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
        winners = twinners;
        fwinners = tfwinners;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
        winners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
        fwinners = (unsigned int *) malloc ((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  icopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), int_compare);//Sort the copy
  fcounter = 0;
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    counter=1;
    winners[counter-1] = idx[i]+1; //So add its index to winners...increment for yorick
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        counter++; //Count it
        winners[counter-1] = idx[j]+1; //In yorick, indexing starts from 1
      }
      else
         break; //Break since the array is sorted
    if (fcounter <= counter) //Refresh the return array b, if necessary
    {
       fcounter = counter; //Remember the counter value
                                                //For mode 2, store the winners 
       memcpy ((void *)fwinners, (void *)winners, ((sizeof(unsigned int))*fcounter));
    }
    if (a[idx[number_elems-1]] < a[idx[i]]+w) //Break the whole process when the last element in 
      break; //the sorted copy falls in a window of some element
  }
  if (flag)
  {
          free (winners); //Dont need winners anymore...they are in fwinners
          free (idx); //idx array is also not needed now
  }
  return fcounter;
}
void rcf_int_3 (int* a, int w, int* sorteda, unsigned int* votes)
{
  unsigned int i, j, number_elems, counter, *idx;
  DataBlock *db;
  if (w<=(int)0)
    YError("Window size must be positive");
  db = XGetInfo(sp-3); //stack pointer-3 is the source array 
  if (!db)
     number_elems= (unsigned int)type.number; //Get the number of elements in the source array
  else
     number_elems= 0;
  if (number_elems <= TBUFSIZE)
          flag = 0;
  else
          flag =1;
  if (!flag) //Use arrays if number_elems is less than array size
  {
        idx = tidx;
  }
  else
  {
        idx = (unsigned int*)malloc((sizeof(unsigned int))*number_elems);
  }
  for (i=0; i<number_elems; i++)
          idx[i]=i;
  icopy = a; //Make the jury gloabally accessible
  qsort(idx, number_elems, sizeof(unsigned int), int_compare);//Sort the copy
  for (i=0; i<number_elems-1; i++) //For each element in the copy
  {
    sorteda[i] = a[idx[i]]; //Fill the sorted a array
    votes[i]=1; //Each element starts with 1 vote
    for (j=i+1; j< number_elems;j++) //For each subsequent element
      if (a[idx[j]] < a[idx[i]]+w) //If it lies in the window
      {
        votes[i]++; //Count it
      }
      else
         break; //Break since the array is sorted
  }
  sorteda[number_elems-1]=a[idx[number_elems-1]];
  votes[number_elems-1]=1;
  if (flag)
  {
          free (idx); //idx array is also not needed now
  }
  return;
}
