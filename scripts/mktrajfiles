#!/usr/bin/perl -w

# This should be run from a YYYY/trajectories directory.
# It will then take each zip file and look for the proper place to put it.

# File naming convention:
# YYYY-MM-DD-A-B-yyyy-mm-dd-AAA-AAAA-BBBB-CCCCC-wgs84-CCC-DDD.txt
#
# where:
#
# YYYY-MM-DD : flight date
# A          : flight "number", A, B, C...
# B          : B P - Broadcast / Precision trajectory
# yyyy-mm-dd : processing date when trajectory was created
# AAA        : Creator initials
# AAAA       : Airport ID
# BBBB       : Remote ground station
# CCCCC      : Airplane callsign
# wgs84
# CCC        : cmb fwd rev - Combined, Forward only, Reverse only
# DDD        : ins pnav
# .txt
#
# use strict;     # This breaks $getopt

my $Id     = '$Id$';
my $Source = '$Source$';

use warnings;
use Getopt::Long;

my $help;         # quiet the warning message
my $getopt;       # quiet the warning message
my $options;

my $myint;
my $magic;
my $myfloat;
my $mystr;
my $verbose;

my $today = `date +"%Y-%m-%d"`; chop $today;
my $log = "../../alps/trajectories.log";

sub showusage {
  print <<EOF;
$Id
$Source

$0 [-norun] [-verbose] [where] [file1] [file2]

run from a YYYY/trajectories directory.
It finds where each zip file should be unzipped, unzips it, and runs pnav2ybin
as necessary.

If filenames are listed on the cmdline, only those files are checked to
see if they need to be installed.

Each zip file is displayed as it is processed, regardless of the options used.

-norun    : don't execute anything, just show what would have been done.
-verbose  : show more diagnostics
-where    : force showing where it'll put the file, even if already installed

EOF

# print out actual GetOptions() used if -nohelp is specified.
printf("\n%s\n", $options) if ( $help == 0 );

  exit(0);
}

############################################################
# defaults are supplied in GetOptions itself
# use: perldoc Getopt::Long           # to get the manpage #

$options = <<END;
\$getopt = GetOptions (
  'help!'      => \\( \$help = -1   ),  # use -nohelp to show this
  'norun'      => \\( \$norun    =  0   ),  # don't execute anything, just show what would have been done
  'verbose!'   => \\( \$verbose  = -1   ),  # show more diagnostics
  'where'      => \\( \$where    =  0   ),  # force showing where it'll put the file, even if already installed
);
&showusage() if (\$help >= 0);
END

eval $options;
&showusage() if ($getopt == 0); # result is 1 if no errors


############################################################


# check to see if any filenames were supplied on the cmdline.
# if so, only process those, else check everything
if ( $#ARGV >= 0 ) {
  my $list="";
  for ($i=0; $i<=$#ARGV; ++$i) {
    $list .= $ARGV[$i] . " ";
  }
  $LS_CMD = "ls $list|";
}  else {
  $LS_CMD = "ls *.zip|";
}

############################################################

$startdir = `pwd`;
chop $startdir;

open(LS, $LS_CMD) || die("Unable to run $LS_CMD\n");
while ( $file = <LS> ) {
  chop $file;

  my ($A, $B, $C, $D, $E, $junk) = split(/-/, $file, 6);
  if ($A =~ /^(\d{4})(\d{2})(\d{2})/) {
    $y = $1;
    $m = $2;
    $d = $3;
  } elsif ( $A =~ /\D/ ) {
    $y = $m = $d = 0;
  } elsif ( $A < 1990 ) {
    $m = $A;
    $d = $B;
    $y = $C;

    $y =~ s/[a-zA-Z]//g;   # force it into being a numeric when VR misses a "-"
    $y += 2000 if ( $y < 20 );
    $y += 1900 if ( $y < 100);
  } elsif(length($A) < 5) {
    $y = $A;
    $m = $B;
    $d = $C;
  } else {
    $y = $m = $d = 0;
  }

  # Now determine which flight
  # the 4th field is new and conflicts with the (now) 5th field,
  # so we first check to see if the 5th field is the new or the
  # orig 5th field

  if ( $E =~ /\D/ ) {      # 5th field is non-numeric, must be new
    $f = sprintf("-%s", $D );
  } else {
    $f = "";               # old format, set to null

  }

  $YYYYMMDD = sprintf("%04d%02d%02d%s", $y, $m, $d, $f);
  $YYYY_MM_DD = sprintf("%04d-%02d-%02d%s", $y, $m, $d, $f);

  printf("%s\t%s\n", $YYYY_MM_DD, $file);

  open(FIND1, "find .. -follow -type d -name $YYYYMMDD -or -type d -name $YYYY_MM_DD |") || die("Unable to run find1\n");
  while ( $dir = <FIND1> ) {
    chop $dir;
    $tmp = $dir . "/trajectories";
    $dir = $tmp;

    printf("\t%s\tdestination\n", $dir) if ( $where );
    if ( ! -d $dir ) {
      printf("\t%s\tdestination\n", $dir) if ( ! $where );  # don't show twice
      printf("$dir does not exist, creating\n");
      mkdir ( $dir ) if ( ! $norun );
    }
    chdir($dir );

    ###### Leave the zip file where it is, but expand it in the new location.

    $zipdir =  $file;
    $zipdir =~ s/\.zip//;

    if ( ! -d $zipdir ) {
      open(LOG, ">> $log") || die("Unable to open >>$log<<") if ( ! $norun );
      printf("\tmaking %s/%s\n", $dir,$zipdir);
      mkdir ( $zipdir ) if ( ! $norun );
      chdir ( $zipdir );
      printf("\tunzip ../%s\n", $zipdir) if ( $verbose );
      # -j junks the directory structure inside the zip file.
      system("unzip -j $startdir/" . $zipdir) if ( ! $norun );

      # Check to see if this was a gps trajectory
      open(FIND2, "find . -follow -name  \"\*cmb-pnav\" -or -name \"\*pnav.txt\"|")
        || die ("Unable to run find2\n");
      while ( $txt = <FIND2> ) {
        chop $txt;
        printf ("LOG: %s %s\n", $today, $txt );
        printf LOG ("%s %s\n", $today, $txt ) if ( ! $norun );
        printf("\tpnav2ybin $txt\n")  if ( $verbose );
        system("pnav2ybin $txt") if ( ! $norun );
      }

      # Check to see if this was an ins trajectory
      open(FIND2, "find . -follow -name  \"\*imu.txt\" -or -name \"\*ins.txt\" |")
        || die ("Unable to run find2\n");
      while ( $txt = <FIND2> ) {
        chop $txt;
        printf LOG ("%s %s\n", $today, $txt ) if ( ! $norun );
        $txt =~ s/\.\///;
        printf("\tiex_ascii2pbd $txt\n")  if ( $verbose );
        system("iex_ascii2pbd `pwd`/$txt") if ( ! $norun );
      }
      close( LOG ) if ( ! $norun );
    }

    chdir ($startdir);     # go back to our starting directory

  }
  close (FIND1);

}
close (LS);
