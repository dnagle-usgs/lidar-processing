#!/usr/bin/perl
# vim: set tabstop=3 softtabstop=3 shiftwidth=3 autoindent shiftround expandtab:

####
# This script is used to determine the root mean square distance between pairs
# of control points among CIR images, using their associated JGW files. It
# relies on .pto files, which are output by the panotools and Hugin programs;
# they contain control points that tie locations between two images. It also
# uses JGW files, which are JPEG world files, generated by the ALPS software
# (using cir-mosiac.i).
#
# This script is typically used by tune_cir_parameters (in cir-mosaic.i).
#
# It takes two command-line arguments. Arg 1 is the pto directory, and arg 2 is
# the jgw directory. All ptos must be in a single directory. All jgws must be
# in a single directory.
#
# Distances are calculated for each pair of points, so there are $points values
# that determine the root mean squared distance.
#
# This script is an adaptation of pto_analysis.pl from the ADAPT project, trunk
# revision 141.
####

use strict;
use warnings;

use File::Util;
use Math::Vec;
use List::Util qw/sum/;

die "Need 2 args: ptodir jgwdir\n" unless(scalar(@ARGV) == 2);

my($ptodir, $jgwdir);
$ptodir = $ARGV[0];
$jgwdir = $ARGV[1];

my $pi = atan2(0, -1);

my @ptofiles = <$ptodir/*.pto>;

my @distance;

# Iterate through every .pto file
foreach my $file (@ptofiles) {
   my $data = readpto($file);
   # $ties are the control points
   my $ties = $data->[0];
   # @files are the names of the image files
   my @files = @{$data->[1]};
   
   # Iterate through each pair of images in the file
   foreach my $a (keys %{$ties}) {
      foreach my $b (keys %{$ties->{$a}}) {
         my @jgw_a = readjgw("$jgwdir/$files[$a]");
         my @jgw_b = readjgw("$jgwdir/$files[$b]");
         # Iterate through each pair of points
         foreach my $i (0 .. $#{$ties->{$a}{$b}}) {
            my ($sx1, $sy1, $sx2, $sy2) = @{$ties->{$a}{$b}[$i]};
            my ($ix1, $iy1) = jgwtransform($sx1, $sy1, @jgw_a);
            my ($ix2, $iy2) = jgwtransform($sx2, $sy2, @jgw_b);
            my $d = sqrt(($ix1 - $ix2) ** 2 + ($iy1 - $iy2) ** 2);
            push @distance, $d;
         }
      }
   }
}

my $rmse = sqrt( (sum map { $_ * $_ } @distance ) / scalar @distance );
print "$rmse\n";

# Transforms coordinates based on the worldfile
sub jgwtransform {
   my $sx = shift;
   my $sy = shift;
   my @jgw = @_;
   my $dx = $jgw[0] * $sx + $jgw[2] * $sy + $jgw[4];
   my $dy = $jgw[1] * $sx + $jgw[3] * $sy + $jgw[5];
   return ($dx, $dy);
}

# Reads JGW and returns its affine numbers
sub readjgw {
   my $infile = shift;
   $infile =~ s/jpg$/jgw/;
   open(IN, "<", $infile) or die("Could not open $infile");
   my @lines = <IN>;
   close(IN) or die("Couldn't close $infile");
   return map { $_ * 1 } @lines;
}

# Reads and parses a PTO file and returns its interesting contents
sub readpto {
   my $infile = shift;

   my $ties;
   my @files;
   my $fu = File::Util->new();

   open(IN,  "<", $infile) or die("Could not open $infile");
   foreach my $line (<IN>) {
      chomp $line;
      # These are specific patterns found within PTO files thus far
      if($line =~ /^c\s+.*n(\d+)\s+N(\d+)\s+x([.\d]+)\s+y([.\d]+)\s+X([.\d]+)\s+Y([.\d]+)/) {
         push @{$ties->{$1}{$2}}, [ map { $_ * 1 } ($3, $4, $5, $6) ];
      }
      if($line =~ /#-imgfile .* "(.*\.jpg)"/) {
         push @files, $fu->strip_path($1);
      }
      if($line =~ /n"(.*\.jpg)"/) {
         push @files, $fu->strip_path($1);
      }
   }
   close(IN) or die("Couldn't close $infile");

   return [$ties, \@files];
}
