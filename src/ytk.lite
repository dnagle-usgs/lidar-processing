#!/bin/sh
# \
	exec wish "$0" ${1+"$@"}

# /* vim: set tabstop=3 softtabstop=3 shiftwidth=3 shiftround autoindent syntax=tcl: */

# Program to add some limited tcl/Tk GUI capability to Yorick programs.
#
#  C. W. Wright   wright@lidar.wff.nasa.gov
#
# $Id$
#  
# This program is copyrighted under the terms of 
# The GNU GENERAL PUBLIC LICENSE,  Version 2, June 1991.
# A full copy can be found at: http://www.gnu.org/licenses/gpl.txt
#
# 
#
# The main site for this program is:
#     http://ytk.sourceforge.net
# *** NOTE: The newer version at ytk.sourceforge.net isn't compatible
# with ytk (yet) so don't try using it.
#
# The easiest way to get this program working it to download and use
# the ActiveTcl from:        http://aspn.activestate.com/ASPN/Tcl
#
# The best source (according to Dave Munro) for Yorick is:
#  http://rhcontrib.bero.org 
#  Look under "Development/Languages" to find it.  The main site
# for Yorick is:   ftp://ftp-icf.llnl.gov/pub/Yorick/doc/index.html
# Another version of Yorick with builtin command history and
# an ability for dynamic linking of "C" modules is at:
# https://sourceforge.net/projects/yorick-mb/
#
#
# Make "most recent" persist from run to run.
# Stuff to add sometime.
# popup balloon help
# expand plot menus
# time calculator
# some method to "alias" the window names to names meaningful to a project
# fg/bg color change method for plot so we could have colors on black
# html help stuff.
#
#
#  
#
#
# Revision history
#
# 06/02/2005 - Amar Nayegandhi
#  Added option to use rlwrap or rlterm with yorick. Default setting uses
#  rlwrap. Download rlwrap from: http://www.maumae.net/yorick/rlwrap-0.18.tar.gz
#
# 5/31/2003 Added runline commands.  Now you can say:  ytk somefile.[ytk,i,tcl,tk]
# 1/3/2002
#  -> Added  extended help for menu items.
#  -> Moved fifos to users home dir and use a unique name so several
#     Ytks can run at once.
#  -) Added "Save Options" button in Edit pulldown.
#  -) Added .ytkrc default file in users home dir.
#  -) Changed many variables to be elements of the _ytk array so
#     they can easily be saved/restored in .ytkrc
#
#   1/2/2002 ww *) Moved fifos to user's home dir and added some "uniqueness"
#                  to the name to avoid problems when two or more ytks are running.
# 12/31/2001 ww *) Minor changes to gracefully fail if ytk can't find Yorick.
#               *) Added code to look for yorick and rlterm and use what it
#                  finds if it can't use what the user provided.
# 12/28/2001 ww Added some simple most recent file selection stuff
# 12/21/2001 ww Added /tmp/ytk fifo for passing data back from yorick
#               to tcl/tk.  Also added /tmp/tky for sending stuff from
#               tcl/tk to Yorick in cases where you want/need to avoid
#               using the exp_send command.
#  
#

if { $argc != 0 } {
	puts $argv
		set load_on_start $argv
} else {
	set load_on_start ""
}


variable ycode_dir "."
variable Y_SITE ""

proc restore_defaults { } {
	global _ytk
	set _ytk(yorick_executable)	/usr/local/bin/yorick
	set _ytk(use_rlterm)				No
	set _ytk(use_rlwrap)				Yes
	set _ytk(separate_help_win)	Yes
	set _ytk(ycode_dir)				.
}

restore_defaults 			;# begin with the above default settings


############################################################
# Stuff below here doesn't need to be changed if you are
# just porting to another system.
############################################################

package require BWidget
package require fileutil

set ytk_version "Ytk version 1.0  as of 1/3/2002"

set ytk_PLMK_marker(None)					0
set ytk_PLMK_marker(Square)				1
set ytk_PLMK_marker(Cross)					2
set ytk_PLMK_marker(Triangle)				3
set ytk_PLMK_marker(Circle)				4
set ytk_PLMK_marker(Diamond)				5
set ytk_PLMK_marker(Cross45)				6
set ytk_PLMK_marker(Inverted-Triangle) 7

proc save_options { } {
	global _ytk
	set fn "~/.ytkrc"
	if { [ catch { set f [ open $fn "w+" ] } err ] } {
		tk_messageBox -icon error -message $err -type ok
	} else { 
		set names [ array names _ytk ];
		foreach x $names { 
			set s [ format "set %32s    %-32s"  "_ytk($x)" $_ytk($x) ]; 
			puts $f "$s"
		}
		close $f
			tk_messageBox -icon info -message "Options saved to: $fn" -type ok
	}
}

# Check for a .ytkrc file in the users home dir.
if { [ file exists "~/.ytkrc" ] } {
	puts "Found .ytkrc...."
	if { [ catch { source "~/.ytkrc" } err ] } {
		puts "Problem in ~/.ytkrc: $err "
	}
} else {			;# No ~.ytkrc found, so use defaults
	puts "No  ~/.ytkrc found, using defaults"
}

wm withdraw .
if { [ catch { package require Expect } err ]  } {
	tk_messageBox -icon error \
		-message "$err\n Ytk cannot function without ExpectK. Sorry." -type ok
	exit
} 

catch { set rlterm [ exec which rlterm ] }
catch { set rlwrap [ exec which rlwrap ] }

############# set _ytk(yorick_executable) junk
puts "e: $_ytk(yorick_executable)"
if { [ file exists $_ytk(yorick_executable) ] == 0 } {
	catch { set _ytk(yorick_executable)  [ exec which yorick ] }
	if { [ file exists _ytk(yorick_executable) ] == 0 } {
		tk_messageBox -icon error \
			-message "$err\n Ytk cannot function without Yorick.\n\
			Please click OK, and then use the file dialog to find a Yorick we can use." -type ok
			set _ytk(yorick_executable) [ tk_getOpenFile -initialdir "/" ]
	}
}

# fifo name for data coming from yorick.
set ytk_fifo_name "/tmp/ytkfifo.[ pid ]"

# fifo name for special data going to yorick.
set tky_fifo_name "/tmp/tkyfifo.[ pid ]"

set rn 1
set tkcmd_line 0

# Establish fifo for communications from Yorick ---> tcl/tk
if { [ file exists $ytk_fifo_name ] == 0 } {
	exec mkfifo -m uog+rw "$ytk_fifo_name" 
}
set ytk_fifo [ open $ytk_fifo_name "r+" ] 
fconfigure $ytk_fifo -buffering line -blocking 0

# Establish fifo for communications to  Yorick <---- tcl/tk
if { [ file exists $tky_fifo_name ] == 0 } {
	exec mkfifo -m uog+rw "$tky_fifo_name"
}
set tky_fifo [ open $tky_fifo_name "r+" ] 
fconfigure $tky_fifo -buffering line -blocking 0

fileevent $ytk_fifo readable {
	global tkcmd_line
	incr tkcmd_line
	set ycmdstr [ gets $ytk_fifo ]  
	if { [ catch { eval $ycmdstr } errcode ] } {
		send_user "*** Ytk Error in:$ycmdstr"
		incr tkcmd_line
	}
	update
}

set noyorick 0
if { [ info exists rlterm ] && [ string equal $_ytk(use_rlterm) "Yes" ]  } {
	if { [ catch  { spawn $rlterm $_ytk(yorick_executable) } ] } {
		set noyorick 1
	} 
} else {
	if { [ info exists rlwrap ] && [ string equal $_ytk(use_rlwrap) "Yes" ]  } {
		if { [ catch  { spawn $rlwrap -c -b \t\n\r\ \(\)\{\}\[\],+=\&^%\$#@\\\"\;\|  $_ytk(yorick_executable) } ] } {
			set noyorick 1
		} 
	} else {
		if { [ catch  { spawn $_ytk(yorick_executable) } ] } {
			set noyorick 1
		} 
	} 
}
if { $noyorick } {
	puts {Could't find Yorick.  Please edit "ytk" and set "_ytk(yorick_executable)" to your Yorick location}
	file delete $ytk_fifo_name
	file delete $tky_fifo_name
	exit
}


expect "Yorick * ready"
set yorick_version [ lindex [ split $expect_out(0,string) ] 1 ]
expect ">"
exp_send "_ytk = 1\r"
expect ">"
exp_send "Y_SITE\r"
expect -re {"(.*)"}
set Y_SITE $expect_out(1,string)
expect ">"

if { [ file exists "$Y_SITE/contrib/ytk.i" ] == 0 } {
	tk_messageBox -icon error \
		-message "Can't find ytk.i. \n\
		Find the ytk.i file from the Ytk  from the distribution \n\
		and put it somewhere in your Yorick path."  -type ok
		file delete $ytk_fifo_name
		file delete $tky_fifo_name
		exit
}
exp_send "#include \"ytk.i\"\r"
expect ">"
exp_send "open_tkcmd_fifo, \"$ytk_fifo_name\"\r"
set indoc 0
set hwin 0
puts $spawn_id
match_max -i $spawn_id 32768

proc load_and_run { fn } {
	switch [ file extension $fn ] {
		".tcl" -
		".tk"  -
		".ytk" {  
			if { [ file exists $fn ] == 0 } { 
				tk_messageBox -icon error -message "$fn not found"
				exit
			}
			uplevel #0 " source $fn "
		}
		".i" {   
			set ycode_dir [ file dirname $fn ]
			cd $ycode_dir
			exp_send "cd, \"$ycode_dir\"\r"
			exp_send "#include \"$fn\"\r"
		}
		default {
			tk_messageBox -icon error -message "$fn not found"
			exit
		}
	}
}

wm state . normal
if { $load_on_start != "" } {
	load_and_run $load_on_start;
}

proc yorick {}  {
   global _ytk
   global interact_out indoc hwin
   global str
   global Y_SITE
   upvar  spawn_id spawn_id
   expect ">"
   set n 0;
   interact   {
      -o
      -nobuffer
      -re "/\\* DOCUMENT.*\n" {
         regsub -all "\r" $interact_out(0,string) "" str
         if { $_ytk(separate_help_win) == "Yes" } {
            interact {
               -o
               -re ".*\\*/" {
                  regsub -all "\r" $interact_out(0,string) "" str2
                  set str "$str$str2"
                  incr hwin
                  set wintitle [ lindex [ split $str "\n" ] 0 ]
                  toplevel .docwin$hwin
                  set cmd "scrollbar .docwin$hwin.sb -command {.docwin$hwin.doc yview }"
                  eval $cmd

                  set cmd "text .docwin$hwin.doc  -height 25 \
                     -yscrollcommand {  .docwin$hwin.sb set }"
                  eval $cmd
                  .docwin$hwin.doc insert end $str
                  pack .docwin$hwin.doc -side left -fill both -expand 1
                  pack .docwin$hwin.sb -side left -fill y -expand 0
                  wm title .docwin$hwin $wintitle
                  return
               }
               timeout 1 return
            }
         }
      }
   }
}

wm withdraw .
yorick
file delete $ytk_fifo_name
file delete $tky_fifo_name
exit
