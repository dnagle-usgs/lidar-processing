# vim: set tabstop=3 softtabstop=3 shiftwidth=3 autoindent shiftround expandtab:

package require dict
package require struct::set
package require msgcat

################################################################################
#
#  This needs to handle the following:
#     fit_gauss (fit_gauss.i)
#     ex_bath (ref: raspulsearch.i; bathy.i)
#     ex_veg (ref: raspulseach.i; veg.i)
#     show_wf (ref: raspulsearch.i; drast.i)
#     geo_rast (ref: raspulsearch.i; drast.i)
#     dump_info (raspulsearch.i)
#     raspulsearch_groundtruth (raspulseach.i)
#
#  #####
#
#  fit_gauss, raster, pulse, graph=, add_peak=, lims=, verbose=
#
#  #####
#
#  ex_bath, raster, pulse, win=0, graph=1
#
#  #####
#
#  ex_veg, raster, pulse, last=int(250), graph=0/1, win=int(0), use_be_peak=0/1
#     use_be_centroid=0/1, hard_surface=0/1
#
#  #####
#
#  show_wf, *wfa, pulse, win=(0 or 7), raster=raster, c1=, c2=, c3=
#
#  #####
#
#  geo_rast, raster, win=2 (, fsmarks=(0/1), eoffset=double(0)/meters)
#
#  #####
#
#  r = get_erast(rn=raster)
#  rr = decode_raster(r)
#  wfa = ndrast(rr, win=??, graph=??)
#
################################################################################

if {![namespace exists ::pixelwf]} {
   # Initialization and Traces only happen first time ::pixelwf is created.

################################################################################
#                                Initialization                                #
################################################################################
   ybkg require \"pixelwf.i\"

   namespace eval ::pixelwf {
      namespace eval vars {
         namespace eval selection {
            variable raster 1
            variable pulse 1
            variable radius 10.00
         }
         namespace eval fit_gauss {
            variable enabled 1
            variable win 10
            variable add_peak 0
            variable lims 0
            variable lims_x1 1
            variable lims_x2 2
            variable verbose 0
            variable dest_action 0
            variable dest_variable ""
         }
         namespace eval ex_bath {
            variable enabled 1
            variable win 7
            variable verbose 0
            variable dest_action 0
            variable dest_variable ""
         }
         namespace eval ex_veg {
            variable enabled 1
            variable last 250
            variable win 0
            variable verbose 0
            variable use_be_peak 1
            variable use_be_centroid 0
            variable hard_surface 0
            variable dest_action 0
            variable dest_variable ""
         }
         namespace eval show_wf {
            variable enabled 1
            variable win 7
            variable c1 1
            variable c2 1
            variable c3 1
         }
         namespace eval geo_rast {
            variable enabled 1
            variable win 2
            variable verbose 0
            variable fsmarks 0
            variable eoffset 0
         }
         namespace eval ndrast {
            variable enabled 1
            variable win 1
            variable units ns
            variable dest_action 0
            variable dest_variable ""
         }
      }
      namespace eval gui {
         variable widgets_tied_to_enabled {
            fit_gauss {}
            ex_bath {}
            ex_veg {}
            show_wf {}
            geo_rast {}
            ndrast {}
         }
      }
      namespace eval constants {
         # valid_ranges is a dict. It is used to apply bounding ranges on
         # variables using constrain.
         #
         # Keys into valid_ranges are the ranges, as a two-element list of {min
         # max}; optionally, a third element can be included which is the step
         # to use in between items when creating spinboxes (default: 1). Values
         # are themselves dicts, whose keys are namespaces and whose values are
         # lists of variables in those namespaces that need the range applied.
         variable valid_ranges {
            {1 100000000} {
               selection raster
               ex_veg last
            }
            {1 120} {selection pulse}
            {0 5} {fit_gauss add_peak}
            {0 63} {
               fit_gauss win
               ex_bath win
               ex_veg win
               show_wf win
               geo_rast win
               ndrast win
            }
            {0 100} {
               fit_gauss {lims_x1 lims_x2}
            }
            {-1000 1000 0.01} {geo_rast eoffset}
            {0.01 100 0.01} {selection radius}
         }
         # valid_values is a dict. It is used to restrict a variable's value to
         # a list of values.
         #
         # Keys into valid_values are the lists of values, as lists.  Values
         # are themselves dicts, whose keys are namespaces and whose values are
         # lists of variables in those namespaces that need the constraint
         # applied.
         variable valid_values {
            {0 1} {
               fit_gauss {enabled lims verbose}
               ex_bath {enabled verbose}
               ex_veg {enabled verbose use_be_peak use_be_centroid hard_surface}
               show_wf {enabled c1 c2 c3}
               geo_rast {enabled verbose fsmarks}
               ndrast {enabled}
            }
            {0 1 2} {
               fit_gauss dest_action
               ex_bath dest_action
               ex_veg dest_action
               ndrast dest_action
            }
            {meters ns feet} {ndrast units}
         }
         # valid_classes is a dict. It is used to restrict a variable's value to
         # the given string class.
         #
         # Keys into valid_classes are the class names.  Values are themselves
         # dicts, whose keys are namespaces and whose values are lists of
         # variables in those namespaces that need the constraint applied.
         variable valid_classes {
            integer {
               selection {raster pulse}
               fit_gauss {win add_peak lims_x1 lims_x2}
               ex_bath win
               ex_veg {last win}
               show_wf win
               geo_rast win
               ndrast win
            }
            double {
               selection radius
               geo_rast eoffset
            }
         }
         #
         variable valid_variables {
            fit_gauss dest_variable
            ex_bath dest_variable
            ex_veg dest_variable
            ndrast dest_variable
         }
         # output_possibilities is a list specifying the options that can be
         # used for the output of various panels
         variable output_possibilities {
            "Discard output"
            "Store output in..."
            "Append output to..."
         }
      }
   }

################################################################################
#                             User-Friendly Names                              #
################################################################################

   namespace eval ::pixelwf {
      namespace import ::msgcat::mcset

      # Universal
      mcset en win Window
      mcset en verbose Verbose

      # selection
      mcset en raster Raster
      mcset en pulse Pulse

      # fit_gauss
      mcset en "fit_gauss functionality" "Gaussian Deconvolution"

      # geo_rast
      mcset en "geo_rast functionality" "Georeferenced Raster"

      # ndrast
      mcset en units Units

      namespace forget mcset
   }

   namespace eval ::pixelwf {
      namespace import ::msgcat::mc
      namespace eval gui {
         namespace import ::msgcat::mc
      }
      namespace eval util {
         namespace import ::msgcat::mc
      }
   }

################################################################################
#                               Variable Traces                                #
################################################################################

   # Enforce string classes
   namespace eval ::pixelwf {
      dict for {class data} $constants::valid_classes {
         dict for {ns vars} $data {
            foreach var $vars {
               validation_trace append vars::${ns}::$var \
                  [list string is $class %V]
            }
            unset var
         }
         unset ns vars
      }
      unset class data
   }

   # Enforce valid Yorick variable names
   namespace eval ::pixelwf {
      dict for {ns vars} $constants::valid_variables {
         foreach var $vars {
            validation_trace append vars::${ns}::$var \
               {regexp {^[[:alpha:]_]\w*$} %V}
         }
         unset var
      }
      unset ns vars
   }

   # Enforce constrained values
   namespace eval ::pixelwf {
      dict for {values data} $constants::valid_values {
         dict for {ns vars} $data {
            foreach var $vars {
               validation_trace append vars::${ns}::$var \
                  [list ::struct::set contains [concat {""} $values] %V]
            }
            unset var
         }
         unset ns vars
      }
      unset values data
   }

   # Enforce constrained ranges
   namespace eval ::pixelwf {
      dict for {range data} $constants::valid_ranges {
         set range_min [lindex $range 0]
         set range_max [lindex $range 1]
         dict for {ns vars} $data {
            foreach var $vars {
               validation_trace append vars::${ns}::$var \
                  {expr {%V eq ""}} \
                  -invalidcmd [list constrain %v between $range_min and $range_max]
            }
            unset var
         }
         unset ns vars
      }
      unset range data
   }

   # Custom constraint: lims_x1 <= lims_x2
   namespace eval ::pixelwf::vars::fit_gauss {
      set x1 [namespace which -variable lims_x1]
      set x2 [namespace which -variable lims_x2]
      validation_trace append $x1 "expr {%V eq \"\" || %V < \$$x2}" \
         -invalidcmd "set $x2 %V"
      validation_trace append $x2 "expr {%V eq \"\" || %V > \$$x1}" \
         -invalidcmd "set $x1 %V"
   }

   # Add hook for toggling panel visibility
   namespace eval ::pixelwf::vars {
      foreach ns [list fit_gauss ex_bath ex_veg show_wf geo_rast ndrast] {
         validation_trace append ${ns}::enabled \
            {::pixelwf::gui::_trace_toggle_visibility %v}
      }
      unset ns
   }

   # Keep Yorick updated for all variables in the specified namespaces
   namespace eval ::pixelwf::vars {
      foreach ns [list selection fit_gauss ex_bath ex_veg show_wf geo_rast ndrast] {
         foreach var [info vars ${ns}::*] {
            set var [namespace tail $var]
            tky_tie append broadcast ${ns}::$var to pixelwfvars.$ns.$var -initialize 1
         }
         unset var
      }
      unset ns
   }
   # Special cases:
   tky_tie append broadcast ::pro_var to pixelwfvars.selection.pro_var -initialize 1
   tky_tie append broadcast ::win_no to pixelwfvars.selection.win -initialize 1

}; # (end of: if {![namespace exists ::pixelwf]})

################################################################################
#                               Core Procedures                                #
################################################################################
namespace eval ::pixelwf::util {
   proc helper_valid {type var} {
      # Not intended to be called directly... called by valid_*
      set var [uplevel 2 namespace which -variable $var]
      if {![string match ::pixelwf::vars::?*::?* $var]} {
         return
      }
      set varname [namespace tail $var]
      set nsname [namespace tail [namespace qualifiers $var]]
      dict for {valid data} [set ::pixelwf::constants::valid_$type] {
         if {[dict exists $data $nsname]} {
            set vars [dict get $data $nsname]
            if {[lsearch $vars $varname] >= 0} {
               return $valid
            }
         }
      }
      return
   }

   proc valid_range var {helper_valid ranges $var}
   proc valid_values var {helper_valid values $var}
   proc valid_class var {helper_valid classes $var}
}

namespace eval ::pixelwf::gui {
   proc trace_toggle_visibility {w v} {
      variable widgets_tied_to_enabled
      set name [namespace tail [namespace qualifiers \
         [uplevel namespace which -variable $v]]]
      dict lappend widgets_tied_to_enabled $name $w
   }

   proc _trace_toggle_visibility v {
      variable widgets_tied_to_enabled
      set name [namespace tail [namespace qualifiers \
         [uplevel namespace which -variable $v]]]
      # Try to roughly atomically get and clear the list... then re-add all
      # widgets that still exist.
      set widgets [K [dict get $widgets_tied_to_enabled $name] \
         [dict set widgets_tied_to_enabled $name [list]]]
      foreach widget $widgets {
         if {[winfo exists $widget]} {
            dict lappend widgets_tied_to_enabled $name $widget
            if {[uplevel set $v]} {
               grid $widget
               [winfo parent $widget] configure -height 0
            } else {
               grid remove $widget
               [winfo parent $widget] configure -height 24
            }
         }
      }
      return 1
   }

   proc helper_output_dest {cboAction entVariable ns} {
      iwidgets::combobox $cboAction -editable false -width 0 \
         -selectioncommand "set ${ns}::dest_action \[$cboAction curselection\]"

      foreach item $::pixelwf::constants::output_possibilities {
         $cboAction insert list end [mc $item]
      }

      # Ugly little work-around to get an initial value set up
      $cboAction selection set 0
      eval [bind [$cboAction component popup] <Return>]

      entry $entVariable -textvariable ${ns}::dest_variable -width 0
   }

   proc helper_spinbox {w v} {
      set range [::pixelwf::util::valid_range $v]
      lappend range 1
      spinbox $w -textvariable $v -width 0 \
         -from [lindex $range 0] -to [lindex $range 1] -increment [lindex $range 2]
   }

   proc helper_combobox {w v} {
      ::iwidgets::combobox $w -editable 0 -textvariable $v -width 0
      eval [list $w insert list 0] [::pixelwf::util::valid_values $v]
      tie_iw_combobox_textvariable $w
   }

   proc default_sticky args {
      set stickiness [dict create Button es Checkbutton w Entry ew Combobox ew \
         Label e Labelframe ew Frame ew Spinbox ew]
      foreach slave $args {
         set class [winfo class $slave]
         if {[dict exists $stickiness $class]} {
            grid configure $slave -sticky [dict get $stickiness $class]
         }
         if {$class eq "Frame" || $class eq "Labelframe"} {
            $slave configure -pady 2 -padx 2
         }
      }
   }

   proc launch_full_panel w {
      if {[winfo exists $w]} {destroy $w}
      toplevel $w

      set mf $w

      set f $mf.lfr_selection
      labelframe $f -text [mc Selection]
      grid $f -sticky new

      set childsite $f.child
      selection $childsite
      grid $childsite -sticky news

      grid columnconfigure $f 0 -weight 1
      grid rowconfigure $f 0 -weight 1

      foreach type [list fit_gauss ex_bath ex_veg show_wf geo_rast ndrast] {
         # Checkbox for frame
         set chk $mf.chk_$type
         checkbutton $chk -text [mc "Enable %s" [mc "$type functionality"]] \
            -variable ::pixelwf::vars::${type}::enabled

         # Parent frame
         set f $mf.lfr_$type
         labelframe $f -labelwidget $chk
         grid $f -sticky new

         # Child frame
         set childsite $f.child
         $type $childsite
         grid $childsite -sticky news

         grid columnconfigure $f 0 -weight 1
         grid rowconfigure $f 0 -weight 1

         trace_toggle_visibility $childsite ::pixelwf::vars::${type}::enabled
      }
      grid columnconfigure $mf 0 -weight 1
   }

   proc selection f {
      set ns ::pixelwf::vars::selection
      frame $f

      label $f.lblRaster -text [mc raster]:
      helper_spinbox $f.spnRaster ${ns}::raster

      label $f.lblPulse -text [mc pulse]:
      helper_spinbox $f.spnPulse ${ns}::pulse

      label $f.lblWindow -text [mc win]:
      spinbox $f.spnWindow -text [mc win]: -textvariable ::win_no \
         -from 0 -to 63 -increment 1 -width 0

      label $f.lblRadius -text [mc radius]:
      helper_spinbox $f.spnRadius ${ns}::radius

      label $f.lblVar -text [mc pro_var]:
      iwidgets::combobox $f.cboVar -textvariable ::pro_var -editable false -width 0
      $f.cboVar component list configure -listvariable ::varlist

      button $f.btnMouse -text [mc "Interactive"] \
         -command [list ycmd pixelwf_enter_interactive]

      grid $f.lblRaster $f.spnRaster $f.lblPulse $f.spnPulse
      grid $f.lblWindow $f.spnWindow $f.lblVar $f.cboVar
      grid $f.lblRadius $f.spnRadius $f.btnMouse -

      default_sticky \
         $f.lblRaster $f.spnRaster $f.lblPulse $f.spnPulse \
         $f.lblWindow $f.spnWindow $f.lblVar $f.cboVar \
         $f.lblRadius $f.spnRadius $f.btnMouse

      grid columnconfigure $f {0 2} -weight 0 -uniform 2
      grid columnconfigure $f {1 3} -weight 1 -uniform 1
   }

   proc fit_gauss f {
      set ns ::pixelwf::vars::fit_gauss
      frame $f

      label $f.lblWindow -text [mc win]:
      helper_spinbox $f.spnWindow ${ns}::win

      label $f.lblAddPeak -text [mc add_peak]:
      helper_spinbox $f.spnAddPeak ${ns}::add_peak

      # Limits needs to be reworked
      #checkbutton $f.chkLims -variable ${ns}::lims \
      #   -text [mc "Constrain lims from"]
      #helper_spinbox $f.spnLimsX1 ${ns}::lims_x1
      #label $f.lblLimsX2 -text [mc to]
      #helper_spinbox $f.spnLimsX2 ${ns}::lims_x2

      helper_output_dest $f.cboAction $f.entVariable $ns

      checkbutton $f.chkVerbose -text [mc verbose] -variable ${ns}::verbose
      button $f.btnGraph -text [mc fit_gauss] -command [list ybkg pixelwf_fit_gauss]

      grid $f.lblWindow $f.spnWindow $f.lblAddPeak $f.spnAddPeak
      #grid $f.chkLims $f.spnLimsX1 $f.lblLimsX2 $f.spnLimsX2
      grid $f.cboAction - $f.entVariable -
      grid $f.chkVerbose $f.btnGraph - -

      default_sticky \
         $f.lblWindow $f.spnWindow $f.lblAddPeak $f.spnAddPeak \
         $f.cboAction $f.entVariable \
         $f.chkVerbose $f.btnGraph

      grid columnconfigure $f {0 2} -weight 0 -uniform 2
      grid columnconfigure $f {1 3} -weight 1 -uniform 1
   }

   proc ex_bath f {
      set ns ::pixelwf::vars::ex_bath
      frame $f

      label $f.lblWindow -text [mc win]:
      helper_spinbox $f.spnWindow ${ns}::win

      helper_output_dest $f.cboAction $f.entVariable $ns

      checkbutton $f.chkVerbose -text [mc verbose] -variable ${ns}::verbose
      button $f.btnGraph -text [mc ex_bath] -command [list ybkg pixelwf_ex_bath]

      grid $f.lblWindow $f.spnWindow
      grid $f.cboAction $f.entVariable
      grid $f.chkVerbose $f.btnGraph

      default_sticky \
         $f.lblWindow $f.spnWindow \
         $f.cboAction $f.entVariable \
         $f.chkVerbose $f.btnGraph

      grid columnconfigure $f 1 -weight 1
   }

   proc ex_veg f {
      set ns ::pixelwf::vars::ex_veg
      frame $f

      label $f.lblWindow -text [mc win]:
      helper_spinbox $f.spnWindow ${ns}::win

      label $f.lblLast -text [mc last]:
      helper_spinbox $f.spnLast ${ns}::last

      helper_output_dest $f.cboAction $f.entVariable $ns

      checkbutton $f.chkBePeak -text [mc use_be_peak] \
         -variable ${ns}::use_be_peak
      checkbutton $f.chkBeCent -text [mc use_be_centroid] \
         -variable ${ns}::use_be_centroid
      checkbutton $f.chkHardSf -text [mc hard_surface] \
         -variable ${ns}::hard_surface

      button $f.btnGraph -text [mc ex_veg] -command [list ybkg pixelwf_ex_veg]

      checkbutton $f.chkVerbose -text [mc verbose] -variable ${ns}::verbose

      frame $f.fraChks -padx 0 -pady 0
      lower $f.fraChks
      grid $f.chkBePeak $f.chkBeCent $f.chkHardSf -in $f.fraChks
      grid columnconfigure $f.fraChks 2 -weight 1

      grid $f.lblWindow $f.spnWindow $f.lblLast $f.spnLast
      grid $f.cboAction - $f.entVariable -
      grid $f.fraChks - - $f.btnGraph
      grid $f.chkVerbose - - ^

      default_sticky \
         $f.lblWindow $f.spnWindow $f.lblLast $f.spnLast \
         $f.cboAction $f.entVariable \
         $f.fraChks $f.btnGraph \
         $f.chkVerbose

      grid columnconfigure $f {0 2} -weight 0 -uniform 2
      grid columnconfigure $f {1 3} -weight 1 -uniform 1
   }

   proc show_wf f {
      set ns ::pixelwf::vars::show_wf
      frame $f

      label $f.lblWindow -text [mc win]:
      helper_spinbox $f.spnWindow ${ns}::win

      checkbutton $f.chkC1 -text [mc c1] -variable ${ns}::c1
      checkbutton $f.chkC2 -text [mc c2] -variable ${ns}::c2
      checkbutton $f.chkC3 -text [mc c3] -variable ${ns}::c3

      button $f.btnGraph -text [mc show_wf] -command [list ybkg pixelwf_show_wf]

      frame $f.fraC -padx 0 -pady 0
      lower $f.fraC
      grid $f.chkC1 $f.chkC2 $f.chkC3 -in $f.fraC
      grid columnconfigure $f.fraC 2 -weight 1

      grid $f.lblWindow $f.spnWindow
      grid $f.fraC $f.btnGraph

      default_sticky \
         $f.lblWindow $f.spnWindow \
         $f.fraC $f.btnGraph

      grid columnconfigure $f 1 -weight 1
   }

   proc geo_rast f {
      set ns ::pixelwf::vars::geo_rast
      frame $f

      label $f.lblWindow -text [mc win]:
      helper_spinbox $f.spnWindow ${ns}::win

      label $f.lblEOff -text [mc eoffset]:
      helper_spinbox $f.spnEOff ${ns}::eoffset

      checkbutton $f.chkFSMarks -text [mc fsmarks] \
         -variable ${ns}::fsmarks
      button $f.btnGraph -text [mc geo_rast] -command [list ybkg pixelwf_geo_rast]

      checkbutton $f.chkVerbose -text [mc verbose] -variable ${ns}::verbose

      grid $f.lblWindow $f.spnWindow $f.lblEOff $f.spnEOff
      grid $f.chkFSMarks - $f.btnGraph -
      grid $f.chkVerbose - ^ ^

      default_sticky \
         $f.lblWindow $f.spnWindow $f.lblEOff $f.spnEOff \
         $f.chkFSMarks $f.btnGraph \
         $f.chkVerbose

      grid columnconfigure $f {0 2} -weight 0 -uniform 2
      grid columnconfigure $f {1 3} -weight 1 -uniform 1
   }

   proc ndrast f {
      set ns ::pixelwf::vars::ndrast
      frame $f

      label $f.lblWindow -text [mc win]:
      helper_spinbox $f.spnWindow ${ns}::win

      label $f.lblUnits -text [mc units]:
      helper_combobox $f.cboUnits ${ns}::units

      helper_output_dest $f.cboAction $f.entVariable $ns

      button $f.btnGraph -text [mc ndrast] -command [list ybkg pixelwf_ndrast]

      grid $f.lblWindow $f.spnWindow $f.lblUnits $f.cboUnits
      grid $f.cboAction - $f.entVariable -
      grid $f.btnGraph - - -

      default_sticky \
         $f.lblWindow $f.spnWindow $f.lblUnits $f.cboUnits \
         $f.cboAction $f.entVariable \
         $f.btnGraph

      grid columnconfigure $f {0 2} -weight 0 -uniform 2
      grid columnconfigure $f {1 3} -weight 1 -uniform 1
   }
}
