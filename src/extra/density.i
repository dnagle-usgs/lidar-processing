/*
  Code for calculating point density statistics.

  Density is a measure of point count over area. Calculating this can be
  slightly tricky because a point cloud doesn't necessarily have a clean
  boundary, which means there's no easy way for calculating the area to divide
  by.

  The approach used here is to grid the data, where each grid cell's value is
  the point count for that cell. The smaller the grid cell, the better the area
  estimate will be. However, smaller grid cells also take longer to process.

  Even with larger cells, we can still get a good density estimate if we focus
  on interior cells and exclude border cells. An interior cell is one that has
  points in each of its eight neighbors. A border cell is one that does not.
  While a border cell is likely to only be partially covered by points, an
  interior cell is very likely entirely covered. Thus, the density calculation
  on interior cells should be more reliable.

  This leverages the gridding functionality in gridding.i to calculate counts.
  Use method="cell_counts" of data_grid and batch_grid.

  Overview of functions:

    density_stats: Analyzes data and outputs statistics about its density.

    density_stats_dir: Analyzes the counts data generated by batch_grid and
      outputs density statistics.
*/

func density_stats(data, mode=, cell=, tile=) {
/* DOCUMENT density_stats, data, mode=, cell=, tile=

  Analyzes the given data and outputs density statistics to the console.

  Parameter:
    data: An array of FS, VEG__, etc. Note: This cannot be a ZGRID value.
  Options:
    mode= Data mode to use for deriving the x,y coordinates. Elevation is not used.
    cell= Cell size to use, in meters. Default is 250. When working with tiled
      data, use a value that divides evenly into 2000 for best results.
    tile= The tile name for the data. If provided, then stats are only
      calculated over the cells that are within the tile's boundaries. However,
      the buffer region cells are still used for detecting if cells are
      interior or border.
*/
  t0 = array(double, 3);
  timer, t0;
  write, format="Calculating counts...%s", "\n";
  counts = data_grid(data, mode=mode, cell=cell, method="cell_counts");
  timer_finished, t0, fmt="Counts calculated in ELAPSED\n";

  parts = density_stats_partition(counts, tile=tile);
  density_stats_print, parts.interior, parts.border, parts.cell;
}

func density_stats_print(interior, border, cell) {
/* DOCUMENT density_stats_print, interior, border, cell
  Helper function that displays stats for the given cells. Not intended for
  direct use.
*/
  cell = double(cell);
  cell_area = cell ^ 2;

  write, "";
  write, format="Overall density statistics%s", "\n";
  density_stats_print_helper, grow(border, interior), cell_area;

  write, format="Border cell density statistics%s", "\n";
  density_stats_print_helper, border, cell_area;

  write, format="Interior cell density statistics%s", "\n";
  density_stats_print_helper, interior, cell_area;

  write, format="Cell size is %g by %g meters.\n", cell, cell;
  write, format="Densities are points per square meter.%s", "\n";
}

func density_stats_print_helper(counts, cell_area) {
/* DOCUMENT density_stats_print, counts, cell_area
  Helper function for density_stats_print. Not intended for direct use.
*/
  if(!numberof(counts)) {
    write, " No applicable cells";
    write, "";
    return;
  }
  density = counts / cell_area;
  cells = numberof(density);
  sq_m = cell_area * cells;
  sq_km = sq_m / (1000 * 1000);
  write, format="  %d cells covering %.3f sq km\n", cells, sq_km;
  write, format="  Minimum density: %.2f\n", density(min);
  write, format="  Maximum density: %.2f\n", density(max);
  write, format="  Average density: %.2f\n", density(avg);
  write, format="  Median density:  %.2f\n", median(density);
  write, "";
}

func density_stats_partition(counts, tile=) {
/* DOCUMENT density_stats_partition(counts, tile=)
  Analyzes the counts grid to determine which cells are interior and which
  cells are border. It then returns the counts from those cells. If tile= is
  specified, counts are restricted to the specified tile.

  The output is an oxy group with three members:
      interior - An array of counts for interior cells.
      border - An array of counts for border cells.
      cell - The cell size.
*/
  zcounts = *counts.zgrid;

  xcount = ycount = 0;
  splitary, dimsof(zcounts), , xcount, ycount;

  // Is the cell in the right tile?
  ztile = array(1, xcount, ycount);
  if(tile) {
    x = counts.xmin + indgen(0:xcount-1) * counts.cell;
    y = counts.ymin + indgen(1:ycount) * counts.cell;
    utm2dt_corners, x, y, tile_size(tile);
    bbox = tile2bbox(tile);
    tx = ty = [];
    dt2utm_corner, tile, ty, tx;
    ztile &= (x == tx)(,-);
    ztile &= (y == ty)(-,);
  }

  // Is the cell populated?
  zpop = zcounts > 0;

  // Count how many adjacent cells are populated on each of the eight sides
  zadj = array(0, xcount, ycount);
  zadj(:-1,:-1) += zpop(2:,2:);
  zadj(:-1,) += zpop(2:,);
  zadj(:-1,2:) += zpop(2:,:-1);
  zadj(,:-1) += zpop(,2:);
  zadj(,2:) += zpop(,:-1);
  zadj(2:,:-1) += zpop(:-1,2:);
  zadj(2:,) += zpop(:-1,);
  zadj(2:,2:) += zpop(:-1,:-1);

  // Interior cells are populated cells with eight populated adjacent cells
  zinterior = zpop & (zadj == 8);

  // Border cells are populated cells with fewer than eight populated adjacent cells
  zborder = zpop & (zadj < 8);

  return save(
    interior=zcounts(where(zinterior & ztile)),
    border=zcounts(where(zborder & ztile)),
    cell=counts.cell
  );
}

func density_stats_dir(dir, searchstr=) {
/* DOCUMENT density_stats_dir, dir, searchstr=

  Displays density statistics on the console for the specified cell counts data
  (i.e., the output of batch_grid using method="cell_counts").

  Parameter:

    dir: The directory to look in for cell counts data.

  Option:

    searchstr= The search string to use for finding the correct files.
        searchstr="*_grid*.pbd"   Default
*/
  local vname;
  default, searchstr, "*_grid*.pbd";

  files = find(dir, searchstr=searchstr);
  nfiles = numberof(files);
  if(!nfiles) {
    write, "No files found, aborting.";
    return;
  }

  cell = array(long, nfiles);
  interior = border = array(pointer, nfiles);
  for(i = 1; i <= nfiles; i++) {
    curcounts = pbd_load(files(i), , vname);
    if(is_void(curcounts)) continue;
    tile = extract_tile(vname);
    parts = density_stats_partition(curcounts, tile=tile);

    cell(i) = parts.cell;
    interior(i) = &parts.interior;
    border(i) = &parts.border;
  }
  if(anyof(cell != cell(1))) error, "not all cells are same size";
  cell = cell(1);
  interior = merge_pointers(interior);
  border = merge_pointers(border);

  density_stats_print, interior, border, cell;
}
