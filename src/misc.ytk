# vim: set tabstop=3 softtabstop=3 shiftwidth=3 autoindent shiftround expandtab:

################################################################################
# DEPRECATED 2009-10-04                                                        #
# The code in this file appears to be unused and unneeded.                     #
################################################################################

# This makes sure the file doesn't get sourced multiple times, since it might
# be called from several files. If you DO need to resource it, just 'unset
# __misc_ytk_loaded' first.
if {[info exists __misc_ytk_loaded]} {
   return
}
set __misc_ytk_loaded 1

package require struct::list

##############################################################################

# DEPRECATED 2009-10-04
#     This appears to be unused.
proc indent {str {ind "  "}} {
# indent - Applies indentation to each line in a string
# Usage:
#   indent string_value
#   indent string_value indentation_value
# Returns indented string
# Examples:
#   % indent "foo\nbar\nbaz"
#     foo\n  bar\n  baz
#   % indent "foo\n bar\n  baz" " "
#    foo\n  bar\n   baz
   return [string trimright "$ind[string map [list "\n" "\n$ind"] $str]" " "]
}

# DEPRECATED 2009-10-04
#     This appears to be unused.
proc next_unused {type base} {
# next_unused - finds an unused name
# type: one of: command namespace variable widget window
# base: any string
# For example, [next_unused variable foo] will check to see if a variable foo0
# exists. If it does, it checks to see if foo1 exists. It keeps incrementing
# until it finds a variable that doesn't exist, then returns that variable
# name.
   set num 0
   while {
      [switch -- $type {
         command -
         -command {
            expr {[uplevel info commands $base$num] ne ""}
         }
         namespace -
         -namespace {
            uplevel namespace exists $base$num
         }
         variable -
         -variable {
            uplevel info exists $base$num
         }
         widget -
         -widget -
         window -
         -window {
            uplevel winfo exists $base$num
         }
         default {
            error "Type must be one of: command, window, widget, variable"
         }
      }]
   } {
      incr num
   }
   return $base$num
}

# DEPRECATED 2009-10-04
#     This appears to be unused.
proc listify { str } {
# listify converts a stringy list into a real list. This isn't normally needed,
# as Tcl normally can interpret a string list just fine. But sometimes, they
# make eval choke.
#
# This:
#     listify {
#        -foo "Hello world"
#        -bar "This is a test"
#     }
#
# Will return:
#     -foo {Hello world} -bar {This is a test}
#
# The first version would choke a call to eval because of the newlines; the
# second would not.
   return [lrange $str 0 end]
}

# DEPRECATED 2009-10-04
#     This appears to be unused.
proc default_opts { optVar args } {
# default_opts - provides defaults to an options variable
# This is intended to be used where one of the arguments to a proc is a
# dictionary contianing option-value pairs. It makes sure that any dictionary
# keys in the defaults list that are not present in the passed variable get
# supplied with default values.
   upvar $optVar opt
   set opt [dict merge $args $opt]
}

# DEPRECATED 2009-10-04
#     This appears to be unused.
proc list_to_comma_and { lst } {
# list_to_comma_and - converts a list to a string with commas
# list_to_comma_and {a} -> a
# list_to_comma_and {a b} -> a and b
# list_to_comma_and {a b c} -> a, b, and c
# list_to_comma_and {a b c d} -> a, b, c, and d
# etc.
   if { ! [llength $lst] } {
      return
   } elseif { [llength $lst] == 1 } {
      return [lindex $lst 0]
   } elseif { [llength $lst] == 2 } {
      return [join $lst { and }]
   } else {
      return "[join [lrange $lst 0 end-1] {, }], and [lindex $lst end]"
   }
}
