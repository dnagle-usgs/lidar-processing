# vim: set ts=3 sts=3 sw=3 ai sr et:
#
# 2008-11-26:  little procs to improve the interface

# This makes sure the file doesn't get sourced multiple times, since it might
# be called from several files. If you DO need to resource it, just 'unset
# __gui_procs_ytk_loaded' first.
if {[info exists __gui_procs_ytk_loaded]} {
   return
}
set __gui_procs_ytk_loaded 1

package require Itcl
package require Iwidgets
package require struct::set
package require misc

proc west {type w args} {
# from: http://wiki.tcl.tk/1420
# when using a checkbox or radio button, display the text on
# the west side of the button instead of the east as is the default
   frame $w
   set pos [lsearch $args -text]
   if {$pos == -1} {
      set text ""
   } else {
      set text [lindex $args [expr $pos+1]]
      set args [lreplace $args $pos [incr pos]]
   }
   eval $type $w.r $args [list -text ""] -pady 0
   label $w.t -text $text -pady 0
   pack $w.t $w.r -side left -pady 0 -padx 0 -fill x -anchor e
   set w
} ;# RS

proc setTooltip {widget text} {
# from: http://wiki.tcl.tk/1954
# display popup tooltips.  this uses a bigger font and is more readable
# than the default -helptext.
   if { $text != "" } {
      # 2) Adjusted timings and added key and button bindings. These seem to
      # make artifacts tolerably rare.
      bind $widget <Any-Enter>    [list after 1000 [list showTooltip %W $text]]
      bind $widget <Any-Leave>    [list after  500 [list destroy %W.tooltip]]
      bind $widget <Any-KeyPress> [list after  500 [list destroy %W.tooltip]]
      bind $widget <Any-Button>   [list after  500 [list destroy %W.tooltip]]
   }
}

proc showTooltip {widget text} {
   global tcl_platform
   if { [string match $widget* [winfo containing  [winfo pointerx .] [winfo pointery .]] ] == 0  } {
      return
   }

   catch { destroy $widget.tooltip }

   set scrh [winfo screenheight $widget]    ; # 1) flashing window fix
   set scrw [winfo screenwidth $widget]     ; # 1) flashing window fix
   set tooltip [toplevel $widget.tooltip -bd 1 -bg black]
   wm geometry $tooltip +$scrh+$scrw        ; # 1) flashing window fix
   wm overrideredirect $tooltip 1

   if {$tcl_platform(platform) == {windows}} { ; # 3) wm attributes...
      wm attributes $tooltip -topmost 1   ; # 3) assumes...
   }                                           ; # 3) Windows
   pack [label $tooltip.label -bg lightyellow -fg black -text $text -justify left]

   set width [winfo reqwidth $tooltip.label]
   set height [winfo reqheight $tooltip.label]

   set positionX [winfo pointerx .]
   set positionY [expr [winfo pointery .] + 25]

   wm geometry $tooltip [join  "$width x $height + $positionX + $positionY" {}]
   raise $tooltip

   # 2) Kludge: defeat rare artifact by passing mouse over a tooltip to destroy it.
   bind $widget.tooltip <Any-Enter> {destroy %W}
   bind $widget.tooltip <Any-Leave> {destroy %W}
}

##############################################################################
# copied from ADAPT: lib/misc.tcl

proc center_win { win } {
# Center a window.
   set lx [ expr [winfo screenwidth  $win]/2 - [winfo width  $win]/2 ]
   set ly [ expr [winfo screenheight $win]/2 - [winfo height $win]/2 ]
   wm geometry $win "+$lx+$ly"
   wm deiconify $win
   update
}

proc tk_getString {w var title text {initial {}}} {
# adapted from http://wiki.tcl.tk/9172
   variable ::tk::Priv
   upvar $var result
   catch {destroy $w}
   set focus [focus]
   set grab [grab current .]

   toplevel $w -bd 1 -relief raised -class TkSDialog
   wm title $w $title
   wm iconname  $w $title
   wm protocol  $w WM_DELETE_WINDOW {set ::tk::Priv(button) 0}
   wm transient $w [winfo toplevel [winfo parent $w]]

   entry  $w.entry -width 20
   button $w.ok -bd 1 -width 5 -text Ok -default active -command {set ::tk::Priv(button) 1}
   button $w.cancel -bd 1 -text Cancel -command {set ::tk::Priv(button) 0}
   label  $w.label -text $text

   grid $w.label -columnspan 2 -sticky ew -padx 3 -pady 3
   grid $w.entry -columnspan 2 -sticky ew -padx 3 -pady 3
   grid $w.ok $w.cancel -padx 3 -pady 3
   grid rowconfigure $w 2 -weight 1
   grid columnconfigure $w {0 1} -uniform 1 -weight 1

   $w.entry insert 0 $initial

   bind $w <Return>  {set ::tk::Priv(button) 1}
   bind $w <Destroy> {set ::tk::Priv(button) 0}
   bind $w <Escape>  {set ::tk::Priv(button) 0}

   wm withdraw $w
   update idletasks
   focus $w.entry
   set x [expr {[winfo screenwidth  $w]/2 - [winfo reqwidth  $w]/2 - [winfo vrootx $w]}]
   set y [expr {[winfo screenheight $w]/2 - [winfo reqheight $w]/2 - [winfo vrooty $w]}]
   wm geom $w +$x+$y
   wm deiconify $w
   grab $w

   tkwait variable ::tk::Priv(button)
   set result [$w.entry get]
   bind $w <Destroy> {}
   grab release $w
   destroy $w
   focus -force $focus
   if {$grab != ""} {grab $grab}
   update idletasks
   return $::tk::Priv(button)
}

##############################################################################
# imported from ADAPT: GUI/lib/utils.tcl

namespace eval GUI::utils {
   proc getfile { args } { }
}

proc GUI::utils::getfile { args } {
# getfile: pops up one of tk_chooseDirectory, tk_getOpenFile, or tk_getSaveFile
# usage: Much like the above three. Pass the dashed options you want.
# Note that -initialdirvariable can be used so that it updates an external
# variable if the user changes directory
   set defaults [list \
      -variable {} \
      -initialdir {} \
      -initialdirvariable {} \
      -filetypes {
         { {All files} * }
      } \
      -type open]
   set args [dict merge $defaults $args]

   if { [dict get $args -variable] ne "" } {
      upvar [dict get $args -variable] filename
   } else {
      set filename ""
   }

   if { [dict get $args -initialdirvariable] ne "" } {
      upvar [dict get $args -initialdirvariable] initial
   } else {
      set initial [dict get $args -initialdir]
   }
   set initial_bkp $initial

   if { $initial eq "" } {
      set initial $filename
   }
   while { ! [file isdirectory $initial] } {
      set initial [file dirname $initial]
   }

   set type [string tolower [dict get $args -type]]

   set command [switch -- $type {
      dir  {K* tk_chooseDirectory}
      open {K* tk_getOpenFile}
      save {K* tk_getSaveFile}
   }]

   set opts [dict filter $args script {key val} {
      struct::set contains \
         [switch -- $type {
            dir {K* [list -parent -title]}
            open -
            save {K* [list -defaultextension -filetypes -parent -title]}
         }] $key
   }]

   dict set opts -initialdir $initial

   set temp [eval $command $opts]

   if { $temp ne "" } {
      set filename $temp
      set initial [file dirname $filename]
   } else {
      set initial $initial_bkp
   }
   return $filename
}

##############################################################################
# imported from ADAPT: lib/GUI/EntryFieldButton.tcl

if { [info commands GUI::EntryFieldButton] eq "" } {
   itcl::class GUI::EntryFieldButton {
      inherit iwidgets::Entryfield

      constructor {args} {}
   }
}

itcl::body GUI::EntryFieldButton::constructor {args} {
   itk_component add button {
      button $itk_interior.button
   } {
      keep -state
      rename -command -buttoncommand buttonCommand Command
      rename -text -buttontext buttonText Text
      rename -width -buttonwidth buttonWidth Width
      rename -height -buttonheight buttonHeight Height
   }
   pack $itk_component(button)

   eval itk_initialize $args
}

##############################################################################
# Imported from ADAPT: lib/GUI/FileEntryButton.tcl

if { [info commands GUI::FileEntryButton] eq "" } {
   itcl::class GUI::FileEntryButton {
      inherit GUI::EntryFieldButton
      
      constructor {args} {}

      itk_option define -defaultextension defaultextension Extension ""
      itk_option define -filetypes filetypes Filetypes ""
      itk_option define -initialdir initialdir Dir ""
      itk_option define -initialdirvariable initialdirVariable Variable ""
      itk_option define -parent parent Parent ""
      itk_option define -actiontype actiontype ActionType ""
      itk_option define -updatecommand updatecommand Command ""
      
      method file_choose {args} {}
   }
}

itcl::body GUI::FileEntryButton::constructor {args} {
   #itk_option remove GUI::EntryFieldButton::buttoncommand
   eval itk_initialize $args
   configure \
      -buttoncommand [itcl::code $this file_choose] \
      -buttontext "Choose..."
}

itcl::body GUI::FileEntryButton::file_choose {args} {
   GUI::utils::getfile \
      -defaultextension $itk_option(-defaultextension) \
      -filetypes $itk_option(-filetypes) \
      -initialdir $itk_option(-initialdir) \
      -initialdirvariable $itk_option(-initialdirvariable) \
      -parent $itk_option(-parent) \
      -type $itk_option(-actiontype) \
      -variable $itk_option(-textvariable)
   if {$itk_option(-updatecommand) ne ""} {
      uplevel #0 $itk_option(-updatecommand)
   }
}

##############################################################################

proc winfo_children_all widget {
# Like [winfo children $widget], except that it works recursively.
   set result [list]
   foreach child [winfo children $widget] {
      lappend result $child
      if {[llength [winfo children $child]]} {
         eval [list lappend result] [winfo_children_all $child]
      }
   }
   return $result
}
