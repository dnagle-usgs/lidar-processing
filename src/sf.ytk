#!/bin/sh
# \
	exec wish "$0" ${1+"$@"}

# [ Header #########################################
#
# Web sources for components and modules used by sf.
# Activetcl www.activestate.com
# Jpg image module at:    http://mmbers1.chello.nl/~j.nijtmans/img.html
# Mogrify and friends at: http://www.imagemagick.org
#
#
# ] End Header #####################################

# [ Script Initialization ##########################
# set path to be sure to check /usr/lib for the package
set auto_path "$auto_path /usr/lib"

package require Img
package require BWidget
if { [ catch {package require vfs::tar} ] } {
	wm withdraw .
		tk_messageBox \
		-message "Can't find vfs::tar package.\n\
		You are using tk version $tk_version,\n\
		Recommend you install the most recent stable version of Activetcl" \
		-icon error \
		-type ok
		exit 1;
}
package require comm
package require Iwidgets
package require Itcl
package require Tk

option add *SFWindow.title "SF" widgetDefault

# ] End Script Initialization ######################

if {[info commands SFWindow] eq ""} {
	itcl::class SFWindow {
		inherit iwidgets::Shell

		constructor {imageset args} {}
		destructor {}

		method center_win { win } {}
		method ytk_exists {}
		method send_ytk { args } {}
		method cir_exists {} {}
		method send_cir { args } {}
		method send_comm_id {} {}
		method curzone { zone } {}
		method timern_write { name1 name2 op } {}
		method ci_write { name1 name2 op } {}
		method zoom_write { name1 name2 op } {}
		method cur_mark_write { name1 name2 op } {}
		method cur_class_write { name1 name2 op } {}
		method toolbar_status_write { name1 name2 op } {}
		method scrollbar_status_write { name1 name2 op } {}
		method gotoImage {{sod -1}} {}
		method plotRaster {} {}
		method set_gamma { g } {}
		method no_file_selected { nfiles } {}
		method play { direc } {}
		method step_img { direc } {}
		method title { t } {}
		method show_img { {n ""} } {}
		method archive_save_marked { type } {}
		method get_heading { } {} ;# inhd
		method apply_zoom_factor { percentage } {}
		method clear_class {} {}
		method clear_marks {} {}
		method invert_marks {} {}
		method mark_range {} {}
		method enable_controls {} {}
		method plotpos { } {}
		method include_heading {} {}
		method enable_mog_message {} {}
		method mog_message {} {}
		method rewind {} {}
		method tk_getString { w var title text {initial {}}} {}
		method begin_range {} {}
		method end_range {} {}
		method toggle_mark {} {}
		method toggle_play {} {}
		method show_cir {} {}
		method raster {} {}
		method apply_range {} {}
		method guiInit {} {}
		method mark_image {img_idx} {}
		method get_nfiles {} {
			return $nfiles
		}
		method get_fcin {} {
			return $fcin
		}
		method get_lcin {} {
			return $lcin
		}
		method sync {} {}

		method set_offset {name1 name2 op} {}

# [ Variable Initialization ########################

# Disables the display of messages about mogrify. Change to any nonzero value
# to disable. Zero will enable messages.

		variable no_mog_messages 0

		variable image_set

		variable DEBUG_SF 1      ;# Show debug info on (1) or off (0)

	# The camera is frequently out of time sync so we add this to correct it.
		variable seconds_offset 0
		
		variable universal_offset 1
		variable fna       ;#
		variable gamma 1.0       ;#
		variable speed Fast      ;# Speed/delay to use for playing images
		variable step 1          ;# Step by thru images
		variable run 0           ;#
		variable ci 1           ;# Current image; glued to .slider
		variable nfiles 0        ;# Nmber of files
		variable dir				 ;# Base directory
		variable base_dir
		variable timern "hms"    ;# "hms" "sod" "cin"
		variable fcin 0          ;# First index for range
		variable lcin 0          ;# Last index for range
		variable yes_head 0      ;# Use heading
		variable head 0          ;# Heading
		variable inhd_count 0    ;#
		variable step_marked 0   ;# Step through marked items only?
		variable mark
		variable class
	# variable mark_range_inc 1;# Increment for ranges
		variable range_touched 0 ;# Have fcin or lcin been variable but not used?
		variable hms
		variable show_fname 0    ;# Show the file name?
		variable sod
		variable cin
		variable tarname ""      ;# Tar file to access - may be changed by .lst commands
		variable inhd
		variable ytk_id			;# Comm id for ytk
		variable cir_id			;# Comm id for cir

		variable frame_off 0     ;# Frame offvariable

		variable data "No GPS data"  ;#
		variable img   

		variable last_tar ""

		variable rate
# Zoom configuration
		variable zoom 100
		variable zoom_min 1
		variable zoom_max 200

# Do we want to show a message about mogrify if it gets disabled? 
# (Used to avoid displaying the message too excessively)
# Setting this to -1 will completely disable this.
		variable show_mog_message 1
		variable win	;#window	
		variable menubar

		variable mogrify_exists

		variable scrollbar_status 1
		variable toolbar_status_gps 1
		variable toolbar_status_slider 1
		variable toolbar_status_vcr 1
		variable toolbar_status_speedgamma 1
		variable toolbar_status_alps 1
		variable mogrify_pref
		variable mog_inc_contrast
		variable mog_dec_contrast
		variable mog_despeckle
		variable mog_enhance
		variable mog_equalize
		variable mog_normalize
		variable mog_monochrome
		variable cur_mark
		variable start_hms
		variable hsr
		variable cur_class
	}
}

# BEGIN SFMarkRangeWin ############################
# Helper class of SFWindow.  Used for creating instances of
# the window for marking ranges of windows.
if {[info commands SFMarkRangeWin] eq ""} {
	itcl::class SFMarkRangeWin {
		inherit iwidgets::Shell

			constructor {sfwin_arg args} {}
		destructor {}

		method range_start {} {}
		method range_end {} {}
		method mark_range {} {}
		method cancel {} {}

		variable win
			variable fcin
			variable lcin
			variable range_min
			variable range_max
			variable mark_range_inc 1
			variable sfwin

	}
}

itcl::body SFMarkRangeWin::constructor {sfwin_arg args} {
	wm protocol $itk_component(hull) WM_DELETE_WINDOW \
		[itcl::code itcl::delete object $this]
	eval itk_initialize $args

	set win $itk_interior
	set sfwin $sfwin_arg
	set lcin [$sfwin get_lcin]
	set fcin [$sfwin get_fcin]

	if { $lcin < $fcin } {
		tk_messageBox -icon warning -message "The beginning of the range occured after the end of the range. The range boundaries have been exchanged to remain sensible."
			set temp $fcin
			set fcin $lcin
			set lcin $temp
	}

	set range_min 1
	set range_max [$sfwin get_nfiles]

	toplevel $win.ranger

	frame $win.ranger.1
	frame $win.ranger.2
	frame $win.ranger.3
	frame $win.ranger.4

	label $win.ranger.1.lbl -text "Start"
	SpinBox $win.ranger.1.start \
	-range [list [set range_min] [set range_max] 1] \
	-helptext "Start: The beginning of the range you want to mark." \
	-justify right \
	-textvariable [itcl::scope fcin] \
	-width 5 \
	-modifycmd [itcl::code $this range_start]

	label $win.ranger.2.lbl -text "Stop"
	SpinBox $win.ranger.2.stop \
	-range [list [set range_min] [set range_max] 1] \
	-helptext "Stop: The end of the range you want to mark." \
	-justify right \
	-textvariable [itcl::scope lcin] \
	-width 5 \
	-modifycmd [itcl::code $this range_end]

	label $win.ranger.3.lbl -text "Increment"
	SpinBox $win.ranger.3.inc \
	-range [list 1 [set range_max] 1] \
	-helptext "Increment: The amount to increment by when going through the range. For example, 1 marks every image while 2 marks 1st, 3rd, 5th, etc. The start frame is always the first marked. Depending on the increment, the stop frame may not be marked." \
	-justify right \
	-textvariable [itcl::scope mark_range_inc] \
	-width 5

	Button $win.ranger.4.cancel \
	-text "Cancel" \
	-underline 0 \
	-command [itcl::code $this cancel]

	Button $win.ranger.4.mark \
	-text "Mark" \
	-underline 0 \
	-command [itcl::code $this mark_range]


	pack $win.ranger.1.lbl $win.ranger.1.start -side left -in $win.ranger.1
	pack $win.ranger.2.lbl $win.ranger.2.stop -side left -in $win.ranger.2
	pack $win.ranger.3.lbl $win.ranger.3.inc -side left -in $win.ranger.3
	pack $win.ranger.4.mark $win.ranger.4.cancel \
	-side left -in $win.ranger.4
	pack $win.ranger.1 $win.ranger.2 $win.ranger.3 $win.ranger.4 \
	-side top -in $win.ranger


}

itcl::body SFMarkRangeWin::range_start {} {
	if { $fcin > $lcin } {
		set lcin $fcin
	}
}

itcl::body SFMarkRangeWin::range_end {} {
	if { $lcin < $fcin } { set fcin $lcin }

}

itcl::body SFMarkRangeWin::mark_range {} {
	for { set i $fcin } { $i <= $lcin } { incr i $mark_range_inc } {
		$sfwin mark_image $i
	}
	destroy $win.ranger
}

itcl::body SFMarkRangeWin::cancel {} {
	destroy $win.ranger
}

itcl::body SFWindow::mark_image {img_idx} {
	set mark($img_idx) 1
		if {$ci == $img_idx} {
			set cur_mark $mark($ci)
		}
}

itcl::body SFWindow::constructor {imageset args} {
	wm protocol $itk_component(hull) WM_DELETE_WINDOW \
		[itcl::code itcl::delete object $this]
	eval itk_initialize $args

	set win $itk_interior
	set menubar $itk_component(hull)
# Setting for the existance of mogrify
	set mogrify_exists [expr {! [ catch { exec which mogrify } ]} ]

# Set the version of ImageMagick -- not currently used, but may be useful in the future
	if {$mogrify_exists} {
		if {[catch { set mogrify_version [split [scan [exec mogrify -version] "Version: ImageMagick %s"] .] } ]} {
			set mogrify_version [list 0]
		}
	} else {
		set mogrify_version [list 0]
	}

	set ytk_id -1 ;# Comm id for ytk
	set cir_id -1    ;# Comm id for cir


	set class(0) ""	  ;# Array of classification data
	set mark(0) 0       ;# Array of marked images
	set fna(0) ""
	set rate(Fast)       0
	set rate(100ms)    100
	set rate(250ms)    250
	set rate(500ms)    500
	set rate(1s)      1000
	set rate(2s)      2000
	set rate(4s)      4000
	set rate(5s)      5000
	set rate(7s)      7000
	set rate(10s)    10000

	set img    [ image create photo -gamma $gamma ] ;

# [ Select defaults ################################

	if { $mogrify_exists } {
		set mogrify_pref "prefer tcl"
	} else {
		set mogrify_pref "only tcl"
	}

# if { $DEBUG_SF } { enable_controls }
# set scrollbar_status 0
# set toolbar_status_gps 1
# set toolbar_status_slider 1
# set toolbar_status_vcr 1
# set toolbar_status_speedgamma 1
# set toolbar_status_alps 1

	send_comm_id
	send_ytk init_sf

# ] End Select defaults ############################

# [ Display necessary notices ######################

	if {!$mogrify_exists && $no_mog_messages != 0} {
		tk_messageBox  \
			-message "Since mogrify does not exist on your system, some features will not work correctly. Zooming will round to the nearest even fraction (1/2, 1/3, 1/4, etc.), so the amount that is zoomed to may not be what is indicated. Including heading information is disabled due to the inability to rotate images. Please install ImageMagick <http://www.imagemagick.org/> to correct these issues."  \
			-type ok
			set show_mog_message 0
	}

# ] End Display necessary notices ##################
	guiInit


# [ Variable Traces ################################

		if { [catch {package require Tcl 8.4}] } {
			eval trace variable [list [itcl::scope timern]]							w \
				[list [itcl::code $this timern_write]]
				eval trace variable [list [itcl::scope ci]]                        w \
				[list [itcl::code $this ci_write]]
				eval trace variable [list [itcl::scope zoom]]                      w \
				[list [itcl::code $this zoom_write]]
				eval trace variable [list [itcl::scope cur_mark]]                  w \
				[list [itcl::code $this cur_mark_write]]
				eval trace variable [list [itcl::scope cur_class]]                 w \
				[list [itcl::code $this cur_class_write]]
				eval trace variable [list [itcl::scope scrollbar_status]]          w \
				[list [itcl::code $this scrollbar_status_write]]
				eval trace variable [list [itcl::scope toolbar_status_gps]]        w \
				[list [itcl::code $this toolbar_status_write]]
				eval trace variable [list [itcl::scope toolbar_status_slider]]     w \
				[list [itcl::code $thiS toolbar_status_write]]
				eval trace variable [list [itcl::scope toolbar_status_vcr]]        w \
				[list [itcl::code $this toolbar_status_write]]
				eval trace variable [list [itcl::scope toolbar_status_speedgamma]] w \
				[list [itcl::code $this toolbar_status_write]]
				eval trace variable [list [itcl::scope toolbar_status_alps]]       w \
				[list [itcl::code $this toolbar_status_write]]
				eval trace variable [list [itcl::scope universal_offset]] \
				[list [itcl::code $this set_offset]]
				eval trace variable [list [itcl::scope frame_off]] \
				[list [itcl::code $this set_offset]]
		} else {
			eval trace add variable [list [itcl::scope timern]]						\
				write [list [itcl::code $this timern_write] ]
				eval trace add variable [list [itcl::scope ci] ]                    \
				write [list [itcl::code $this ci_write] ]
				eval trace add variable [list [itcl::scope zoom]]                  \
				write [list [itcl::code $this zoom_write]]
				eval trace add variable [list [itcl::scope cur_mark]]              \
				write [list [itcl::code $this cur_mark_write]]
				eval trace add variable [list [itcl::scope cur_class]]             \
				write [list [itcl::code $this cur_class_write]]
				eval trace add variable [list [itcl::scope scrollbar_status]]      \
				write	[list [itcl::code $this  scrollbar_status_write]]
				eval trace add variable [list [itcl::scope toolbar_status_gps]]    \
				write [list [itcl::code $this toolbar_status_write]]
				eval trace add variable [list [itcl::scope toolbar_status_slider]] \
				write [list [itcl::code $this toolbar_status_write]]
				eval trace add variable [list [itcl::scope toolbar_status_vcr]]    \
				write [list [itcl::code $this toolbar_status_write]]
				eval trace add variable [list [itcl::scope toolbar_status_speedgamma]] \
				write [list [itcl::code $this toolbar_status_write]]
				eval trace add variable [list [itcl::scope toolbar_status_alps]]		\
				write [list [itcl::code $this toolbar_status_write]]
				eval trace add variable [list [itcl::scope universal_offset]] \
				write [list [itcl::code $this set_offset]]
				eval trace add variable [list [itcl::scope frame_off]] \
				write [list [itcl::code $this set_offset]]
		}


# ] End Variable Traces ############################
	
	set image_set $imageset
	puts $image_set
	set cin 1
	set nfiles [$image_set size]
	enable_controls
	$win.slider configure -to $nfiles
	set ci 1
	clear_marks
	clear_class
	show_img
	activate
	apply_zoom_factor -1
}
# Additional globals - initialized within load_file_list
# imgtime lat lon alt hms sod

# Additional globals - initialized externally in eaarl.ytk
# hsr pitch roll dir
# also timern is modified externally

# pitch roll does not seem to be used in sf.ytk RJN 02/24/09

# Additional globals
# llat and llon are used internally
# thetime is used by plotRaster only
# cin

# ] End Variable Initialization ####################

# [ Procedures #####################################

itcl::body SFWindow::center_win { win } {
# Center a window.
	set lx [ expr [winfo screenwidth  $win]/2 - [winfo width  $win]/2 ]
		set ly [ expr [winfo screenheight $win]/2 - [winfo height $win]/2 ]
		wm geometry $win "+$lx+$ly"
		wm deiconify $win
		update
}

itcl::body SFWindow::ytk_exists { } {
# global ytk_id
	return [expr {$ytk_id != -1}]
}

itcl::body SFWindow::send_ytk { args } {
# global ytk_id
	if { $ytk_id == -1 } {
		return 0
	}
	if { [catch { eval ::comm::comm send $ytk_id $args }] } {
		set ytk_id -1
			return 0
	} else {
		return 1
	}
}

itcl::body SFWindow::cir_exists { } {
# global cir_id
	return [expr {$cir_id != -1}]
}

itcl::body SFWindow::send_cir { args } {
# global cir_id
	if { $cir_id == -1 } {
		return 0
	}

	if { [catch { eval ::comm::comm send $cir_id $args }] } {
		set cir_id -1
			return 0
	} else {
		return 1
	}

}

itcl::body SFWindow::send_comm_id { } {
#global ytk_id cir_id
	send_ytk set sf_a_id [::comm::comm self]
		send_cir set sf_a_id [::comm::comm self]
}

itcl::body SFWindow::curzone { zone } {
	send_ytk "exp_send \"curzone = $zone \\n\";"
}

itcl::body SFWindow::timern_write { name1 name2 op } {
# timern_write is used in a variable trace to keep
# .alps.entry up to date when .alps.option changes
# global ci
	show_img
}

itcl::body SFWindow::ci_write { name1 name2 op } {
# ci_write is  used in a variable trace to keep the
# mark box up to date with the current image
# global mark ci cur_mark cur_class class

	catch {set cur_mark $mark($ci)}
	catch {set cur_class $class($ci)}
}

itcl::body SFWindow::zoom_write { name1 name2 op } {
# zoom_write is used in a variable trace to keep zoom
# within its proper range and to update the image shown
# global zoom ci zoom_min zoom_max

	if { $zoom < $zoom_min } { set zoom $zoom_min }
	if { $zoom > $zoom_max } { set zoom $zoom_max }

	show_img
}

itcl::body SFWindow::cur_mark_write { name1 name2 op } {
# cur_mark_write updates mark($ci) to reflect the new
# value of $cur_mark. Note that this will be called
# whenever 'set cur_mark $mark($ci)' is used, but that
# isn't a problem since mark($ci) is just set back to
# it's current value.
# global cur_mark mark ci

	catch { set mark($ci) $cur_mark }
}

itcl::body SFWindow::cur_class_write { name1 name2 op } {
# global cur_class class ci

	catch { set class($ci) $cur_class }
}

itcl::body SFWindow::toolbar_status_write { name1 name2 op } {
# global $name1
	set bar [lindex [split $name1 "_"] 2]
		if { [set $name1] } {
			grid $win.$bar
		} else {
			grid remove $win.$bar
		}
}

itcl::body SFWindow::scrollbar_status_write { name1 name2 op } {
# global $name1
	if { [set $name1] } {
		grid $win.canf.xscroll
			grid $win.canf.yscroll
	} else {
		grid remove $win.canf.xscroll
			grid remove $win.canf.yscroll
	}
}


itcl::body SFWindow::gotoImage {{sod -1}} {
# global timern hms sod ci hsr imgtime seconds_offset frame_off \
	pitch roll head DEBUG_SF

# global hsr

	if {$sod != -1} {
		set cin [$image_set somd2idx $sod]
		show_img
	} else if {$timern == "sod"} {
		set cin [$image_set somd2idx $hsr]
		show_img
	} else if {$timern == "hms"} {
		set cin [$image_set hms2idx $hsr]
		show_img
	} else if {$timern == "cin"} {
		set cin $hsr
		show_img
	}
	
}

itcl::body SFWindow::plotRaster {} {
# global timern hms cin sod hsr frame_off thetime

# global hsr

	set thetime 0
		if {$timern == "hms"} {
			puts "Plotting raster using Mode Value: $hms"
				$win.alps.entry delete 0 end
				$win.alps.entry insert insert $hms
				if { [ytk_exists] == 1 } {
					send_ytk set themode $timern
						send_ytk set thetime $sod
##send $win set thetime [expr {$sod + $frame_off}]
				}
		}
	if {$timern == "sod"} {
		puts "Plotting raster using Mode Value: $sod"
			$win.alps.entry delete 0 end
			$win.alps.entry insert insert $sod
			if { [ytk_exists] == 1 } {
				send_ytk set themode $timern
					send_ytk set thetime $sod
##send $win set thetime [expr {$sod + $frame_off}]
			}
	}
	if {$timern == "cin"} {
		puts "Plotting raster using Mode Value: $cin"
			$win.alps.entry delete 0 end
			$win.alps.entry insert insert $cin
			if { [ytk_exists] == 1 } {
				send_ytk set themode $timern
					send_ytk set thetime $sod
##send $win set thetime [expr {$sod + $frame_off}]
			}
	}
}

itcl::body SFWindow::set_gamma { g } {
# global img gamma
	$img configure -gamma $g 
}

itcl::body SFWindow::no_file_selected { nfiles } {
# global run 
	if { $nfiles != 0 } {
		return 0
	}

	tk_dialog $win.error "No File" "Click File, then Open\nand select a file to display" "" 0 "Ok"
		set run 0 
		return 1
}

itcl::body SFWindow::play { direc } {
#  Play displays successive images either forward or in reverse.
# global nfiles run ci speed rate step timern
	set run 1
		if { [no_file_selected $nfiles] } { return }

	while { $run == 1 } {
		if { (($direc > 0) && ($ci < $nfiles)) || (($direc < 0) && ($ci > 1)) } {
			if {[step_img $direc]} {set run 0}
#			incr ci [expr $step * $dir]
#			show_img $ci
			set u [ expr $rate($speed) / 100 ]
				for { set ii 0; } { $ii < $u } { incr ii } { 
					after 100; update; 
				}
		} else {
			set run 0
		}
	}
}

itcl::body SFWindow::step_img { direc } {
# global ci nfiles step_marked mark DEBUG_SF

	if { [no_file_selected $nfiles] } { return }
	set o $ci
		set n $ci
		if { $step_marked } {
			set rem $step
				set j $ci
				incr j $direc
				while {$rem && $j <= $nfiles && $j >= 0 } {
					if {$mark($j)} {
						set n $j
							incr rem -1
							if {$DEBUG_SF} { puts "step_img: using step_marked, n is at $n" }
					}
					incr j $direc
				}
		} else {
			incr n [ expr $step * $direc]
				if {$DEBUG_SF} { puts "step_img: not using step_marked, n is at $n" }
		}
	if { $n < 0 } { set n 0; } elseif { $n > $nfiles } { set n $nfiles; }
	set ci $n
		show_img
		return [expr $o == $n]
}

######################################
itcl::body SFWindow::title { t } {
# commands executed from the lst file
# global img
	puts "Title command: $t"
		$img blank ;
	set s [ $win.canf.can bbox img ]
		set dx [ expr [ lindex $s 2 ] / 2 ]
		set dy [ expr [ lindex $s 3 ] / 2 ]
		puts "$dx $dy"
		$win.canf.can create text $dx $dy -tags title \
		-font [ font create -family helvetica -weight bold -size 24  ] \
		-justify center -text $t
		update;
	after 1000
		$win.canf.can delete title
}

itcl::body SFWindow::show_img { {n ""} } {
# Use as few global def as possible to keep the speed up.  
# If you have more global vars declare them on a 
# continued line as follows:
# global fna nfiles img run ci data imgtime dir img_opts \
	lat lon alt ew ns pdop nsat seconds_offset hms sod timern cin hsr \
	frame_off llat llon pitch roll head yes_head zoom inhd \
	DEBUG_SF mogrify_pref mogrify_exists tarname show_fname \
	mog_normalize mog_inc_contrast mog_dec_contrast mog_despeckle \
	mog_enhance mog_equalize mog_monochrome img img0 last_tar tar \
	cam1_flst 

# global hsr

	if {$n == ""} {
		set n $ci
	}

	set cin $n

	if { $DEBUG_SF } {
		puts "fna:"
		puts [array size fna]
		puts "called with n: $n"
		puts "ci: $ci"
	}

	set fn [$image_set get_img $cin]
	set frame_off [$image_set get_offset $cin]
	set sod [$image_set idx2somd $cin]
	set hms [$image_set somd2hms $sod]


	if {![file exists $fn]} {
		$img blank
		$win.canf.can itemconfigure tx -text "Image does not exist."
		if { $timern == "cin" } { set hsr $cin }
		if { $timern == "hms" } { set hsr $hms }
		if { $timern == "sod" } { set hsr $sod }
		update
		return
	}


# Some shorthand variables
	set only_tcl [string equal $mogrify_pref "only tcl"]
	set prefer_tcl [string equal $mogrify_pref "prefer tcl"]
	set prefer_mogrify [string equal $mogrify_pref "prefer mogrify"]

	if { $DEBUG_SF } { puts "fn: $fn" }

# Copy the file to a temp file, to protect the original from changes
	file copy -force $fn /tmp/sf_tmp_$this.jpg
	set fn /tmp/sf_tmp_$this.jpg

# Make sure we can read/write the temp file
	file attributes $fn -permissions uog+rw

	$win.canf.can config -cursor watch

	set rotate_amount 0

	if {$inhd && $only_tcl} {
		$win.mb.options invoke "Include Heading"
			tk_messageBox  \
			-message "Mogrify is disabled, so heading utilizations has been disabled." \
			-type ok
	}

	if {$inhd} {
# include heading information...
		get_heading
		$img blank
		set rotate_amount [expr ($rotate_amount + $head)]
	}
	
	set rotate_amount [expr $rotate_amount + [$image_set base_rotation]]
	# set rotate_amount [expr ($rotate_amount + 180)]
	
	# ensure rotation is less than 360
	set rotate_amount [expr $rotate_amount % 360]
	# set rotate_amount [expr {$rotate_amount > 360 ? $rotate_amount - 360 : $rotate_amount}]


# Make zoom variables
	set zoom_percent [expr {round($zoom)}]%
	if { $zoom > 100 } {
		set zoom_type 1
		set zoom_factor [expr {round($zoom/100.0)}]
		if { $zoom_factor == [expr {$zoom/100.0}] } {
			set zoom_even 1
		} else {
			set zoom_even 0
		}
	} else {
		set zoom_type -1
		set zoom_factor [expr {round(100.0/$zoom)}]
		if { $zoom_factor == [expr {100.0/$zoom}] } {
			set zoom_even 1
		} else {
			set zoom_even 0
		}
	}

# Mogrify process image before loading

	if {! $only_tcl} {
		set extra_opts ""
		if { $mog_normalize } {
			set extra_opts "$extra_opts -normalize "
		}
		if { $mog_equalize } {
			set extra_opts "$extra_opts -equalize "
		}
		if { $mog_inc_contrast } {
			set extra_opts "$extra_opts -contrast "
		}
		if { $mog_dec_contrast } {
			set extra_opts "$extra_opts +contrast "
		}
		if { $mog_despeckle } {
			set extra_opts "$extra_opts -despeckle "
		}
		if { $mog_enhance } {
			set extra_opts "$extra_opts -enhance "
		}
		if { $mog_monochrome } {
			set extra_opts "$extra_opts -monochrome "
		}

		if {$rotate_amount != 0 && (!$prefer_tcl || $rotate_amount != 180) } {
			if {$zoom != 100 && (!$prefer_tcl || !$zoom_even)} {
				eval exec mogrify -sample $zoom_percent -rotate $rotate_amount $extra_opts $fn
					if { $DEBUG_SF } { puts "mogrified: rotate and zoom" }
			} else {
				eval exec mogrify -rotate $rotate_amount $extra_opts $fn
					if { $DEBUG_SF } { puts "mogrified: rotate" }
			}
		} elseif {$zoom != 100 && (!$prefer_tcl || !$zoom_even)} {
			eval exec mogrify -sample $zoom_percent $extra_opts $fn
				if { $DEBUG_SF } { puts "mogrified: zoom" }
		}

	}

# Done processing, direct load image
	if {$prefer_mogrify || ($prefer_tcl && !($rotate_amount == 180) && !$zoom_even)} {
		if { [ catch { $img read $fn -shrink } ] } {
			puts "Unable to decode: $fna($n)";
		}
		if { $DEBUG_SF } { puts "loaded finished img" }
	} else {
# Not done processing, load image and tcl process
		if { [ catch { image create photo tempimage -file $fn } ] } {
			puts "Unable to decode: $fna($n)";
		}
		if { $DEBUG_SF } { puts "loaded unfinished img" }
		if {!$zoom_even && !$only_tcl} {
			set zoom_factor 1
			set zoom_type -1
		}
		if {$zoom_type == 1} {
			if {$rotate_amount == 180} {
				$img copy tempimage -zoom $zoom_factor -subsample -1 -shrink
					if { $DEBUG_SF } { puts "copied finished img: zoom subsample" }
			} else {
				$img copy tempimage -zoom $zoom_factor -shrink
					if { $DEBUG_SF } { puts "copied finished img: zoom" }
			}
		} else {
			if {$rotate_amount == 180} {
				set zoom_factor [expr {-1 * $zoom_factor}]
			}
			$img copy tempimage -subsample $zoom_factor -shrink
				if { $DEBUG_SF } { puts "copied finished img: subsample" }
		}
	}

# Cleanup -- remove the temp file since we're done with it
	file delete $fn

	$win.canf.can itemconfigure tx -text ""
# set lst [ split $fn "_" ]
# set data "$n  [ lindex $lst 3 ]"
# if { [array size fna] > 1 } {
# 	set hms  $imgtime(idx$n);
#}
#scan $hms "%02d%02d%02d" h m s 
# set sod [ expr $h*3600 + $m*60 + $s + $seconds_offset - $frame_off]
#set hms [ clock format $sod -format "%H%M%S" -gmt 1   ] 

	catch { set llat $ns(hms$hms)$lat(hms$hms) }
	catch { set llon $ew(hms$hms)$lon(hms$hms) }
	if { [ catch { set data "$hms ($sod) $ns(hms$hms)$lat(hms$hms) $ew(hms$hms)$lon(hms$hms) $alt(hms$hms)M $pdop(hms$hms) $nsat(hms$hms)"} ]  } { 
		set data "hms:$hms sod:$sod  "
	}
	if { $show_fname } {
		set data "$data\n$fna($n)"
	}

	if { $timern == "cin" } { set hsr $cin }
	if { $timern == "hms" } { set hsr $hms }
	if { $timern == "sod" } { set hsr $sod }
	$win.canf.can config -cursor arrow
	$win.canf.can config -scrollregion "0 0 [image width $img] [image height $img]"
	update

}

itcl::body SFWindow::archive_save_marked { type } {
# global mark fna dir range_touched imgtime \
	gt lat lon ew ns pdop alt nsat nfiles

	if {!([string equal "zip" $type] || [string equal "tar" $type])} {
		tk_messageBox -type ok -icon error \
			-message "Invalid save type provided. Cannot Save."
			return
	}

	if { $range_touched } {
		set answer [tk_messageBox -message "You set a range boundary but did not enter the 'Apply Marks over Range' dialog. Would you like to visit the 'Apply Marks over Range' dialog now?" -type yesnocancel -icon question]
			set range_touched 0
	} else {
		set answer "no"
	}

	if {[string equal $answer "yes"]} {
		mark_range
			return
	} 

	if {[string equal "zip" $type]} {
		set sf [ tk_getSaveFile -defaultextension .zip -filetypes { {{Zip Files} {.zip}} } \
			-initialdir $dir -title "Save Marked Files as..."];
	} elseif {[string equal "tar" $type]} {
		set sf [ tk_getSaveFile -defaultextension .tar -filetypes { {{Tar Files} {.tar}} } \
			-initialdir $dir -title "Save Marked Files as..."];
	}

	if { $sf == "" } {

		tk_messageBox -type ok -icon error \
			-message "The 'Save File As' dialog was cancelled. Thus, the images were not archived."

			return
	}

	set psf $this
		set tmpdir "/tmp/sf.$psf"
		if {[catch "cd $tmpdir"] != 1} {
			cd $dir
				file delete -force -- $tmpdir
		}
	file mkdir $tmpdir

		set mark_count 0
		set start 1;
	set stop  $nfiles;
	if { [ info exists lat ] } {
		set of [ open "$tmpdir/gps.gga" "w+" ]
			for { set i $start } { $i <= $stop } { incr i } {
				set gt  $imgtime(idx$i);
				puts $of "GPGGA,$gt.00,$lat(hms$gt),$ns(hms$gt),$lon(hms$gt),$ew(hms$gt),1,$nsat(hms$gt),$pdop(hms$gt),$alt(hms$gt),M,$alt(hms$gt),M";
			}
		close $of
	}
	for { set i $start } { $i <= $stop } { incr i } {
		if { $mark($i) } {
			set fn [$image_set get_img $i]
				if {![file exists $fn]} {
					continue
				}
			incr mark_count
				file copy -force $fn $tmpdir;
		}
	}

	if { $mark_count > 0 } {

		cd $tmpdir

			if {[string equal "tar" $type]} {
				exec ls -1 > filelist; 
				exec tar -cvf $sf  -T filelist --exclude filelist;
			} elseif {[string equal "zip" $type]} {
				eval exec zip $sf [glob *.{jpg,gga}];
			}


	} else {
		cd $dir;
		file delete -force -- $tmpdir

			tk_messageBox -type ok -icon error \
			-message "No images were marked to be archived, so no archive was made."

	}

}

itcl::body SFWindow::get_heading { } {
# global sod tansstr head
## this procedure gets the attitude information for the cir data
## amar nayegandhi 12/28/04
	if {$inhd != 1} {
		set head 0
		return
	}

	$win.canf.can configure -height 420 -width 440
	set psf [pid]
## the function request_heading is defined in eaarl.ytk
	send_ytk request_heading $psf $inhd $sod
## tmp file is now saved as /tmp/tans_pkt.$psf
	if { [catch {set f [open "/tmp/tans_pkt.$psf" r] } ] } {
		tk_messageBox -icon warning -message "Heading information is being loaded... Click OK to continue"
	} else {
		set tansstr [read $f]
		set headidx [string last , $tansstr]
		set head [string range $tansstr [expr {$headidx + 1 }] end]
		close $f
	}
}

itcl::body SFWindow::apply_zoom_factor { percentage } {
# global img zoom
	if {$percentage > 0 } {
		set zoom [expr {round($zoom * $percentage)}]
		return
	}

	set iw [expr {[image width $img] / ($zoom/100.0)}]
	set ih [expr {[image height $img] / ($zoom/100.0)}]
	if {$iw && $ih} {
		set cw [winfo width $win.canf.can]
		set ch [winfo height $win.canf.can]
		set wr [expr {int(100*$cw/$iw)}]
		set hr [expr {int(100*$ch/$ih)}]
		set zoom [expr {(($wr < $hr) ? $wr : $hr)}]
	}

}

itcl::body SFWindow::clear_class { } {
# global class cur_class ci nfiles

	for { set i 1 } { $i <= $nfiles } { incr i } {
		set class($i) ""
	}

	catch { set cur_class $class($ci) }
}

itcl::body SFWindow::clear_marks { } {
# global mark cur_mark ci nfiles

	for { set i 1 } { $i <= $nfiles } { incr i } {
		set mark($i) 0
	}

	catch { set cur_mark $mark($ci) }
}

itcl::body SFWindow::invert_marks { } {
# global mark cur_mark ci nfiles
	for { set i 1 } { $i <= $nfiles } { incr i } {
		set mark($i) [expr {1 - $mark($i)}]
	}

	set cur_mark $mark($ci)
}

itcl::body SFWindow::mark_range { } {
# global fcin lcin mark mark_range_inc cur_mark ci nfiles
	SFMarkRangeWin .#auto $this
}

itcl::body SFWindow::enable_controls { } {
# global mogrify_exists mogrify_pref

	$win.speedgamma.mark configure     -state normal
	$win.mb entryconfigure Archive     -state normal
	$win.mb entryconfigure Options     -state normal
	$win.mb entryconfigure Zoom        -state normal
	$win.speedgamma.universal_offset configure -state normal	

	if { $mogrify_exists == 1 } {
		$win.mb.options.mogrify entryconfigure "Prefer mogrify over native Tcl" -state normal
			$win.mb.options.mogrify entryconfigure "Prefer native Tcl over mogrify" -state normal
			$win.mb.options.mogrify entryconfigure "Disable mogrify completely"   -state normal
	} else {
		$win.mb.options.mogrify entryconfigure "Prefer mogrify over native Tcl" -state disabled
			$win.mb.options.mogrify entryconfigure "Prefer native Tcl over mogrify" -state disabled
			$win.mb.options.mogrify entryconfigure "Disable mogrify completely"   -state normal
	}
	after 100 [list catch { $win.mb entryconfigure Tools -state normal }]
	after 5000 [list catch { $win.mb entryconfigure Tools -state normal }]
}

itcl::body SFWindow::plotpos { } {
# global nfiles llat llon sod
	if { [no_file_selected $nfiles] } { return }
	if { [ ytk_exists ] != 1 } {
		tk_messageBox  \
			-message "ytk isn\'t running. You must be running Ytk and the eaarl.ytk program to use this feature."  \
			-type ok
			return
	}

	if { [ info exists llat ] } {
		send_ytk ::plot::mark_pos $llat $llon
	} else {
		send_ytk ::plot::mark_time_pos $sod
	}

}

itcl::body SFWindow::include_heading { } {
# global inhd ci
	set psf [pid]
		if { $inhd == 0 } {
			file delete /tmp/tans_pkt.$psf
		}
	get_heading ;#$inhd
		show_img
}

itcl::body SFWindow::enable_mog_message { } {
# global show_mog_message
	if {$show_mog_message == 0} {
		set show_mog_message 1
	}
}

itcl::body SFWindow::mog_message { } {
# global show_mog_message no_mog_messages
	if {$show_mog_message == 1 && $no_mog_messages == 0} {
		set show_mog_message 0
			tk_messageBox  \
			-message "Since mogrify is disabled, some features will not work correctly. Zooming will round to the nearest even fraction (1/2, 1/3, 1/4, etc.), so the amount that is zoomed to may not be what is indicated. Including heading information is disabled due to the inability to rotate images. Please enable mogrify to fix these issues."  \
			-type ok
	}
}

itcl::body SFWindow::rewind { } {
# global ci nfiles
	if { [no_file_selected $nfiles] } { return }
	set ci 1
		show_img
}

# adapted from http://wiki.tcl.tk/9172
itcl::body SFWindow::tk_getString {w var title text {initial {}}} {
	variable ::tk::Priv
	upvar $var result
	catch {destroy $w}
	set focus [focus]
	set grab [grab current .]

	toplevel $w -bd 1 -relief raised -class TkSDialog
	wm title $w $title
	wm iconname  $w $title
	wm protocol  $w WM_DELETE_WINDOW {set ::tk::Priv(button) 0}
	wm transient $w [winfo toplevel [winfo parent $w]]

	entry  $w.entry -width 20
	button $w.ok -bd 1 -width 5 -text Ok -default active -command {set ::tk::Priv(button) 1}
	button $w.cancel -bd 1 -text Cancel -command {set ::tk::Priv(button) 0}
	label  $w.label -text $text

	grid $w.label -columnspan 2 -sticky ew -padx 3 -pady 3
	grid $w.entry -columnspan 2 -sticky ew -padx 3 -pady 3
	grid $w.ok $w.cancel -padx 3 -pady 3
	grid rowconfigure $w 2 -weight 1
	grid columnconfigure $w {0 1} -uniform 1 -weight 1

	$w.entry insert 0 $initial

	bind $w <Return>  {set ::tk::Priv(button) 1}
	bind $w <Destroy> {set ::tk::Priv(button) 0}
	bind $w <Escape>  {set ::tk::Priv(button) 0}

	wm withdraw $w
	update idletasks
	focus $w.entry
	set x [expr {[winfo screenwidth  $w]/2 - [winfo reqwidth  $w]/2 - [winfo vrootx $w]}]
	set y [expr {[winfo screenheight $w]/2 - [winfo reqheight $w]/2 - [winfo vrooty $w]}]
	wm geom $w +$x+$y
	wm deiconify $w
	grab $w

	tkwait variable ::tk::Priv(button)
	set result [$w.entry get]
	bind $w <Destroy> {}
	grab release $w
	destroy $w
	focus -force $focus
	if {$grab != ""} {grab $grab}
	update idletasks
	return $::tk::Priv(button)
}

itcl::body SFWindow::begin_range {} {
	set fcin $cin
		set range_touched 1
}

itcl::body SFWindow::end_range {} {
	set lcin $cin
		set range_touched 1
}

itcl::body SFWindow::toggle_mark {} {
	set cur_mark [expr {1 - $cur_mark}]
}

itcl::body SFWindow::toggle_play {} {
	if { $run == 0 } { play 1 } 
	else { play -1 } 
}

itcl::body SFWindow::raster {} {
	if { [no_file_selected $nfiles] } { return }
	send_ytk "exp_send \"sfsod_to_rn, $sod;\\n\";"		 
}

itcl::body SFWindow::show_cir {} {
	if { [no_file_selected $nfiles] } { return }
	set cir_sod [ expr $sod - 2 ]
		if { !([ cir_exists ] && [ send_cir "show sod $cir_sod" ]) } {
			tk_messageBox -icon warning -message "You must run cir.tcl first."
		}	 
}

itcl::body SFWindow::apply_range {} {
	set range_touched 0
		mark_range

}

# ] End Procedures #################################

itcl::body SFWindow::sync {} {
	set sod [$image_set idx2somd $cin]
	# $sfmanager $sod
}

itcl::body SFWindow::set_offset {name1 name2 op} {
	if {$universal_offset == 1} {
		$image_set set_offset $frame_off
		show_img
	} else {
		$image_set set_offset $frame_off $cin $cin
		show_img
	}

}

# [ GUI Initialization #############################

itcl::body SFWindow::guiInit {} {

#wm title $win "RGB"

### [ Frames
	frame $win.canf -borderwidth 5 -relief sunken
	frame $win.vcr  -borderwidth 5 -relief raised
	frame $win.speedgamma  -borderwidth 5 -relief raised
	frame $win.alps  -borderwidth 5 -relief raised
### ] /Frames

### [ Menubar

	$menubar configure -menu $win.mb
	menu $win.mb

# Menubar
	menu $win.mb.archive
	menu $win.mb.options
	menu $win.mb.zoom

	$win.mb add cascade -label "Archive" -underline 0 -menu $win.mb.archive 
	$win.mb add cascade -label "Options" -underline 0 -menu $win.mb.options 
	$win.mb add cascade -label "Zoom" -underline 0 -menu $win.mb.zoom 

##### ][ Edit Menu

	$win.mb.archive add command -label "Mark This Frame" -underline 0 \
		-command [itcl::code $this toggle_mark]
	$win.mb.archive add command -label "Unmark This Frame"              -underline 0 \
		-command [itcl::code $this toggle_mark]
	$win.mb.archive add command -label "Clear All Marks"                -underline 0 \
		-command [itcl::code $this clear_marks]
	$win.mb.archive add command -label "Invert All Marks"               -underline 0 \
		-command [itcl::code $this invert_marks]
	$win.mb.archive add separator
	$win.mb.archive add command -label "Begin Range with this Frame"    -underline 0 \
		-command [itcl::code $this begin_range]
	$win.mb.archive add command -label "End Range with this Frame"      -underline 0 \
		-command [itcl::code $this end_range]
	$win.mb.archive add command -label "Apply Marks over Range..."      -underline 0 \
		-command [itcl::code $this apply_range]
	$win.mb.archive add separator
	$win.mb.archive add command -label "Tar and Save Marked Images ..." -underline 0 \
		-command [itcl::code $this archive_save_marked "tar"]
	$win.mb.archive add command -label "Zip and Save Marked Images ..." -underline 0 \
		-command [itcl::code archive_save_marked "zip"]

##### ][ Options Menu

	$win.mb.options add checkbutton -label "Scroll Bars" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope scrollbar_status]

	$win.mb.options add checkbutton -label "GPS Info" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope toolbar_status_gps]

	$win.mb.options add checkbutton -label "Image slider" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope toolbar_status_slider]

	$win.mb.options add checkbutton -label "VCR Controls" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope toolbar_status_vcr]

	$win.mb.options add checkbutton -label "Speed, Gamma, etc." -underline 1 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope toolbar_status_speedgamma]

	$win.mb.options add checkbutton -label "ALPS Interface" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope toolbar_status_alps]

	$win.mb.options add command     -label "Resize window to fit controls" -underline 0 \
		-command { wm geometry . "" }

	$win.mb.options add separator

	$win.mb.options add checkbutton -label "Include Heading" -underline 8 -onvalue 1 \
		-offvalue 0 -variable [itcl::scope inhd] \
		-command [itcl::code $this include_heading]

	$win.mb.options add checkbutton -label "Display Image File Name" -underline 14 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope show_fname] \
		-command [itcl::code $this show_img]

	$win.mb.options add checkbutton -label "Step through only marked images" -underline 21 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope step_marked]

	$win.mb.options add separator

	menu $win.mb.options.mogrify
	$win.mb.options add cascade -label "Image manipulation method" \
		-menu $win.mb.options.mogrify -underline 0

	$win.mb.options.mogrify add radiobutton -label "Prefer mogrify over native Tcl" \
		-underline 7 -variable [itcl::scope mogrify_pref] -value "prefer mogrify" \
		-command [itcl::code $this enable_mog_message]

	$win.mb.options.mogrify add radiobutton -label "Prefer native Tcl over mogrify" \
		-underline 14 -variable [itcl::scope mogrify_pref] -value "prefer tcl" \
		-command [itcl::code $this enable_mog_message]

	$win.mb.options.mogrify add radiobutton -label "Disable mogrify completely" \
		-underline 0 -variable [itcl::scope mogrify_pref] -value "only tcl" \
		-command [itcl::code $this mog_message]

	menu $win.mb.options.mogopt

	$win.mb.options add cascade -label "Mogrify options" -menu $win.mb.options.mogopt \
		-underline 0

	$win.mb.options.mogopt add checkbutton -label "Increase Contrast" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope mog_inc_contrast] \
		-command [itcl::code $this show_img]

	$win.mb.options.mogopt add checkbutton -label "Decrease Contrast" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope mog_dec_contrast] \
		-command [itcl::code $this show_img]

	$win.mb.options.mogopt add checkbutton -label "Despeckle" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope mog_despeckle] \
		-command [itcl::code $this show_img]

	$win.mb.options.mogopt add checkbutton -label "Enhance" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope mog_enhance] \
		-command [itcl::code $this show_img]

	$win.mb.options.mogopt add checkbutton -label "Equalize" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope mog_equalize] \
		-command [itcl::code $this show_img]

	$win.mb.options.mogopt add checkbutton -label "Monochrome" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope mog_monochrome] \
		-command [itcl::code $this show_img]

	$win.mb.options.mogopt add checkbutton -label "Normalize" -underline 0 \
		-onvalue 1 -offvalue 0 -variable [itcl::scope mog_normalize] \
		-command [itcl::code $this show_img]

##### ][ Zoom Menu

	$win.mb.zoom add command -label "Actual pixels (100%)" -underline 0 \
		-command [list set [itcl::scope zoom] 100]
	$win.mb.zoom add command -label "Fit to window" -underline 0 \
		-command [itcl::code $this apply_zoom_factor -1]
	$win.mb.zoom add separator
	$win.mb.zoom add command -label "Zoom to 50%" -underline 8 \
		-command [list set [itcl::scope zoom] 50]
	$win.mb.zoom add command -label "Zoom to 33%" -underline 8 \
		-command [list set [itcl::scope zoom] 33]
	$win.mb.zoom add command -label "Zoom to 25%" -underline 8 \
		-command [list set [itcl::scope zoom] 25]
	$win.mb.zoom add command -label "Zoom to 20%" -underline 5 \
		-command [list set [itcl::scope zoom] 20]
	$win.mb.zoom add command -label "Zoom to 10%" -underline 8 \
		-command [list set [itcl::scope zoom] 10]
	$win.mb.zoom add separator
	$win.mb.zoom add command -label "Zoom In by 25%" -underline 0 \
		-command [itcl::code $this  apply_zoom_factor 1.25]
	$win.mb.zoom add command -label "Zoom In by 10%" -underline 5 \
		-command [itcl::code $this apply_zoom_factor 1.1]
	$win.mb.zoom add command -label "Zoom Out by 10%" -underline 5 \
		-command [itcl::code $this apply_zoom_factor 0.9]
	$win.mb.zoom add command -label "Zoom Out by 25%" -underline 3 \
		-command [itcl::code $this apply_zoom_factor 0.75]

##### ]

### ] /Menubar


### [ Frame Contents

# Toplevel .

	label $win.gps -textvariable [itcl::scope data] -justify left

	scale $win.slider -orient horizontal -from 1 -to 1 \
		-variable [itcl::scope ci]

# Frame .canf

	scrollbar $win.canf.xscroll -orient horizontal -command [list $win.canf.can xview]
	scrollbar $win.canf.yscroll -orient vertical   -command [list $win.canf.can yview]
	canvas $win.canf.can -height 240 -width 350 \
		-xscrollcommand [list $win.canf.xscroll set] \
		-yscrollcommand [list $win.canf.yscroll set] \
		-scrollregion { 0 0 0 0 } \
		-xscrollincrement 10 -yscrollincrement 10 -confine true

	$win.canf.can create image 0 0 -tags img -image $img -anchor nw 

	set me "\
		EAARL RGB Image/Data Animator\n\
		C. W. Wright charles.w.wright@nasa.gov\n\
		Amar Nayegandhi anayegandhi@usgs.gov\n\
		David Nagle dnagle@usgs.gov\n\
		"

	$win.canf.can create text 25 80 -text $me -tag tx -anchor nw 

# Frame .vcr

	ArrowButton $win.vcr.prev  -relief raised -type button -width 40 \
		-dir left  -height 25 -helptext "Click for Previous Image. Keep Mouse Button Pressed to Repeat Command" \
		-repeatdelay 1000 -repeatinterval 500 \
		-armcommand [itcl::code $this step_img -1]

	ArrowButton $win.vcr.next  -relief raised -type button -width 40 \
		-dir right  -height 25 -helptext "Click for Next Image. Keep Mouse Button Pressed to Repeat Command" \
		-repeatdelay 1000 -repeatinterval 500 \
		-armcommand [itcl::code $this step_img 1]

	ArrowButton $win.vcr.playr  -arrowrelief raised -type arrow -arrowbd 2 -width 40 \
		-dir left -height 25 -helptext "Click to play backwards (YalP) through images." \
		-clean 0 -command [itcl::code $this play -1]

	Button $win.vcr.stop  -text "Stop" -helptext "Stop Playing Through Images" \
		-command [list set [itcl::scope run] 0]

	ArrowButton $win.vcr.play  -arrowrelief raised -type arrow -arrowbd 2 -width 40 \
		-dir right  -height 25 -helptext "Click To play forward through images." \
		-clean 0 -command [itcl::code $this play 1]

	Button $win.vcr.rewind -text "Rewind" -helptext "Rewind to First Image" \
		-command [itcl::code $this rewind]

	Button $win.vcr.plotpos  \
		-text "Plot" -helptext "Plot position on Yorick-6\nunder the eaarl.ytk program." \
		-command [itcl::code $this plotpos]

# Frame .speedgamma
	tk_optionMenu $win.speedgamma.speed [itcl::scope speed] Fast 100ms 250ms 500ms 1s \
		1.5s 2s 4s 5s 7s 10s

	label $win.speedgamma.lbl -text "Step"

	tk_optionMenu $win.speedgamma.step [itcl::scope step] 1 2 5 10 20 30 60 100

	scale $win.speedgamma.gamma -orient horizontal -from 0.01 -to 2.00 -resolution 0.01 \
		-bigincrement .1 -variable [itcl::scope gamma] \
		-command [itcl::code $this set_gamma] \
		-length 60 -sliderlength 15

	SpinBox $win.speedgamma.offset \
		-helptext "Offset: Enter the frames to be offset here."\
		-justify center \
		-range {-300 300 1}\
		-width 5 \
		-textvariable [itcl::scope frame_off]

	checkbutton $win.speedgamma.universal_offset \
		-text "All"\
		-state disabled \
		-variable [itcl::scope universal_offset]
		

	checkbutton $win.speedgamma.mark \
		-state disabled \
		-variable [itcl::scope cur_mark] \
		-text "Mk"

# Frame .alps

	Entry $win.alps.entry -width 8 -relief sunken -bd 2 \
		-helptext "Click to Enter Value" -textvariable [itcl::scope hsr]

	tk_optionMenu $win.alps.option [itcl::scope timern] hms sod cin 

	Button $win.alps.button -text "Raster" \
		-helptext "Click to Examine EAARL Rasters.  Must have drast.ytk running." \
		-command [itcl::code $this raster]

	Button $win.alps.cirbutton -text "Sync" \
		-helptext "Click to sync all image sets to the same time" \
		-command [itcl::code $this sync]

	SpinBox $win.alps.zoom \
		-helptext "Zoom: Select a zooming factor."\
		-justify center \
		-range [list $zoom_min $zoom_max 1] \
		-width 5 \
		-textvariable [itcl::scope zoom] \
		-modifycmd [itcl::code $this show_img]


### ] /Frame Contents

### [ Pack
	grid $win.canf.xscroll -in $win.canf -column 0 -row 1 -sticky "ew"
	grid $win.canf.yscroll -in $win.canf -column 1 -row 0 -sticky "ns"
	grid $win.canf.can     -in $win.canf -column 0 -row 0 -sticky "ewns"

	grid rowconfigure $win.canf 0 -weight 1
	grid columnconfigure $win.canf 0 -weight 1

	pack \
	$win.vcr.prev \
		$win.vcr.next \
		$win.vcr.playr \
		$win.vcr.stop \
		$win.vcr.play \
		$win.vcr.rewind \
		$win.vcr.plotpos \
		-side left -in $win.vcr -expand 1 -fill x

	pack	\
		$win.speedgamma.speed \
		$win.speedgamma.lbl \
		$win.speedgamma.step \
		$win.speedgamma.gamma \
		$win.speedgamma.offset \
		$win.speedgamma.universal_offset \
		$win.speedgamma.mark \
		-side left -in $win.speedgamma -expand 1 -fill x -padx 3

	pack \
		$win.alps.entry \
		$win.alps.option \
		$win.alps.button \
		$win.alps.cirbutton \
		$win.alps.zoom \
		-side left -in $win.alps -expand 1 -fill x

	grid $win.canf  -in $win -column 0 -row 0 -sticky "nsew"

	set i 0
	grid $win.gps         -in $win -column 0 -row [incr i] -sticky "w"
	grid $win.slider      -in $win -column 0 -row [incr i] -sticky "ew"
	grid $win.vcr         -in $win -column 0 -row [incr i] -sticky "ew"
	grid $win.speedgamma  -in $win -column 0 -row [incr i] -sticky "ew"
	grid $win.alps        -in $win -column 0 -row [incr i] -sticky "ew"
	unset i

	grid rowconfigure    $win 0 -weight 1
	grid columnconfigure $win 0 -weight 1

### ] /Pack

### [ Bindings

	bind $win <Key-p>     [itcl::code $this step_img -1]
	bind $win <Key-n>     [itcl::code $this step_img 1]
# Since marking is currently broken, this binding is void:
	bind $win <Key-m>     [itcl::code $this toggle_mark]
	bind $win <Key-space> [itcl::code $this toggle_play]
	bind $win <Key-Home>  [itcl::code $this rewind]
	bind $win <Control-Key-equal> [list incr [itcl::scope zoom]]
	bind $win <Control-Key-plus>  [list incr [itcl::scope zoom]]
	bind $win <Control-Key-minus> [list incr [itcl::scope zoom] -1]
	$win.alps.zoom bind <Key-Return>    [itcl::code $this show_img]
	$win.alps.zoom bind <Key-KP_Enter>  [itcl::code $this show_img]
	bind $win.alps.entry <Key-Return>   [itcl::code $this gotoImage]
	bind $win.alps.entry <Key-KP_Enter> [itcl::code $this gotoImage]
	bind $win.slider <ButtonRelease> [itcl::code $this show_img]

### ] /Bindings
}
# ] End GUI Initialization #########################


# set sfw [SFWindow .#auto]
# $sfw activate


