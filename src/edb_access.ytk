#
# $Id$
#
#
#  Buttons and controls for loading EAARL data
#  This code:
#    1) Destroys and unpacks any widgets that will be needed
#    2) Instructs Yorick to load the database access code
#    3) Installs buttons and controls to run the Yorick functions.
#


#proc edb_status { } {
# global edb;
# destroy .edb
# if { [ info exists edb ] == 0 } {
#   tk_messageBox -type ok \
#	-icon warning \
#	-message { No EDB (EAARL Data Base) is loaded }
#   return;
# }

 toplevel .edb
 set v " \
	Year 				year \	
	{Day of Year} 			day \
	 Path 				path \
	{Index File} 			idx_file \
	{Total Data (GB)} 		gb \
	{Number of Files} 		number_of_files \
	{Total Rasters} 		nbr_rasters \
	{First Good Raster} 		data_begins \
	{Last Good Raster} 		data_ends \
	{Mission Duration (Hours)} 	mission_duration \
	{Seconds of the Epoch} 		soe \
       "

  set edb(idx_file) [ file tail $edb(idx_file) ]
  set row 0
  foreach {lbl x} $v {
    label .edb.$x\lbl -text "$lbl:" -relief sunken -anchor e -padx 5
    label .edb.v$x    -text  $edb($x) -relief sunken -padx 5
    grid  .edb.$x\lbl -column 0  -row $row -sticky ew 
    grid  .edb.v$x    -column 1  -row $row -sticky ew
    incr row
  }
  button .edb.dismiss -text Dismiss -command { destroy .edb }
  grid .edb.dismiss -row $row -columnspan 2 -sticky ew

}

pack forget .edb_load .edb_plt_sod
destroy     .edb_load .edb_plt_sod

exp_send "#include \"edb_access.i\"\r"
button .edb_load -text "Load EAARL Data set index" -command {
  exp_send "load_edb\r"
  expect ">"
  edb_status
  wm title . "Eaarl:$edb(path)"
}

button .edb_plt_sod -text "Plot SOD" -command {
  exp_send "plg,edb.seconds % 86400\r"
  exp_send "plg,edb.seconds(1) % 86400 + (edb.seconds - edb.seconds(1)), color=\"red\"\r"
  exp_send "\r"
}

button .edb_status -text "EDB Status" -command edb_status


pack .edb_load .edb_plt_sod .edb_status -side left


