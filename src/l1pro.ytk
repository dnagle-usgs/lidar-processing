#
# $Id$
#
# Orginal Amar Nayegandhi aka "anayegan"
#
# For info on using the Bwidget NoteBoook see:  http://mini.net/tcl/2298
#

#unset cdelta
#unset cmin
#unset cmax

  set ofname ""
  set curvar ""
  set outvar ""
  set win_no 		5
  set msize 		1.0
  set markerv		1
  set usecentroid   	1
  set hist_log		1
  set cmax 		40
  set cdelta		80
  set cmin		-40

  set cmax_max		5000
  set cmin_min		-100
  set cmax_inc		0.1
  
  set list		{}
  set lrnindx		{}
  set write_some 	0
  set ssvar "*.pbd"
  set changed_dpi 	0
  set avg_surf		1
  set rcf_buf_rgn	0; #Used in proc replace_proc
  
  array set _mpipx {
	0,0	Selector
	0,1	Data_Variable
	0,2	PIP_Variable
	0,3	File_Name
	0,4	Processing_Type
	0,5	GGA_Array
  }
  global varc
  set varc 0
  if {[info exists varname]} {unset varlist}
  set varlist {fs_all depth_all veg_all cveg_all workdata}
  if {[info exists plist]} { unset plist } 
  array set plist {idx1 idx1, cmin $cmin cmax $cmax ptype 0 dtype 0 msize $msize mtype $markerv}
  set plist(idx1,cmin) $cmin
  set plist(idx1,cmax) $cmax
  set plist(idx1,ptype) 0
  set plist(idx1,dtype) 0
  set plist(idx1,msize) $msize
  set plist(idx1,mtype) $markerv

  set plist(idx2,cmin) $cmin
  set plist(idx2,cmax) $cmax
  set plist(idx2,ptype) 1
  set plist(idx2,dtype) 1
  set plist(idx2,msize) $msize
  set plist(idx2,mtype) $markerv

  set plist(idx3,cmin) $cmin
  set plist(idx3,cmax) $cmax
  set plist(idx3,ptype) 2
  set plist(idx3,dtype) 3
  set plist(idx3,msize) $msize
  set plist(idx3,mtype) $markerv

  set plist(idx4,cmin) $cmin
  set plist(idx4,cmax) $cmax
  set plist(idx4,ptype) 3
  set plist(idx4,dtype) 0
  set plist(idx4,msize) $msize
  set plist(idx4,mtype) $markerv

  set plist(idx5,cmin) $cmin
  set plist(idx5,cmax) $cmax
  set plist(idx5,ptype) 1
  set plist(idx5,dtype) 1
  set plist(idx5,msize) $msize
  set plist(idx5,mtype) $markerv

  set var_no 1
  set pvar_no 1
  set plot_dpi 75
  array set cbvc {cmin cmin cmax cmax msize msize mtype mtype}

  set cbvc(cmin) -40.0
  set cbvc(cmax) 40.0
  set cbvc(msize) 1
  set cbvc(mtype) 1

exp_send "#include \"$src_path/l1pro.i\"\r";   #load all yorick support functions
expect ">";

package require BWidget
package require Tktable
destroy .l1wid

toplevel .l1wid
wm title .l1wid "Process EAARL Data"
frame .l1wid.bf1
frame .l1wid.bf2
frame .l1wid.bf2.utm
frame .l1wid.bf3
frame .l1wid.bf4 
frame .l1wid.bf4.1
frame .l1wid.bf4.2
frame .l1wid.bf45 -relief groove -borderwidth 3
frame .l1wid.bf45.sc -relief groove -borderwidth 3
frame .l1wid.bf45.p -relief groove -borderwidth 3
frame .l1wid.bf45.q -relief groove -borderwidth 3
LabelFrame .l1wid.bf45.r -relief groove -borderwidth 7 -text "FILTER:"
frame .l1wid.bf5  -relief groove -borderwidth 3

.l1wid configure -menu .l1wid.mb
menu .l1wid.mb
menu .l1wid.mb.file
menu .l1wid.mb.load
menu .l1wid.mb.options
menu .l1wid.mb.graph
menu .l1wid.mb.post
menu .l1wid.mb.cmd 
menu .l1wid.mb.diag 
.l1wid.mb   add cascade -label File -underline 0 -menu .l1wid.mb.file

.l1wid.mb.file add command -label "Read Binary Data file..." -underline 0 -command {
  global cbv cmin cmax cdelta cbvc
  if {$cbv == 1} {
	set cbvc(cmin) $cmin
	set cbvc(cmax) $cmax
	set cbvc(msize) $msize
	set cbvc(mtype) $markerv 
  } 

  set _ytk_fn [ tk_getOpenFile -filetypes \
	{  
           {{Yorick PBD file} {.pbd}  }
           {{IDL Binary file} {.bin}  }
           {{IDL Binary file} {.edf}  }
	   {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".pbd" {  
            exp_send "_ytk_pbd_f = openb(\"$_ytk_fn\"); restore, _ytk_pbd_f;\r"
            exp_send "show, _ytk_pbd_f\r"
 	       toplevel .stby
            exp_send "\r"
            label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
            pack .stby.lbl
            expect ">"
	    update
  	    exp_send "set_read_tk \r"
            expect "Tk updated"
	    expect ">"
	    update
            set var_type [lindex $varlist [expr {[llength $varlist] -1}]]
	    update
	    if { $cbv == 0 } {
              exp_send "set_read_yorick, $var_type \r"
              expect ">"
	    }
            destroy .stby
 	    if {$cbv == 1} {
		set cmin $cbvc(cmin)
		set cdelta [expr {$cbvc(cmax)-$cbvc(cmin)} ]
		set cmax $cbvc(cmax)
		set msize $cbvc(msize)
		set markerv $cbvc(mtype) 
	    } 
	    update
	    save_plot_settings [expr {[llength $varlist]-1}]
           }
     ".edf" -
     ".bin" {
        #global data_file_path 
        #if { [info exists data_file_path ] == 0 } {
        #      set data_file_path ""
        #}
	set ytk_bin_dir [ file dirname $_ytk_fn ]/
	set ytk_bin_file [ file tail $_ytk_fn ]
  	exp_send "data_ptr = read_yfile(\"$ytk_bin_dir\", fname_arr=\"$ytk_bin_file\"); \r"
	expect ">"
	exp_send "read_pointer_yfile, data_ptr, mode=1; \r"
	expect ">"
	set ptype [.l1wid.bf4.1.p getvalue]
     }
    }
  }
}

#.l1wid.mb.file add command -label "Read Data File... " -underline 10 -command {
#        global data_file_path 
#        if { [info exists data_file_path ] == 0 } {
#              set data_file_path ""
#        }
#  	exp_send "data_ptr = read_yfile(initialdir=\"$data_file_path\"); \r"
#	expect ">"
#	exp_send "read_pointer_yfile, data_ptr, mode=1; \r"
#	expect ">"
#	set ptype [.l1wid.bf4.1.p getvalue]
#	
##	if {$ptype == 0} {
##	  exp_send "fs_all = *data_ptr(1);\r"
##	  expect ">"
##	}
##	if {$ptype == 1} {
##	  exp_send "depth_all = *data_ptr(1);\r"
##	  expect ">"
##	}
##	if {$ptype == 2} {
##	  exp_send "veg_all = *data_ptr(1);\r"
##	  expect ">"
##	}
#
#  }
	


.l1wid.mb.file add command -label "Write Binary Data File..." -underline 0 -command {
	global write_some data_file_path
        if { [info exists data_file_path ] == 0 } {
              set data_file_path "~/"
        }
	destroy .l1write
        toplevel .l1write
	frame .l1write.1
	frame .l1write.2
	frame .l1write.3
         set ftypes {
                  {{For pbd}       {.pbd}        }
                  {{IDL bin}       {.bin}        }
                  {{IDL edf}       {.edf}        }
                  {{All Files}            *      }
              }
        set ptype [.l1wid.bf4.1.p getvalue]
        set var_no [.l1wid.bf45.p.15 getvalue]
        set var_type [lindex $varlist $var_no]
	LabelEntry .l1write.1.path  -width 30 -relief sunken -bd 3 -label "Output Path:  " -helptext "Enter Output Data Path Here" \
		-textvariable ofname -text $data_file_path
 	Button .l1write.1.browse -text "Browse..." -width 10 -command {
           set ofname [ tk_getSaveFile -filetypes $ftypes -defaultextension ".pbd" ]
	   write_binary_file $ofname
        }
	LabelEntry .l1write.2.varname -width 10 -relief sunken -bd 3 -label "Variable Name: " -helptext "Enter Name of Variable to Write to file"  -textvariable var_type -text $var_type
	LabelEntry .l1write.2.plyname -width 10 -relief sunken -bd 3 -label "PLY Name: " -helptext "Enter ply name to Write to file; Leave it empty if you don't want to write out ply data"  -textvariable ply_type -text ""
	LabelEntry .l1write.2.qname -width 10 -relief sunken -bd 3 -label "GGA(q) Name: " -helptext "Enter q name to Write to file; Leave it empty if you don't want to write out gga data"  -textvariable q_type -text ""
    Button .l1write.3.ok -text "Write File" -width 5 -command {
	global ofname
	write_binary_file $ofname
   }
   Button .l1write.3.cancel -text "Cancel" -width 5 -command {
	   destroy .l1write
   }
   pack .l1write.1.path .l1write.1.browse -side left -padx 5
   pack .l1write.2.varname .l1write.2.plyname .l1write.2.qname -side left -padx 5
   pack .l1write.3.ok .l1write.3.cancel -side left -padx 5
   pack .l1write.1 .l1write.2 .l1write.3
  }

.l1wid.mb.file add command -label "Read SubSampled Data File..." -underline 0 -command {
        global data_file_path
  	set ofn [ tk_getOpenFile -filetypes \
	  {  
           {{Yorick PBD file} {.pbd}  }
	   {{All Files}       {*}   }
          }  ]
	destroy .l1ss
	toplevel .l1ss
	wm title .l1ss "Read SubSampled Data File"
        LabelFrame .l1ss.1 -relief groove -borderwidth 3 -text "Points to skip:"
	frame .l1ss.2
  	SpinBox .l1ss.1.sk \
	-range {1 1000 1} \
	-textvariable skipl \
	-helptext "Enter points to skip (Subsample)" \
	-width 5
	LabelEntry .l1ss.1.mvar -label "Variable Name: " -width 10 -bd 3 \
		-helptext "Enter Variable Name of Data array after merging" \
		-textvariable mvar
 	Button .l1ss.2.ok -text "OK" -width 5 -command {
	   exp_send "$mvar = subsample_pbd_data(fname=\"$ofn\", skip = $skipl);\r"
	   destroy .l1ss
	}
 	Button .l1ss.2.cancel -text "Cancel" -width 5 -command {
	   destroy .l1ss
 	}
	pack .l1ss.1.sk .l1ss.1.mvar -side left -padx 5
	pack .l1ss.2.ok .l1ss.2.cancel -side left -padx 5  
	pack .l1ss.1 .l1ss.2 -pady 5
	
}

.l1wid.mb.file add command -label "Read Data Directory..." \
   -underline 10 -command ::l1dir::gui

catch { namespace delete l1dir }
namespace eval l1dir {
   # Global scope variables used:
   # ::data_file_path
   namespace eval v {
      variable window .l1dir
      variable merged ""
      variable type_pbd pbd
      variable type_yfile {edf or bin}
      variable datatype $type_pbd
      variable skip 1
      variable unique 0
      variable search ""
      variable fixedzone 0
      variable zone 18
      variable tile_dt {2km Data Tiles}
      variable tile_qq {Quarter Quads}
      variable tiletype $tile_dt
   }

   proc gui { } {
      set win $v::window
      destroy $win
      toplevel $win
      wm resizable $win 1 0
      wm minsize $win 400 1
      wm title $win "Read Data Directory"
      
      label $win.lblPath -text "Data Path:"
      entry $win.entPath -width 40 -textvariable ::data_file_path
      button $win.butPath -text "Browse..." \
         -command [namespace code butPath_cmd]

      label $win.lblType -text "Data Type:"
      ComboBox $win.cboType -editable 0 \
         -values [list $v::type_pbd $v::type_yfile] \
         -textvariable [namespace which -variable v::datatype]

      label $win.lblSearch -text "Search String:"
      entry $win.entSearch -width 8 \
         -textvariable [namespace which -variable v::search]

      set fra $win.fraPBD
      labelframe $fra -text "PBD Options"

      label $fra.lblMerged -text "Merged Variable:"
      entry $fra.entMerged -width 8 \
         -textvariable [namespace which -variable v::merged]

      label $fra.lblUnique -text "Unique:"
      checkbutton $fra.chkUnique \
         -variable [namespace which -variable v::unique]

      label $fra.lblSubsample -text "Subsample:"
      spinbox $fra.spnSubsample -from 1 -to 1000 -increment 1 -width 5 \
         -textvariable [namespace which -variable v::skip]

      label $fra.lblFixed -text "Fixed Zone:"
      checkbutton $fra.chkFixed \
         -variable [namespace which -variable v::fixedzone]

      label $fra.lblZone -text "Zone:"
      spinbox $fra.spnZone -from 1 -to 60 -increment 1 -width 5 \
         -textvariable [namespace which -variable v::zone]

      label $fra.lblTiles -text "Tile Type:"
      ComboBox $fra.cboTiles -editable 0 \
         -textvariable [namespace which -variable v::tiletype] \
         -values [list $v::tile_dt $v::tile_qq]

      grid $fra.lblMerged - $fra.entMerged -
      grid $fra.lblUnique $fra.chkUnique $fra.lblSubsample $fra.spnSubsample
      grid $fra.lblFixed $fra.chkFixed $fra.lblZone $fra.spnZone
      grid $fra.lblTiles - $fra.cboTiles -

      makesticky e [list $fra.lblMerged $fra.lblTiles \
         $fra.lblUnique $fra.lblFixed $fra.lblSubsample $fra.lblZone]
      makesticky w [list $fra.chkUnique $fra.chkFixed]
      makesticky ew [list $fra.spnSubsample $fra.spnZone $fra.entMerged $fra.cboTiles]

      set fra $win.fraEmpty
      frame $fra

      set fra $win.fraButtons
      frame $fra
      button $fra.butLoad -text "Load Data" \
         -command [namespace code butLoad_cmd]
      button $fra.butCancel -text "Cancel" \
         -command [namespace code butCancel_cmd]
      grid $fra.butLoad $fra.butCancel

      grid $win.lblPath   $win.entPath   - $win.butPath
      grid $win.lblType   $win.cboType   $win.fraPBD -
      grid $win.lblSearch $win.entSearch ^ ^
      grid $win.fraEmpty   - ^ ^
      grid $win.fraButtons - ^ ^
      makesticky e [list \
         $win.lblPath $win.lblType $win.lblSearch]
      makesticky ew [list \
         $win.entPath $win.cboType $win.entSearch]
      makesticky news [list $win.fraEmpty]
      grid $win.fraPBD -padx {5 0}
      grid columnconfigure $win 1 -weight 1
      grid rowconfigure    $win 3 -weight 1

      datatype_changes
   }

   proc makesticky { sticky widgets } {
      foreach widget $widgets {
         grid $widget -sticky $sticky
      }
   }

   trace add variable [namespace which -variable v::datatype] write \
      [namespace code datatype_changes]

   proc datatype_changes { {n1 {}} {n2 {}} {op {}} } {
      set state [lindex {disabled normal} \
         [string equal $v::datatype $v::type_pbd]]
      foreach widget [winfo children $v::window.fraPBD] {
         $widget configure -state $state
      }
      tiletype_changes
   }

   trace add variable [namespace which -variable v::fixedzone] write \
      [namespace code tiletype_changes]

   proc tiletype_changes { {n1 {}} {n2 {}} {op {}} } {
      set fra $v::window.fraPBD
      if {[$fra.lblFixed cget -state] == "normal"} {
         set state [lindex {disabled normal} $v::fixedzone]
         foreach widget [list $fra.lblZone $fra.spnZone \
               $fra.lblTiles $fra.cboTiles] {
            $widget configure -state $state
         }
      }
   }

   proc butPath_cmd { } {
      set temp_path [ tk_chooseDirectory -initialdir $::data_file_path \
         -mustexist 1 -title "Read data directory" ]
      if {$temp_path != ""} {
         set ::data_file_path $temp_path
      }
   }

   proc butLoad_cmd { } {
      if { ! [file isdirectory $::data_file_path] } {
         error "The data path provided is not a real directory: $::data_file_path"
      }
      switch -- $v::datatype \
         $v::type_pbd {
            if { ! [string length $v::merged] } {
               error "You must provide a merged variable name!"
            }
            set search $v::search
            if {! [string length $search]} {
               set search {*.pbd}
            }
            if {$v::fixedzone} {
               switch -- $v::tiletype \
                  $v::tile_dt {
                     set cmd zoneload_dt_dir
                  } \
                  $v::tile_qq {
                     set cmd zoneload_qq_dir
                  } \
                  default {
                     error "Invalid tile type provided: $v::tiletype"
                  }
               exp_send [join [list \
                  "require, \"zone.i\"; require, \"qq24k.i\"; " \
                  "$v::merged = ${cmd}(\"$::data_file_path\", " \
                  "$v::zone, skip=$v::skip, unique=$v::unique, " \
                  "glob=\"$search\");\r" \
               ] {}]
            } else {
               wm withdraw $v::window
               exp_send [join [list \
                  "$v::merged = merge_data_pbds(\"$::data_file_path\", " \
                  "skip=$v::skip, uniq=$v::unique, " \
                  "searchstring=\"$search\");\r" \
               ] {}]
            }
            expect ">"
            exp_send "vname=\"$v::merged\";set_read_tk;set_read_yorick,$v::merged\r"
            expect ">"
            exp_send "\r"
         } \
         $v::type_yfile {
            set search $v::search
            if {! [string length $search]} {
               set search "\[\]"
            }
            wm withdraw $v::window
            exp_send "data_ptr = read_yfile(\"$::data_file_path\", searchstring=\"$search\");\r"
            expect ">"
            exp_send "read_pointer_yfile, data_ptr, mode=1;\r"
            expect ">"
         } \
         default {
            error "Invalid data type provided: $v::datatype"
         }

      destroy $v::window
   }

   proc butCancel_cmd { } {
      destroy $v::window
   }
}

.l1wid.mb.file add command -label "Read Data Directory... (deprecated)" \
   -command {
      global data_file_path
      if { [info exists data_file_path ] == 0 } {
         set data_file_path "/data/"
      }
      destroy .l1dir
      toplevel .l1dir
      frame .l1dir.1
      frame .l1dir.2
      wm title .l1dir "Read Data Directory"
      LabelFrame .l1dir.3 -relief groove -borderwidth 3 -text "Options:"
      LabelEntry .l1dir.2.op  -width 50 -relief sunken -bd 3 \
         -label "Path:  " -helptext "Enter Data Path Here" \
		   -textvariable path -text $data_file_path
      Button .l1dir.2.fbutton -text "Browse..." -command {
         global data_file_path
         set path [ tk_chooseDirectory -initialdir $data_file_path \
            -mustexist 1 -title "Read Data Directory" ]/
         set data_file_path $path
      }

      ComboBox .l1dir.3.dtype -text "Data Type..." -width 10 \
         -helptext "Select Data File type" \
         -editable 0 -takefocus 0 \
         -values { pbd edf bin } \
         -modifycmd {
            set dtype [.l1dir.3.dtype getvalue]
            if {$dtype == 0} {
               .l1dir.3.skip configure -state normal
               .l1dir.3.mvar configure -state normal
            } else {
               .l1dir.3.skip configure -state disabled
               .l1dir.3.mvar configure -state disabled
            }
         }

      LabelEntry .l1dir.3.mvar -label "Merged Variable Name: " \
         -width 8 -bd 3 -textvariable mvar \
         -helptext "Enter Variable Name of Data array after merging"

      Label .l1dir.3.skL -text "Subsample: "
      
      SpinBox .l1dir.3.skip -range {1 1000 1} -width 3 -textvariable skipl \
         -helptext "Enter plot points to skip" \

      LabelEntry .l1dir.3.ssvar -label "Search String: " -width 8 -bd 3 \
         -helptext "Enter search string" \
         -textvariable ssvar

      checkbutton .l1dir.3.uniq -text "Unique" -variable uniq
      Button .l1dir.1.ok -text "OK" -width 5 -command {
         if {$path != ""} {
            .l1dir.2.op configure -state disabled
            .l1dir.1.ok configure -state disabled
            set dtype [.l1dir.3.dtype getvalue]
            if {$dtype == 0}  {
               exp_send "$mvar = merge_data_pbds(\"$path\", skip = $skipl, uniq = $uniq, searchstring=\"$ssvar\"); \r"
               destroy .l1dir
            }
            if {$dtype == 1 || $dtype == 2} {
               exp_send "data_ptr = read_yfile(\"$path\"); \r"
               expect ">"
               exp_send "read_pointer_yfile, data_ptr, mode=1; \r"
               expect ">"
               set ptype [.l1wid.bf4.1.p getvalue]
               destroy .l1dir
            }
         }
      }
      .l1dir.3.skip configure -state disabled

      Button .l1dir.1.cancel -text "Cancel" -width 5 -command {
         destroy .l1dir
      }
      pack .l1dir.1.ok .l1dir.1.cancel -side left -padx 5
      pack .l1dir.2.op .l1dir.2.fbutton -side left -padx 5
      pack .l1dir.3.dtype .l1dir.3.mvar .l1dir.3.skL .l1dir.3.skip \
         .l1dir.3.uniq .l1dir.3.ssvar -side left -padx 3
      pack .l1dir.2 .l1dir.3 .l1dir.1 -side top -pady 5	
   }

.l1wid.mb.file add command -label "Ascii output ..." -underline 0 \
  -command {
	global cmin cmax  opath ofile data_path
	global write_asc_some
        if { [ info exists data_path ]  == 0} {
	     set data_path "~/"
        }
        set delimit "space"
	set indx 0
      	set intensity 0
	set rnidx 0
 	set soeindx 0
	set hline 0
	set split 0
	set zclip 0
	set opath $data_path
	set zmin $cmin
	set zmax $cmax
         set ftypes {
                  {{For QTViewer}       {.xyz}        }
                  {{Generic ASCII}      {.asc}        }
                  {{Simple txt}         {.txt}      TEXT}
                  {{All Files}            *             }
              }

	destroy .l1asc
        toplevel .l1asc
	set w .l1asc
	$w configure -menu $w.mb
 	menu $w.mb
	menu $w.mb.file
        $w.mb add cascade -label File     -underline 0 -menu $w.mb.file
	$w.mb.file add command -label "File..." \
	   -command { set ofname [ tk_getSaveFile \
			           -filetypes $ftypes \
		                   -initialdir $data_path \
                                   -defaultextension .xyz \
                                ];
		   if { $ofname != "" } {
                      set opath  "[ file dirname $ofname ]/";
                      set ofname [ file tail    $ofname ];
 		      set data_path $opath;
####		      .l1asc.cmd.ok configure -state normal;

	    #.l1asc.ops configure -state disabled
	    #.l1asc.fn.of configure -state disabled
	    #.l1asc.cmd.ok configure -state disabled

        set ptype [.l1wid.bf4.1.p getvalue]
  	set dtype [.l1wid.bf45.p.5 getvalue]
        set var_no [.l1wid.bf45.p.15 getvalue]
        set var_type [lindex $varlist $var_no]

     	if {$utmll == "UTM"} {set latlon 0}
     	if {$utmll == "LATLON"} {set latlon 1}
	    if {$zclip == 0} { set zclips  "\[\]" } 
	    if {$zclip == 1} { set zclips "\[$zmin, $zmax\]"}
	    if {$delimit == "space"} {
		set de "\" \""		
	    } 
	    if {$delimit == "comma"} {
		set de "\",\""		
	    } 
	    if {$delimit == "semicolon"} {
		set de "\";\""		
	    } 
	   

      set wtype ""
      set pstruc ""
      if {$ptype == 0} {
         set wtype 1
         set pstruc FS
      } elseif {$ptype == 1} {
         set wtype [expr {$dtype ? 2 : 1}]
         set pstruc GEO
      } elseif {$ptype == 2} {
         set wtype [expr {$dtype ? 3 : 1}]
         set pstruc VEG__
      } elseif {$ptype == 3} {
         set wtype 1
         set pstruc CVEG_ALL
      }
      if { $wtype ne "" && $pstruc ne "" } {
         exp_send "write_ascii_xyz, $var_type, \"$opath\", \"$ofname\", type=$wtype, indx=$indx, split=$split, intensity=$intensity, delimit=$de, zclip=$zclips, pstruc=$pstruc, rn=$rnidx, soe=$soeindx, header=$hline, latlon=$latlon;\r"
         expect ">"
      }
	    #destroy .l1asc
	  set write_some 0
	 }

        }

        wm title .l1asc "Write Ascii Data"
        LabelFrame .l1asc.ops -justify center -relief groove -borderwidth 3 -text "Options:"
        set utmll "UTM"
        tk_optionMenu .l1asc.ops.0 utmll UTM LATLON
        LabelFrame .l1asc.ops.1 -justify center -relief groove -borderwidth 3 -text "Include:"
        frame .l1asc.ops.2 -relief groove -borderwidth 3
        frame .l1asc.fn -relief groove -borderwidth 3
        frame .l1asc.cmd -relief groove -borderwidth 3
        set ptype [.l1wid.bf4.1.p getvalue]
        set var_no [.l1wid.bf45.p.15 getvalue]
        set var_type [lindex $varlist $var_no]

        # grid .l1asc.ops.dl .l1asc.ops.d -sticky ew 
        Separator .l1asc.ops.1.s0 -orient vertical -bg black -relief groove 
        Separator .l1asc.ops.1.s1 -orient vertical -bg black -relief groove 
      
        checkbutton .l1asc.ops.1.indx -text "Index Number" -variable indx 
        Separator .l1asc.ops.1.s2 -orient vertical -bg black -relief groove 

        checkbutton .l1asc.ops.1.rn -text "Raster/Pulse Number" -variable rnidx 
        Separator .l1asc.ops.1.s3 -orient vertical -bg black -relief groove 

        checkbutton .l1asc.ops.1.int -text "Intensity Data" -variable intensity 

        checkbutton .l1asc.ops.1.soe -text "SOE" -variable soeindx 
        Separator .l1asc.ops.1.s4 -orient vertical -bg black -relief groove 

        checkbutton .l1asc.ops.1.header -text "Header" -variable hline 
        Separator .l1asc.ops.1.s5 -orient vertical -bg black -relief groove 

        Separator .l1asc.ops.2.s1 -orient vertical -bg black -relief groove 

        label .l1asc.ops.2.dl -text "Delimiter: " 
        tk_optionMenu .l1asc.ops.2.d delimit comma semicolon space

        LabelEntry .l1asc.ops.2.split -width 7 -bd 3 -label "Max number of lines/file" \
		-helptext "Enter maximum number of lines in each file; enter 0 to write all data in 1 file" \
		-textvariable split 

        Separator .l1asc.ops.2.s2 -orient vertical -bg black -relief groove 

        checkbutton .l1asc.ops.2.zclip -text "Z Clipper:" -variable zclip \
		-command {
		   if {$zclip == 1} {
			.l1asc.ops.2.zmin configure -state normal
			.l1asc.ops.2.zmax configure -state normal
		   } 
		   if {$zclip == 0} {
			.l1asc.ops.2.zmin configure -state disabled
			.l1asc.ops.2.zmax configure -state disabled
		   }
           	 }
    	LabelEntry .l1asc.ops.2.zmin -width 5 -bd 3 -label "Zmin" \
		-textvariable zmin -state disabled
    	LabelEntry .l1asc.ops.2.zmax -width 5 -bd 3 -label "Zmax" \
		-textvariable zmax -state disabled

        pack .l1asc.ops.1.s0 .l1asc.ops.1.indx .l1asc.ops.1.s1 .l1asc.ops.1.rn .l1asc.ops.1.s2 .l1asc.ops.1.int .l1asc.ops.1.s3  .l1asc.ops.1.soe  .l1asc.ops.1.s4 .l1asc.ops.1.header .l1asc.ops.1.s5 -side left -fill both -padx 3

 	pack .l1asc.ops.2.dl .l1asc.ops.2.d .l1asc.ops.2.s1 .l1asc.ops.2.split .l1asc.ops.2.s2 .l1asc.ops.2.zclip .l1asc.ops.2.zmin .l1asc.ops.2.zmax -side left -padx 3 -fill both
	pack .l1asc.ops.0 .l1asc.ops.1 .l1asc.ops.2 -side top
 
 	Button .l1asc.cmd.cancel -text "Cancel" -width 5 -command {
	   set write_some 0
	   destroy .l1asc
 	}
 	Button .l1asc.cmd.dismiss -text "Dismiss" -width 5 -command {
	   destroy .l1asc
 	}
	pack .l1asc.cmd.cancel .l1asc.cmd.dismiss -side left -padx 5
###	pack .l1asc.fn.op .l1asc.fn.of -side top -pady 5	
        #pack .l1asc.ops.indx .l1asc.ops.int -side left
        pack .l1asc.ops .l1asc.fn .l1asc.cmd -side top
  }
.l1wid.mb.file add command -label "Load EAARL data from map limits" -underline 21 \
  -command {
	global data_file_path path
	set skipb 0
	set search .pbd
	
	if { [info exists data_file_path] == 0} {
		set data_file_path "~/"
	}
	
	destroy .l1map
	toplevel .l1map
	wm title .l1map "EAARL Data Loader"
	
	foreach x {1 2 3 4 5 6} {
		frame .l1map.$x
		pack .l1map.$x -side top
	}
   
	LabelEntry .l1map.1.path -relief sunken -borderwidth 3 \
	   -label "Path:  " -width 70 -helptext "Enter path to processed data" \
	   -textvariable data_file_path -text $data_file_path

	Button .l1map.1.pathbutton -text "Browse..." -helptext "Open dialog to select path" \
	   -command {
           global data_file_path 
           set data_file_path [ tk_chooseDirectory -initialdir $data_file_path -mustexist 1 -title "Processed Data Directory" ]/
        }

#	ComboBox .l1map.2.rcf -text "RCF Mode..." -width 10 \
#   	   -helptext "Select RCF mode" \
#	   -editable 0 \
#	   -values { none RCF IRCF } \
#	   -takefocus 0 \
#	   -modifycmd {
#		set rcf [.l1map.2.rcf getvalue]
#	   }
	
#	ComboBox .l1map.2.dat -text "Datum..." -width 10 \
#   	   -helptext "Select Datum" \
#	   -editable 0 \
#	   -values { w84 n88 } \
#	   -takefocus 0 \
#	   -modifycmd {
#		set dat [.l1map.2.dat getvalue]
#	   }

	ComboBox .l1map.2.mode -text "Data Type..." -width 10 \
   	   -helptext "Select Data Type" \
	   -editable 0 \
	   -values { FirstSurface Bathy BareEarth } \
	   -takefocus 0 \
	   -modifycmd {
		set mode [.l1map.2.mode getvalue]
		set modes [ expr $mode + 1 ]
	   }

	Label .l1map.2.winl -text "Win:"	
	SpinBox .l1map.2.win -justify center -range {0 7 1} \
	   -width 2 -textvariable win_no 
	 
	checkbutton .l1map.2.skipb -text "Use This Skip:" -variable skipb \
	   -command {
		if {$skipb == 1} {
		   .l1map.2.skip configure -state normal
		}
		if {$skipb == 0} {
		   .l1map.2.skip configure -state disabled
		}
	   }

	LabelEntry .l1map.2.skip -width 5 -bd 3 -label "Skip" \
	   -textvariable skipl -state disabled
	
	LabelEntry .l1map.2.search -width 15 -bd 3 -label "Search String:" \
	   -textvariable search
	
	Button .l1map.2.go -text "Load" -helptext "Click button to load data" \
	   -command {
		append_varlist "exploredata"
		set mvar "exploredata"
		set curvar "exploredata"
#		if {$dat == 0} {
#		   set datt "w84"
#		}
#		if {$dat == 1} {
#		   set datt "n88"
#		}
		if {$skipb == 1} {
		   exp_send "explorestart, \"$data_file_path\", $modes, win=$win_no, search_str=\"$search\", forceskip=$skipl\r"
		   expect ">"
		}
		if {$skipb == 0} {
		   exp_send "explorestart, \"$data_file_path\", $modes, win=$win_no, search_str=\"$search\"\r"
		   expect ">"
		}
	}
	pack .l1map.1.path .l1map.1.pathbutton -side left -padx 5
#	pack .l1map.2.rcf .l1map.2.dat .l1map.2.mode .l1map.2.winl .l1map.2.win .l1map.2.skipb .l1map.2.skip .l1map.2.search .l1map.2.go -side left -padx 5
	pack .l1map.2.mode .l1map.2.winl .l1map.2.win .l1map.2.skipb .l1map.2.skip .l1map.2.search .l1map.2.go -side left -padx 5
  }
	

.l1wid.mb       add cascade -label "Load" -underline 0 -menu .l1wid.mb.load
.l1wid.mb.file  add command -label "Dismiss" -underline 0 -command {destroy .l1wid}
.l1wid.mb.load  add command -label "Load TANS Data .. " -underline 5 \
		-command { exp_send "tans = rbtans();\r" 
			   expect ">"
			 }
.l1wid.mb.load  add command -label "Load DMARS PBD Data .. " -underline 5 \
		-command load_dmars;


.l1wid.mb.load add command -label "Load PNAV Data .. " -underline 5 \
	-command { exp_send "pnav = rbpnav(); \r"
			 }

 .l1wid.mb.load add command -label "Load Ops_conf Settings..." -underline 5 \
	-command load_ops_conf 

.l1wid.mb.load add command -label "Load Bathymetry Settings .." -underline 21 \
	-command { 
            bathctl 
         }


.l1wid.mb add cascade -label Options -underline 0 -menu .l1wid.mb.options



.l1wid.mb.options add command -label "Configure elevation scale limits..." -underline 0 \
	-command { 
	   destroy  .l1wid-opts
 	   toplevel .l1wid-opts
    	   wm title .l1wid-opts "Set Elevation Scale limits"
	   frame .l1wid-opts.f1
	   frame .l1wid-opts.f2
	   frame .l1wid-opts.f3
	   frame .l1wid-opts.f4
	   #set cmax_max 5000
	   #set cmax_min -200
	   set cmax_inc 0.1
	   Label .l1wid-opts.f1.label -text "Set Max Cmax scale to:" 
	   Label .l1wid-opts.f2.label -text "Set Min Cmin scale to:" 
	   Label .l1wid-opts.f3.label -text "Set Increment to:" 
	   SpinBox  .l1wid-opts.f1.max -range { -10000. 50000. 10. } -width 10 \
		-textvariable cmax_max 
	   SpinBox  .l1wid-opts.f2.min -range { -10000. 50000. 10. } -width 10 \
                -textvariable cmax_min 
	   SpinBox  .l1wid-opts.f3.inc -width 10 \
		-values { 0.1 0.2 .25 .5 .75 1.0 1.5 2.0 2.5 3 4 5 6 7 8 9 10 15 20 25 }  \
                -textvariable cmax_inc 

    	    Button .l1wid-opts.f4.go -text "Go" -width 10 -command {
		   set rg [list $cmax_min $cmax_max $cmax_inc]
		   .l1wid.bf45.sc.1.cmin.sc configure -from $cmax_min -to $cmax_max -resolution $cmax_inc
		   .l1wid.bf45.sc.1.cmin.sb configure -range $rg
		   .l1wid.bf45.sc.1.cmax.sc configure -from $cmax_min -to $cmax_max -resolution $cmax_inc
		   .l1wid.bf45.sc.1.cmax.sb configure -range $rg
		    set cmax_delta [expr $cmax_max - $cmax_min]
		    set cdel_rg [list 0 $cmax_delta $cmax_inc]
		   .l1wid.bf45.sc.1.cdelta.sc configure -from 0 -to $cmax_delta -resolution $cmax_inc
		   .l1wid.bf45.sc.1.cdelta.sb configure -range $cdel_rg
    		}

    	    Button .l1wid-opts.f4.dis -text "Dismiss" -width 10 -command {
          	    destroy .l1wid-opts
	   	}

	   pack .l1wid-opts.f1.label .l1wid-opts.f1.max -side left -fill x
	   pack .l1wid-opts.f2.label .l1wid-opts.f2.min -side left -fill x
	   pack .l1wid-opts.f3.label .l1wid-opts.f3.inc -side left -fill x
	   pack .l1wid-opts.f4.go .l1wid-opts.f4.dis -side left -fill x
	   pack .l1wid-opts.f1 .l1wid-opts.f2 .l1wid-opts.f3 .l1wid-opts.f4 -side top -anchor e -pady 5
         }
.l1wid.mb.options add checkbutton -label "Log Histograms" -underline 0 \
	-variable hist_log \
	-command hist_linlog 

.l1wid.mb.options add command -label "Plot/Write Individual Flightlines..." -underline 0 \
 -command {
    global list lrnindx
    destroy .l1plot
    toplevel .l1plot 
    wm title .l1plot "Plot / Write Selected Flightlines"
    frame .l1plot.1
    listbox .l1plot.1.lb -selectmode extended -width 50 -xscrollcommand ".l1plot.xscroll set" -yscrollcommand ".l1plot.1.yscroll set" 
    scrollbar .l1plot.xscroll -orient horizontal -command [list .l1plot.1.lb xview]
    scrollbar .l1plot.1.yscroll -command [list .l1plot.1.lb yview]
    for {set i 0} { $i < [llength $lrnindx] } {incr i} { 
       set e [lindex $lrnindx $i]
       set rnf [lindex $list [expr ($i*2)]]
       set rnl [lindex $list [expr ($i*2+1)]]
       .l1plot.1.lb insert end "Flightline $i. Rasters $rnf to $rnl. Start Index = $e" 
    }
    
    Button .l1plot.sall -text "Select All" -width 10 -command {
        .l1plot.1.lb selection set 0 [llength $lrnindx]
    }

    Button .l1plot.clear -text "Clear All" -width 10 -command {
        .l1plot.1.lb delete 0 end
       set list {}
       set lrnindx {}
    }

    Button .l1plot.plot -text "Plot" -width 6 -command {
	make_selected_arrays {junk}
	plot_fltlines 1
    }

    Button .l1plot.write -text "Write Datafile" -command {
#	 set write_some 1
#	 make_selected_arrays {junk}
#        .l1wid.bf5.1 invoke	
    }

    pack .l1plot.1.lb .l1plot.1.yscroll -side left -fill y 
    pack .l1plot.1 .l1plot.xscroll -side top -fill x
    pack .l1plot.sall .l1plot.clear .l1plot.plot .l1plot.write -side left -fill x
}

.l1wid.mb.options add command -label "Show Flightlines with No Raster Data..." -underline 25 \
 -command {
   exp_send "plot_no_raster_fltlines(gga, edb);\r"
 }

.l1wid.mb.options add command -label "Show Flightlines with No TANS Data..." -underline 25 \
 -command {
   exp_send "plot_no_tans_fltlines(tans, gga);\r"
 }

.l1wid.mb.options add command -label "List Plot Variables..." -underline 10 -command {
    varlist_plot
}

proc varlist_plot {} {
    global varlist
    destroy .varplot
    toplevel .varplot 
    wm title .varplot "List"
    frame .varplot.1
    frame .varplot.2
    listbox .varplot.1.lb -selectmode single -width 12 -xscrollcommand ".varplot.1.xscroll set" -yscrollcommand ".varplot.1.yscroll set"
    scrollbar .varplot.1.xscroll -orient horizontal -command [list .varplot.1.lb xview]
    scrollbar .varplot.1.yscroll -command [list .varplot.1.lb yview]
    for {set i 0} { $i < [llength $varlist] } {incr i} { 
       .varplot.1.lb insert end [lindex $varlist $i]
    }
    Button .varplot.2.select -text "Select" -command {
      set plot_var [lindex $varlist [.varplot.1.lb curselection]]
      .l1wid.bf45.p.15 setvalue @[.varplot.1.lb curselection]
    }
    LabelEntry .varplot.2.add -width 8 -relief sunken -label "Add:" -helptext "Add variable name to list" \
      -textvariable addvar 
    .varplot.2.add bind <Return> { 
        global varlist
	append_varlist $addvar
    }
    Button .varplot.2.delete -width 8 -text "Delete" \
       -command {
         set del_no [.varplot.1.lb curselection]
         if {$del_no <= 3} {
          # don't delete fixed variables
       	  tk_messageBox  -icon warning \
            -message "Cannot delete this variable" \
             -type ok
         } else {
          set del_var [lindex $varlist $del_no]
       	  set choice [tk_messageBox  -icon question \
            -message "Deleting variable $del_var.  Are you sure??" \
             -type yesno -title "Warning" ]
          if {$choice == "yes"} {
           set new_varlist1 [lrange $varlist 0 [expr ($del_no-1)]]
           set new_varlist2 [lrange $varlist [expr ($del_no+1)] end]
	   .varplot.1.lb delete $del_no $del_no	
           set varlist [concat $new_varlist1 $new_varlist2]
           .l1wid.bf45.p.15 configure -values $varlist
           exp_send "$del_var = \[\];\r"
          }
         }
    }
    Button .varplot.2.dismiss -text "Dismiss" -width 8 -command {
          destroy .varplot
    }
    pack .varplot.2.select .varplot.2.add .varplot.2.delete .varplot.2.dismiss -side top -fill x
    grid .varplot.1.lb      -in .varplot.1 -column 0 -row 0 -sticky "nswe"
    grid .varplot.1.yscroll -in .varplot.1 -column 1 -row 0 -sticky "ns"
    grid .varplot.1.xscroll -in .varplot.1 -column 0 -row 1 -sticky "ew"
    grid columnconfigure .varplot.1 0 -weight 1
    grid rowconfigure    .varplot.1 0 -weight 1
    pack .varplot.1 -in .varplot -side top -fill both -expand 1
    pack .varplot.2 -in .varplot -side top -fill x
  }

proc append_varlist {newvar} {
  global varlist plist cmin cmax msize markerv
  set ptype [.l1wid.bf4.1.p getvalue]
  set dtype [.l1wid.bf45.p.5 getvalue]

  ## save previous variable's constants in plist
  set curvar  [lindex $varlist [.l1wid.bf45.p.15 getvalue]]
  set lslth [expr ([lsearch -exact $varlist $curvar] + 1)]
  set plist(idx$lslth,cmin) $cmin
  set plist(idx$lslth,cmax) $cmax
  set plist(idx$lslth,ptype) $ptype
  set plist(idx$lslth,dtype) $dtype
  set plist(idx$lslth,msize) $msize
  set plist(idx$lslth,mtype) $markerv

  if {[lsearch -exact $varlist $newvar] == -1} {
      lappend varlist $newvar
      ## save current constants to $newvar
      set lslth [llength $varlist]
      set plist(idx$lslth,cmin) $cmin
      set plist(idx$lslth,cmax) $cmax
      set plist(idx$lslth,ptype) $ptype
      set plist(idx$lslth,dtype) $dtype
      set plist(idx$lslth,msize) $msize
      set plist(idx$lslth,mtype) $markerv
      .l1wid.bf45.p.15 configure -values $varlist
      varlist_plot
      .varplot.1.lb insert end $newvar
      varlist_plot
  } else {
     ## save current constants to $newvar even if it exists
     set lslth [expr ([lsearch -exact $varlist $newvar] + 1)]
     set plist(idx$lslth,cmin) $cmin
     set plist(idx$lslth,cmax) $cmax
     set plist(idx$lslth,ptype) $ptype
     set plist(idx$lslth,dtype) $dtype
     set plist(idx$lslth,msize) $msize
     set plist(idx$lslth,mtype) $markerv
  }
}

.l1wid.mb.options add checkbutton -label "Constant Colorbar for Variables" \
	-variable cbv \
	-command {
  	    if {$cbv == 1} {
		global cbvc
		set cbvc(cmin) $cmin
		set cbvc(cmax) $cmax
		set cbvc(msize) $msize
		set cbvc(mtype) $markerv
 	    }
     	}
               
.l1wid.mb.options add checkbutton -label "Set Plot Limits" -variable setll \
	-command {
	    if {$setll == 1} {
	    	exp_send "_ytk_ll = limits();\n"
	    }
	 }

.l1wid.mb.options add checkbutton -label "Show raw and processed waveforms when using Pixel Waveform" -variable bconst 

proc make_selected_arrays {junk} {
    global lrnindx list
    	set curlist [.l1plot.1.lb curselection]
        set ptype [.l1wid.bf4.1.p getvalue]
 	if {$ptype == 0} {
    	  exp_send "fs_some = \[\];\r"
	  expect ">"
	  foreach f $curlist {
           set fidx [lindex $lrnindx $f] 
	   set lidx [lindex $lrnindx [expr ($f+1)]]
	   if {[expr ($lidx-$fidx)] != 0} {
	    if {($lidx != "")} { 
	      set lidx [expr ($lidx - 1)]
 	      exp_send "grow, fs_some, fs_all($fidx:$lidx);\r"
	      expect ">"
	    } else {
	      exp_send "grow, fs_some, fs_all($fidx:);\r"
	      expect ">"
 	    }
	   }
    	  }
        }
 	if {$ptype == 1} {
    	  exp_send "depth_some = \[\];\r"
	  expect ">"
	  foreach f $curlist {
           set fidx [lindex $lrnindx $f] 
	   set lidx [lindex $lrnindx [expr ($f+1)]]
	   if {[expr ($lidx-$fidx)] != 0} {
	    if {$lidx != ""} {
	      set lidx [expr ($lidx - 1)]
 	      exp_send "grow, depth_some, depth_all($fidx:$lidx);\r"
	      expect ">"
	    } else {
	      exp_send "grow, depth_some, depth_all($fidx:);\r"
	      expect ">"
 	    }
	   }
    	  }
        }
 	if {$ptype == 2} {
    	  exp_send "veg_some = \[\];\r"
	  expect ">"
	  foreach f $curlist {
           set fidx [lindex $lrnindx $f] 
	   set lidx [lindex $lrnindx [expr ($f+1)]]
	   if {[expr ($lidx-$fidx)] != 0} {
	    if {$lidx != ""} {
	      set lidx [expr ($lidx - 1)]
 	      exp_send "grow, veg_some, veg_all($fidx:$lidx);\r"
	      expect ">"
	    } else {
	      exp_send "grow, veg_some, veg_all($fidx:);\r"
	      expect ">"
 	    }
	   }
    	  }
        }
 	if {$ptype == 3} {
    	  exp_send "cveg_some = \[\];\r"
	  expect ">"
	  foreach f $curlist {
           set fidx [lindex $lrnindx $f] 
	   set lidx [lindex $lrnindx [expr ($f+1)]]
	   if {[expr ($lidx-$fidx)] != 0} {
	    if {$lidx != ""} {
	      set lidx [expr ($lidx - 1)]
 	      exp_send "grow, cveg_some, cveg_all($fidx:$lidx);\r"
	      expect ">"
	    } else {
	      exp_send "grow, cveg_some, cveg_all($fidx:);\r"
	      expect ">"
 	    }
	   }
    	  }
        }
}
    
proc hist_linlog {} {
 global hist_log
       exp_send "_win=window();window,0;\
  logxy,0,$hist_log; range,$hist_log;window,_win \r"
}


.l1wid.mb   add cascade -label Graph -underline 0 -menu .l1wid.mb.graph
.l1wid.mb.graph add radiobutton \
        -label "75 Dpi (450x450)" -value "75" -variable plot_dpi -underline 1 \
	-command {
	   set changed_dpi 1
	}
.l1wid.mb.graph add radiobutton \
        -label "100 Dpi (600x600)" -value "100" -variable plot_dpi -underline 1 \
	-command {
	   set changed_dpi 1
	}
.l1wid.mb.graph add radiobutton \
        -label "100 Dpi (1100x850)" -value "1100" -variable plot_dpi -underline 1 \
	-command {
	   set changed_dpi 1
	}
.l1wid.mb.graph add command -label "Open the Limits Tool" -underline 0 -command { limits_tool }

.l1wid.mb   add cascade -label PostProcessing -underline 0 -menu .l1wid.mb.post


.l1wid.mb.post add command -label "Datum Convert" -underline 0 -command {
   datum_proc    
}

.l1wid.mb.post add command -label "RCF Region Filter" -underline 0 -command {
    rcf_region
}

.l1wid.mb add cascade -label CmdLine -underline 1 -menu .l1wid.mb.cmd

.l1wid.mb.cmd add command -label "mtransect" -command {
      exp_send "require,\"transect.i\"; help,mtransect\r" 
}
 .l1wid.mb.cmd add command -label "batch_process" -command {  
      exp_send "require, \"batch_process.i\"; help,batch_process\r" 
 }
 .l1wid.mb.cmd add command -label "batch_rcf(Filter)" -command {  
      exp_send "require, \"batch_process.i\"; help,batch_rcf\r" 
 }
 .l1wid.mb.cmd add command -label "batch_datum_convert" -command {  
      exp_send "require, \"batch_datum_convert.i\"; help,batch_datum_convert\r" 
 }
 .l1wid.mb.cmd add command -label "batch_veg_lfpw" -command {  
      exp_send "require, \"batch_veg_energy.i\"; help,batch_veg_lfpw\r" 
 }
 .l1wid.mb.cmd add command -label "batch_pbd2las" -command {  
      exp_send "require, \"pbd2las.i\"; help,batch_pbd2las\r" 
 }
 .l1wid.mb.cmd add command -label "batch_write_xyz" -command {  
      exp_send "require, \"batch_process.i\"; help,batch_write_xyz\r" 
 }


.l1wid.mb add cascade -label Diagnostics -underline 0 -menu .l1wid.mb.diag

.l1wid.mb.diag add command -label "Transect Tool" -command {
       source "$src_path/transrch.ytk"
}

.l1wid.mb.diag add command -label "Flightline Analysis Tool" -command {
}

.l1wid.mb.diag entryconfigure 2 -state disabled

proc rcf_region {} {
    global varlist l1pro_data
    destroy .rcf
    destroy .ircf
    toplevel .rcf
    wm title .rcf "Random Consensus Filter"
    frame .rcf.0 -relief groove -borderwidth 3
    frame .rcf.1 
    frame .rcf.2 
    frame .rcf.3 
    frame .rcf.4 
    frame .rcf.5 
    frame .rcf.6 

    ComboBox .rcf.0.mode -text "Select RCF type" -width 18 -values { 
		RCF 
		Iterative\ RCF} \
	-helptext "Select the type of RCF filter" -editable 0 \
	-modifycmd {
    	    set rcfmode [.rcf.0.mode getvalue]
	    if {$rcfmode == -1} {
		set rcfmode 0
            }
	    if {$rcfmode == 1} {
		pack forget .rcf.3
    		pack .rcf.0 .rcf.1 .rcf.2 .rcf.5 .rcf.6 .rcf.3 -side top -pady 10
            } else {
		pack forget .rcf.5 .rcf.6
	    }
         }

    Button .rcf.0.help -text "Help" -width 8 -bd 5 \
	-command {
    	    set rcfmode [.rcf.0.mode getvalue]
	    if {$rcfmode == -1} {
       	        tk_messageBox  -icon info \
        	   -message "Select one of the filtering methods in the drop down menu.  Click Help on each selection to learn more about the filtering method" \
        	-type ok -title "Select RCF Type -- Help"
            }
	    if {$rcfmode == 0} {
		exp_send "help, rcfilter_eaarl_pts\r"
            }
	    if {$rcfmode == 1} {
		exp_send "help, rcf_triag_filter\r"
            }
        }
	     

    LabelEntry .rcf.1.buf -width 4 -relief sunken -label "Input Window (cm):" -helptext "The input window size that will slide through the data set (in centimeters)" \
      -textvariable buf -text 500
    LabelEntry .rcf.1.w -width 4 -relief sunken -label "Elevation width (cm):" -helptext "The vertical extent or range of the filter (in centimeters)" \
      -textvariable w -text 20
    LabelEntry .rcf.1.no -width 4 -relief sunken -label "Minimum winners:" -helptext "The minimum number of winners" \
      -textvariable no_rcf -text 3

    Label .rcf.2.varname -text "Input Variable:"
    ComboBox .rcf.2.varlist  -values \
  	$varlist \
	-helptext "Select any one of the following variables to RCF" \
	-editable 0 -width 10 \
        -modifycmd { 
         global outvar varlist
         set curvar [lindex $varlist [.rcf.2.varlist getvalue]]
         set outvar "rcf_$curvar"
        }

    set curvar [.l1wid.bf45.p.15 getvalue]
    .rcf.2.varlist setvalue @$curvar

    Label .rcf.2.dispname -text "Mode:"
    ComboBox .rcf.2.disp -width 20 \
	-values $l1pro_data(processing_mode) \
	-helptext "Select any one of the following" \
	-editable 0 
	   
    set curproc [.l1wid.bf4.1.p getvalue]
    .rcf.2.disp setvalue @$curproc

    set curvar  [lindex $varlist [.rcf.2.varlist getvalue]]
    LabelEntry .rcf.2.outvar -relief sunken \
	-label "Output Variable:" -helptext "Define output variable" \
	-textvariable outvar -text "rcf_$curvar" -width 10

    LabelEntry .rcf.5.premin -relief sunken -label "Pre-filter Elevations (m): Min" -helptext "Use this minimum elevation (in m) before applying RCF. Leave blank for no value" \
	-textvariable prefilter_min -text "" -width 4
   
    LabelEntry .rcf.5.premax -relief sunken -label "Max" -helptext "Use this maximum elevation (in m) before applying RCF. Leave blank for no value" \
	-textvariable prefilter_max -text "" -width 4

    LabelEntry .rcf.5.tai -relief sunken -label "No. of iterations" -helptext "Number of RCF iterations to perform (default = 3)" \
	-textvariable tai -text 3 -width 2

    LabelEntry .rcf.5.tw -relief sunken -label "TIN elev width (cm)" -helptext "Vertical range (in cm) used in each iteration to densify the point cloud after triangulating" \
	-textvariable tw -text 20 -width 4

    checkbutton .rcf.6.inter -text "Interactive?" -variable interactive \
	-command {
 	     if {($interactive == 1) && ($plottriagwin == "")} {
		set plottriagwin 4
	     }
 	}
    set interactive 0

    LabelEntry .rcf.6.triagwin -relief sunken -label "Plot TIN in win:" -helptext "Plot TIN during each iteration in this window number.  Leave blank to not plot the TINs.  If interactive is set, default window is 4" \
	-textvariable plottriagwin -width 4

    LabelEntry .rcf.6.distthresh -relief sunken -label "Distance Threshold (m):" \
	-textvariable distthresh -text 100  -width 4 \
	-helptext "Enter distance threshold (in meters) that sets the maximum allowable length of any side of a triangle in the TIN model.  Set to 0 if you don't want to use it.  Defaults to 100m."

    Button .rcf.3.go -width 8 -text "Go" \
       -command {
        global varlist outvar
        set curvar [lindex $varlist [.rcf.2.varlist getvalue]]
        switch [.rcf.2.disp getvalue] {
        "0" { set mode 1}
        "1" { set mode 2}
        "2" { set mode 3}
        } 
	append_varlist $outvar
        set rcfmode [.rcf.0.mode getvalue]
        if { $rcfmode == 1 } {
          if {$plottriagwin != ""} {
               set plottriag 1
          } else {
      		set plottriag ""
	  }
	  set datawin [.l1wid.bf45.p.3 getvalue]
          exp_send "$outvar = rcf_triag_filter($curvar, buf=$buf, w=$w, no_rcf=$no_rcf, mode=$mode, tw=$tw, interactive=$interactive, tai=$tai, plottriag=$plottriag, plottriagwin=$plottriagwin, prefilter_min=$prefilter_min, prefilter_max=$prefilter_max, distthresh=$distthresh, datawin=$datawin );\r\n"
	} else {
          exp_send "$outvar = rcfilter_eaarl_pts($curvar, buf=$buf, w=$w, no_rcf=$no_rcf, mode=$mode);\r\n"
        }
        
	destroy .rcf
    }
    Button .rcf.3.cancel -text "Cancel" -width 8 -command {
          destroy .rcf
    }
    pack .rcf.1.buf .rcf.1.w .rcf.1.no -side left -padx 3
    pack .rcf.2.varname \
        .rcf.2.varlist \
        .rcf.2.dispname \
        .rcf.2.disp \
       	.rcf.2.outvar \
	-side left -padx 3
    pack .rcf.3.go .rcf.3.cancel -side left -padx 5
    pack .rcf.0.mode .rcf.0.help -side left -padx 5
    pack .rcf.5.premin .rcf.5.premax .rcf.5.tai .rcf.5.tw -side left -padx 5
    pack .rcf.6.inter .rcf.6.triagwin .rcf.6.distthresh -side left -padx 5
    pack .rcf.0 .rcf.1 .rcf.2 .rcf.5 .rcf.6 .rcf.3 -side top -pady 10
    pack forget .rcf.5 .rcf.6
}
  

.l1wid.mb.post add command -label "Determine Roll Bias" -underline 0 \
	-command {
	global win_no plot_var varlist curvar bias
	
	destroy .l1bias
	toplevel .l1bias
	wm title .l1bias "Determine Roll Bias"
	
	foreach x {1 2 3 4 5 6} {
	frame .l1bias.$x
	pack .l1bias.$x -side top
	}

	if { [info exists bias ] == 0 } {
		exp_send "updatebias\r"
		expect ">"
		exp_send "updatebias\r"
		expect ">"
	}
	set slope 0
	set iob 0
	set inout 1
	set width 5
	set flwin 4
        set var [lindex $varlist [.l1wid.bf45.p.15 getvalue]]

	LabelEntry .l1bias.1.var -relief sunken -borderwidth 3 -width 10 \
	   -label "Variable:" -helptext "EAARL source data" \
	   -textvariable var -text $var

	Label .l1bias.1.winl -text "in window:"
	SpinBox .l1bias.1.win -justify center -range {0 7 1} -width 2 -textvariable win_no

	Label .l1bias.1.transl -text "Then click"
	Button .l1bias.1.transbutton -text "Get Transect" -helptext "Click to get transect" \
	   -command {
	   exp_send "transdata = get_transect($var, win=$win_no, update=1, width=$width)\r"
	   expect ">"
	   .l1bias.3.plot configure -state normal
	   .l1bias.3.winl configure -state normal
	   .l1bias.3.win configure -state normal
	   .l1bias.3.pick configure -state normal
	   .l1bias.3.inout configure -state normal
	   .l1bias.3.auto configure -state normal
	}

	Button .l1bias.1.help -text "Help!" -helptext "Click for directions" \
	   -command {
       	   tk_messageBox  -icon warning \
           -message "1) Start with data array plotted in a window and raw EAARL data loaded. Set the variable and window and click Get Transect.\r2) Drag a line perpendicular to the flightlines you wish to examine. In the window that appears, zoom into the top, type something, and hit enter. Now drag a box over the section of the transect you wish to keep.\r3) Click the plot button to display the loaded transect. In order to determine the bias automatically all flightlines must be traveling the same direction, so you'll need to remove whichever direction is the minority.\r4) Click 'select flightlines' and simply type 'y' or 'n' to keep or remove each flightline. Now you have a set of flightlines going the same direction.\r5) Finally, determine whether the flightlines are going into or out of the screen. If they are going INTO the screen, check the box." \
           -type ok
	}

	LabelEntry .l1bias.2.width -relief sunken -width 3 \
	   -label "Width:" -helptext "Transect width" \
	   -textvariable width -text $width

	LabelEntry .l1bias.2.bias -relief sunken -width 10 \
	   -label "Current Roll Bias:" -helptext "Current Roll Bias" \
	   -textvariable bias -text $bias

	LabelEntry .l1bias.2.slope -relief sunken -width 10 \
	   -label "Current Slope:" -helptext "Current slope" \
	   -textvariable slope -text $slope

	Button .l1bias.3.plot -text "Plot" -helptext "Click to plot flightline transect" \
	   -command {
	   exp_send "plot_flightline_transect(transdata, $flwin)\r"
	   expect ">"
	}

	Label .l1bias.3.winl -text "in win:"
	SpinBox .l1bias.3.win -justify center -range {0 7 1} \
	   -width 2 -textvariable flwin 

	Button .l1bias.3.pick -text "Select Flightlines" -helptext "Click to select which flightlines to keep" \
	   -command {
	   exp_send "transdata=selgoodflightlines(transdata, win=$flwin)\r"
	   expect ">"
	}
	
	checkbutton .l1bias.3.inout -text "in/out:" -variable iob \
	   -command {
		if {$iob == 1} {
		   set inout -1
		}
		if {$iob == 0} {
		   set inout 1
		}
	   }

	Button .l1bias.3.auto -text "Determine bias" -helptext "Click to automatically determine roll bias" \
	   -command {
	   exp_send "goodroll=find_roll_bias(transdata,0,$inout,update=1)\r"
	   expect ">"
	}

	pack .l1bias.1.var .l1bias.1.winl .l1bias.1.win .l1bias.1.transl .l1bias.1.transbutton .l1bias.1.help -side left
	pack .l1bias.2.width .l1bias.2.bias .l1bias.2.slope -side left
	pack .l1bias.3.plot .l1bias.3.winl .l1bias.3.win .l1bias.3.pick .l1bias.3.inout .l1bias.3.auto -side left
	.l1bias.3.plot configure -state disabled
	.l1bias.3.winl configure -state disabled
	.l1bias.3.win configure -state disabled
	.l1bias.3.pick configure -state disabled
	.l1bias.3.inout configure -state disabled
	.l1bias.3.auto configure -state disabled

	

}

ComboBox .l1wid.bf4.1.d -text "Define Region..." -width 15 -values \
       {
	 Rubberband\ Box\
	 Points\ in\ Polygon\
	 Rectangular\ Coords\
	 Multiple\ PIPs\
       }\
	 -helptext "Select region to process using any of the following methods" -editable 0 \
   -modifycmd {
    
    set defr [.l1wid.bf4.1.d getvalue]
    puts $defr
    if {$defr == 0} {
      if { $_ytk(annoying_help) == "Yes" } {
       	set result [tk_messageBox  -icon info \
        -message "Drag a Rectangular Box in Window $_map(window) to define region." \
        -type okcancel -title "Message"]
      } else {
        set result "ok"
      }
        if {$result == "ok"} {
         exp_send "q = gga_win_sel(2, win=$_map(window));\r"
         expect ">"
        }
    }
    if {$defr == 1} {
      if { $_ytk(annoying_help) == "Yes" } {
       	set result [tk_messageBox  -icon info \
        -message "Draw a Polygon in Window $_map(window) to define a region using a series of left mouse clicks.  To complete the polygon, middle mouse click OR <Ctrl> and left mouse click." \
        -type okcancel -title "Message"]
      } else {
        set result "ok"
      }
        if {$result == "ok"} {
         exp_send "q = gga_pip_sel(1, win=$_map(window));\r"
         expect ">"
        }
    }
    if {$defr == 2} {
        destroy .l1widc
        toplevel .l1widc
	frame .l1widc.lon
	frame .l1widc.1
	frame .l1widc.utm
	ComboBox .l1widc.utm.1 -text "Coordinate System" -width 18 -values "LatLon UTM" \
		-helptext "Select the Coordinate System." -editable 0 
	LabelEntry .l1widc.utm.2 -width 6 -relief sunken  -label "UTM Zone: " -helptext "Enter UTM Zone Here" \
		-textvariable zone 

	LabelEntry .l1widc.lat1 -width 12 -relief sunken -label "NorthLat/Max.Northing " \
		-helptext "Enter Maximum Latitude in degrees or Maximum UTM Northing in meters Here"\
		-textvariable mxlat
	LabelEntry .l1widc.lat2 -width 12 -relief sunken -label "SouthLat/Min.Northing  " \
		-helptext "Enter Minimum Latitude in degrees or Minimum UTM Northing in meters Here"\
		-textvariable mnlat

	LabelEntry .l1widc.lon.mn -width 12 -relief sunken -label "WestLon/Min.Easting  " \
		-helptext "Enter Westernmost Longitude in degrees or Minimum UTM Easting in meters Here"\
		-textvariable mnlon
	LabelEntry .l1widc.lon.mx -width 12 -relief sunken -label "EastLon/Max.Easting " \
		-helptext "Enter Easternmost Longitude in degrees or Maximum UTM Easting in meters Here"\
		-textvariable mxlon
	Button .l1widc.1.ok -text "OK" -width 5 -command {
          set utm [.l1widc.utm.1 getvalue]
          exp_send "utm = $utm; q = gga_win_sel(2, win=$_map(window), llarr=\[$mnlon, $mxlon, $mnlat, $mxlat\]);\r"
	  destroy .l1widc
	}
	Button .l1widc.1.box -text "Plot Region" -width 7 -command {
	   exp_send "a_x=\[$mnlon, $mxlon, $mxlon, $mnlon, $mnlon\];\r"
	   exp_send "a_y=\[$mnlat, $mnlat, $mxlat, $mxlat, $mnlat\];\r"
	   exp_send "window, $_map(window); plg, a_y, a_x;\r";
	}

	  
	Button .l1widc.1.cancel -text "Cancel" -width 5 -command {
	  destroy .l1widc
	}
	pack .l1widc.utm.1 .l1widc.utm.2 -side left 
	pack .l1widc.lon.mn .l1widc.lon.mx -side left -padx 4
	pack .l1widc.utm .l1widc.lat1 .l1widc.lon .l1widc.lat2 -side top -pady 5
	pack .l1widc.1.ok .l1widc.1.box .l1widc.1.cancel -side left
	pack .l1widc.1 -side top


   }
   if {$defr == 3} {
        exp_send "q = \[\]\r"
        expect ">"
	multi_pip_sel {}
   }
   if {$defr == -1} {
	error "Please Define Region."
   }
} 

set l1pro_data(processing_mode)  {\
		  First\ Return\ Topo\
		  Submerged\ Topo\
		  Topo\ Under\ Veg \
		  Multi\ Peak\ Veg \
		  Direct.\ Wave\ Spectra \
		}

proc multi_pip_sel {junk} {
    global _map tpath l1pro_data
    destroy .mpip
    toplevel .mpip
    frame .mpip.1
    frame .mpip.2

    global row 
    set row 20
    set tpath .mpip.1.table
    table $tpath \
	-rows $row \
	-cols 6 \
	-variable _mpipx \
	-titlerows 2 \
	-titlecols 0 \
	-yscrollcommand [list ".mpip.1.sy" set] \
	-xscrollcommand [list ".mpip.1.sx" set] \
	-coltagcommand colorize \
	-flashmode 1 \
	-selectmode extended \
	-width 5 -height 8 \
	-colwidth 15 \
	-multiline 0 \
	-sparsearray 0 \
	-browsecommand {set table(current) %S} 
    $tpath tag configure active \
	-fg blue \
	-relief sunken

    $tpath width 0 7
    $tpath width 3 25
    $tpath height 1 2

    scrollbar .mpip.1.sy -command [list $tpath yview]
    scrollbar .mpip.1.sx -command [list $tpath xview] -orient horizontal

    Button $tpath.pip -text "PIP Selector" \
	-command {
		global tpath varc _map pcurs
		set curs [$tpath curselection]
		if { [info exists curs] == 0 } {
		  if { [info exists pcurs] == 1 } {
			set curs $pcurs
		  } else {
			set curs "2,1"
		  }
		}
	  	set cidx [string first "," $curs]
		set cursr [string range $curs 0 [expr ($cidx-1)]]
		set cursc [string range $curs [expr ($cidx+1)] end]
        	if { ([info exists _mpipx($cursr,2) ] == 0) || ($_mpipx($cursr,2)=="") } {
		   set _mpipx($cursr,2) "ply_$cursr"
		   set _mpipx($cursr,5) "q_$cursr"
		}
        	if { [info exists _mpipx($cursr,1) ] == 0 } {
		   set _mpipx($cursr,1) "var_$_mpipx($cursr,2)"
		}
        	if { [info exists _mpipx($cursr,5) ] == 0 } {
		   set _mpipx($cursr,5) "q_$_mpipx($cursr,2)"
		}
		set pcurs $curs
       		exp_send "$_mpipx($cursr,5) = gga_pip_sel(1, win=$_map(window)); $_mpipx($cursr,2) = ply; \r"
       		expect ">"
	} \
        -helptext "Draw a Polygon in Window 6 to define a region using a series of left mouse clicks.  To complete the polygon, middle mouse click OR <Ctrl> and left mouse click." 
    $tpath window configure 1,2 -window $tpath.pip -sticky news

    Button $tpath.fbutton -text "Browse..." \
	-command {
	   global tpath
	   set curs [$tpath curselection]
           set ftypes {
                  {{For pbd}       {.pbd}        }
                  {{IDL bin}       {.bin}        }
                  {{IDL edf}       {.edf}        }
                  {{All Files}            *      }
           }
          set ofname [ tk_getSaveFile -filetypes $ftypes -defaultextension ".pbd" ]
	  set _mpipx($curs) $ofname
	   puts $curs
	}
    $tpath window configure 1,3 -window $tpath.fbutton -sticky news

    ComboBox $tpath.ptype -text "Process For..." -width 16 \
	-helptext "Process Data for any of the following" \
	-editable 0 \
	-values $l1pro_data(processing_mode) \
	-takefocus 0 \
	-modifycmd {
		global tpath
		set curs [$tpath curselection]
		set _mpipx($curs) [$tpath.ptype getvalue]
	} 
		
    $tpath window configure 1,4 -window $tpath.ptype -sticky news

    for {set seli 2} { $seli < $row } {incr seli} { 
      checkbutton $tpath.sel$seli -variable _mpipx($seli,0) 
      $tpath window configure $seli,0 -window $tpath.sel$seli -sticky news
    }

    Button .mpip.2.process -text "Process Now" -width 20 -bd 5 \
		-command \
     {
	global tpath _mpipx usecentroid data_var pip_var fname_var ptype_var
	set data_var "\["
	set pip_var "\["
	set qname_var "\["
	set fname_var "\["
	set ptype_var "\["
	set ply_var "\["
	set plyname_var "\["
        for {set seli 2} { $seli < $row } {incr seli} { 
	   if { $_mpipx($seli,0) == 1 } {
		append pip_var "&$_mpipx($seli,5),"
		append qname_var "\"$_mpipx($seli,5)\","
		append data_var "\"$_mpipx($seli,1)\","
		append fname_var "\"$_mpipx($seli,3)\","
		append ptype_var "$_mpipx($seli,4),"
		append ply_var "&$_mpipx($seli,2),"
		append plyname_var "\"$_mpipx($seli,2)\","
	    }
	}
	set pip_var [string replace $pip_var end end "\]"]
	set qname_var [string replace $qname_var end end "\]"]
	set data_var [string replace $data_var end end "\]"]
	set fname_var [string replace $fname_var end end "\]"]
	set ptype_var [string replace $ptype_var end end "\]"]
	set ply_var [string replace $ply_var end end "\]"]
	set plyname_var [string replace $plyname_var end end "\]"]
	exp_send "batch_multipip_process, $pip_var, $data_var, $fname_var, $ptype_var, $qname_var, $ply_var, $plyname_var \r\n"
	expect ">"
              
    }

    Button .mpip.2.delete -text "Delete Rows" -width 20 -bd 5 \
	-command \
    {
        global tpath _mpipx row 
        for {set seli 2} { $seli < $row } {incr seli} { 
	   if { $_mpipx($seli,0) == 1 } {
		set _mpipx($seli,0) 0
		$tpath delete rows $seli
		set row [expr {$row - 1}]
	   }
	}
    }
    .mpip.2.delete configure -state disabled
    Button .mpip.2.insert -text "Add Row" -width 20 -bd 5 \
	-command \
    {
        global tpath _mpipx row
	$tpath insert rows  [expr {$row-1}]
	set row [expr {$row + 1}]
    }
    .mpip.2.insert configure -state disabled
		
    pack .mpip.1.sx -side bottom -fill x
    pack .mpip.1.sy -side right -fill y
    pack .mpip.2.process .mpip.2.insert .mpip.2.delete -side left -padx 5
    pack $tpath -side left
    pack .mpip.1 .mpip.2 -side top

    
   # tk_messageBox  -icon info \
    #    -message "Draw a Polygon in Window 6 to define a region using a series of left mouse clicks.  To complete the polygon, hit middle mouse OR <Ctrl> and left mouse click." \
     #   -type ok -title "Message"
      #tk_messageBox -icon info \
#	-message "Select Region $ino" -type "ok" -title "Region $ino"
 #     exp_send "q = gga_pip_sel(1, win=$_map(window), multi=1);\r"
  #    expect ">"
}
   
ComboBox .l1wid.bf4.1.p -text "Process For..." -width 16 \
	-helptext "Process Data for any of the following" \
	-editable 0 \
	-values $l1pro_data(processing_mode) \
	-modifycmd {
		set curs [.l1wid.bf4.1.p getvalue]
		if {$curs == 1} {
		  .l1wid.bf4.2.surf configure -state active
		} else {
		  .l1wid.bf4.2.surf configure -state disabled
		}
		
	}
.l1wid.bf4.1.p setvalue first

ComboBox .l1wid.bf4.1.m -text "Method"  \
        -width 7 \
	-helptext "Batch or single processing" \
	-editable 0 \
	-values "Batch Single"
.l1wid.bf4.1.p setvalue first

Label .l1wid.bf4.1.lw -text "in Win:"
SpinBox .l1wid.bf4.1.sw -justify center -range {0 7 1} \
	-width 2 -textvariable _map(window)


#checkbutton .l1wid.bf4.2.cll -text "Convert UTM\nto Lat Lon" -variable cll 
# checkbutton .l1wid.bf4.2.cng -text "Convert to\nNAVD 88 (GEOID)" -variable cng 
checkbutton .l1wid.bf4.2.cen -text "Correct Range \nWalk with Centroid" -variable usecentroid 
checkbutton .l1wid.bf4.2.surf -text "Use Fresnel reflections\nto determine water surface" -variable avg_surf

.l1wid.bf4.2.surf configure -state disabled

checkbutton .l1wid.bf45.p.fma -text "Auto\nFma" -variable l1pro_fma 

Button .l1wid.bf45.p.1 -text "Plot" -command {
 plot_fltlines 0
}

Button .l1wid.bf45.p.14 -text "Variable:" -command {
  varlist_plot
}
ComboBox .l1wid.bf45.p.15  -values \
  	$varlist \
	-helptext "Select any one of the following variables " \
	-editable 0 \
	-modifycmd { 
	   global cbv
	   set var_no [.l1wid.bf45.p.15 getvalue]
           set var_type [lindex $varlist $var_no]
	   #puts "$var_no"
           if {$cbv == 0} {
	     retrieve_plot_settings $var_no
           }
	} \
	 -postcommand {
 	   global cbv
	   #puts "$var_no"
           set var_no [.l1wid.bf45.p.15 getvalue]
           set var_type [lindex $varlist $var_no]
#	   #puts "variable in postcommand $var_type no $pvar_no"
	   if {$cbv == 0} {
	     save_plot_settings  $var_no
           }
         } 
.l1wid.bf45.p.15 setvalue first

proc retrieve_plot_settings {pvar_no} {
   global cmin cmax msize markerv var_type plist 
   #puts "to retrieve _$var_type from $var_type"
   incr pvar_no
   #puts "pvar_no = $pvar_no"
   set cmin $plist(idx$pvar_no,cmin)
  #puts "$cmin read from  $plist(idx$pvar_no,cmin)"
   #puts "cmin = $cmin"
   set cmax $plist(idx$pvar_no,cmax)
   set msize $plist(idx$pvar_no,msize)
   set markerv $plist(idx$pvar_no,mtype)
   .l1wid.bf4.1.p setvalue @$plist(idx$pvar_no,ptype)
   .l1wid.bf45.p.5 setvalue @$plist(idx$pvar_no,dtype)
   
}

proc cbar_tool { } {
  global cbvc
  set w .cbartool
  destroy $w
  toplevel $w
  wm title $w "Color Bar Tool"
  frame $w.1
  Button $w.both -text "Both" \
         -helptext "Interactively set Cmin, Cmax by \
                     clicking in the histogram window" \
         -command {
          exp_send "set_cbar, \"both\" \r"
	  expect ">"
         }
  Button $w.cmax -text "Cmax" \
         -helptext "Interactively set Cmax by \
                     clicking in the histogram window" \
         -command {
          exp_send "set_cbar, \"cmax\" \r"
         }
  Button $w.cmin -text "Cmin" \
         -helptext "Interactively set Cmin by \
                     clicking in the histogram window" \
         -command {
          exp_send "set_cbar, \"cmin\" \r"
         }
  Button $w.dismiss -text "Dismiss" -command {
           destroy .cbartool
         }
  pack \
	$w.both \
	$w.cmax \
	$w.cmin \
	$w.dismiss \
	-side top \
	-fill both
}


proc save_plot_settings {pvar_no} {
  global cmin cmax msize markerv var_type plist
  #puts "to save $var_type in _$var_type"
  incr pvar_no
  set ptype [.l1wid.bf4.1.p getvalue]
  set dtype [.l1wid.bf45.p.5 getvalue]
  set plist(idx$pvar_no,cmin) $cmin
  #puts "$cmin written to $pvar_no = $plist(idx$pvar_no,cmin)"
  set plist(idx$pvar_no,cmax) $cmax
  set plist(idx$pvar_no,msize) $msize
  set plist(idx$pvar_no,mtype) $markerv
  set plist(idx$pvar_no,ptype) $ptype
  set plist(idx$pvar_no,dtype) $dtype
}

Label .l1wid.bf45.p.2 -text "in Win:"
SpinBox .l1wid.bf45.p.3 -justify center -range {0 7 1} \
	-width 2 -textvariable win_no 

Label .l1wid.bf45.p.25 -text "Mode:"
ComboBox .l1wid.bf45.p.5 -text "Display Type" -width 20 -values { \
	First\ Return\ Topography \
        Submerged\ Topography \
	Water\ Depth \
        Bare\ Earth\ Topography\
        Surface\ Amplitude \
        Bottom\ Amplitude \
        Canopy\ Height \
        } \
	-helptext "Select any one of the following" \
	-editable 0

.l1wid.bf45.p.5 setvalue first

Button .l1wid.bf45.q.2 -text "Histogram\nElevations" \
  -helptext "Generate and display a histogram of all the first return elevations" \
  -command {
      global cbvc cmin cmax
      set ptype [.l1wid.bf4.1.p getvalue]
      set disp_type [.l1wid.bf45.p.5 getvalue]
      set var_no [.l1wid.bf45.p.15 getvalue]
      set var_type [lindex $varlist $var_no]
      if {$disp_type == -1} {
       	tk_messageBox  -icon warning \
        -message "You need to specify the type of data before using this function!" \
        -type ok
     }
     if {$ptype == 0} {
      exp_send "hst = hist_fs($var_type, win=7, dofma=1); \r"
     }
     if {$ptype == 1} {
      if {$disp_type == 0} {
   	exp_send "hst = hist_fs($var_type, win=7, dofma=1);\r"
      } else {
        exp_send "hst = hist_depth($var_type, win=7, dofma=1); \r"
      }
     }
     if {$ptype == 2} {
      if {$disp_type == 0} {
   	exp_send "hst = hist_fs($var_type, win=7, dofma=1);\r"
      } else {
        exp_send "hst = hist_veg($var_type, win=7, dofma=1); \r"
      }
     }
     cbar_tool
     set cbvc(cmin) $cmin
     set cbvc(cmax) $cmax
  }

Button .l1wid.bf45.q.1 -text "Pixel\nWaveform" \
  -helptext "Click to jump to raster, pulse, and image for xyz point" \
  -command {
     global bconst
     if {$bconst == 1} {
	set bconst 2
     }
     set ptype [.l1wid.bf4.1.p getvalue]
     set disp_type [.l1wid.bf45.p.5 getvalue]
     set var_no [.l1wid.bf45.p.15 getvalue]
     set var_type [lindex $varlist $var_no]
     if {$disp_type == -1} {
       	tk_messageBox  -icon warning \
        -message "You need to specify the type of data before using this function!" \
        -type ok
     }
     if {$ptype == 0} {
        exp_send "mindata = raspulsearch($var_type, win=$win_no, cmin=$cmin, cmax=$cmax, msize=$msize, disp_type=$disp_type, ptype=$ptype, lmark = lmark);\r"
     }
     if {$ptype == 1} {
        exp_send "mindata = raspulsearch($var_type, win=$win_no, cmin=$cmin, cmax=$cmax, msize=$msize, disp_type=$disp_type, ptype=$ptype, lmark = lmark, bconst=$bconst );\r"
     }
     if {$ptype == 2} {
        exp_send "mindata = raspulsearch($var_type, win=$win_no, cmin=$cmin, cmax=$cmax, msize=$msize, disp_type=$disp_type, ptype=$ptype, lmark = lmark);\r"
     }
     if {$ptype == 3} {
        exp_send "mindata = raspulsearch($var_type, win=$win_no, cmin=$cmin, cmax=$cmax, msize=$msize, disp_type=$disp_type, ptype=$ptype, lmark = lmark, bconst=$bconst );\r"
     }
   }
	   
Button .l1wid.bf45.q.3 -text "Color\nBar" \
	-command { 
   	global win_no
        exp_send "window, $win_no; colorbar, $cmin, $cmax, drag=1\r";
}
Button .l1wid.bf45.q.4 -text "Elevation\nClipper" \
		-command {
	global varlist
	destroy .l1clip
        toplevel .l1clip
        wm title .l1clip "Elevation Clipper"
	frame .l1clip.05
	frame .l1clip.1
	frame .l1clip.2
	frame .l1clip.3
	frame .l1clip.4
        set ptype [.l1wid.bf4.1.p getvalue]
	#SpinBox  .l1clip.max -range { -100. 5000. 10. }  \
	#	-textvariable max_elv -text "Maximum Elevation"
	#SpinBox  .l1clip.min -range { -100. 5000. 10. }  \
        #        -textvariable min_elv -text "Minimum Elevation"
	#SpinBox  .l1clip.range \
	#	-range { 1 100 } \
         #       -textvariable range_elv  -text "Vertical Range"
        ##checkbutton .l1clip.proc -text "Use this clipper to process new data" -variable proc_clip 
        Label .l1clip.05.varname -text "Input Variable:"
        ComboBox .l1clip.05.varlist  -values \
  	 $varlist \
	 -helptext "Select any one of the following variables" \
	 -editable 0 \
         -modifycmd { 
          global outvar varlist
          set curvar [lindex $varlist [.l1clip.05.varlist getvalue]]
	  set outvar $curvar
	  set curidx [.l1clip.05.varlist getvalue]
	  .l1wid.bf45.p.15 setvalue @$curidx
	  retrieve_plot_settings [expr ($curidx+1)]
         }

        set curvar [.l1wid.bf45.p.15 getvalue]
        .l1clip.05.varlist setvalue @$curvar
        checkbutton .l1clip.1.ymin -variable ymin \
		-command {
		    if {$ymin == 1} {
			set yrange 0
			.l1clip.1.min.sb configure -state normal
			.l1clip.1.min.lb configure -state normal
			.l1clip.1.min.sc configure -state normal
			.l1clip.3.range.sb configure -state disabled
			.l1clip.3.range.lb configure -state disabled
			.l1clip.3.range.sc configure -state disabled
		    }
		    if {$ymin == 0} {
			.l1clip.1.min.sb configure -state disabled
			.l1clip.1.min.lb configure -state disabled
			.l1clip.1.min.sc configure -state disabled
		    }
			
		}
	set ymin 1
        checkbutton .l1clip.2.ymax -variable ymax \
		-command {
		    if {$ymax == 1} {
			set yrange 0
			.l1clip.2.max.sb configure -state normal
			.l1clip.2.max.lb configure -state normal
			.l1clip.2.max.sc configure -state normal
			.l1clip.3.range.sb configure -state disabled
			.l1clip.3.range.lb configure -state disabled
			.l1clip.3.range.sc configure -state disabled
		    }
		    if {$ymax == 0} {
			.l1clip.2.max.sb configure -state disabled
			.l1clip.2.max.lb configure -state disabled
			.l1clip.2.max.sc configure -state disabled
		    }
 		}
	set ymax 1
        checkbutton .l1clip.3.yrange -variable yrange -state disabled \
		 -command {
			set yrange_elv 0
##		    if {$yrange == 1} {
##			set ymin 0
##			set ymax 0
##			.l1clip.3.range.sb configure -state normal
##			.l1clip.3.range.lb configure -state normal
##			.l1clip.3.range.sc configure -state normal
##			.l1clip.1.min.sb configure -state disabled
##			.l1clip.1.min.lb configure -state disabled
##			.l1clip.1.min.sc configure -state disabled
##			.l1clip.2.max.sb configure -state disabled
##			.l1clip.2.max.lb configure -state disabled
##			.l1clip.2.max.sc configure -state disabled
##		    }
##		    if {$yrange == 0} {
##			.l1clip.3.range.sb configure -state disabled
##			.l1clip.3.range.lb configure -state disabled
##			.l1clip.3.range.sc configure -state disabled
##		    }
		 }

        sst .l1clip.2.max   max_elv   "Maximum Elevation:"  { -100 5000.0 0.1  }
        sst .l1clip.1.min   min_elv   "Minimum Elevation:"  { -100 5000.0 0.1  }
        sst .l1clip.3.range   range_elv   "Vertical Range:"  { 0 300.0 0.1  }

	set max_elv $cmax
	set min_elv $cmin
	set range_elv $cdelta

        set curvar  [lindex $varlist [.l1clip.05.varlist getvalue]]
        LabelEntry .l1clip.35 -relief sunken -label "Output Variable:" -helptext "Define output variable" \
	-textvariable outvar -text "$curvar"

	Button .l1clip.4.ok -text "Clip Data" -width 5 -command {
	  
	  global outvar curvar
	    
          set ptype [.l1wid.bf4.1.p getvalue]
          set dtype [.l1wid.bf45.p.5 getvalue]
	  if {$ptype == 0} {
	      ##for surface topography
	      if {$ymin == 1 && $ymax == 1} {
		   exp_send "$outvar = $curvar\(where(($curvar.elevation >= $min_elv*100) & ($curvar.elevation <= $max_elv*100)));\r"
		   expect ">"
	      } else {
	     	if {$ymin == 1} {
		   exp_send "$outvar = $curvar\(where($curvar.elevation >= $min_elv*100));\r"
		   expect ">"
		}
	     	if {$ymax == 1} {
		   exp_send "$outvar = $curvar\(where($curvar.elevation <= $max_elv*100));\r"
		   expect ">"
		}
	      }
	      if {$yrange == 1} {
		   exp_send "sel_ptr = rcf($curvar.elevation,$range_elv*100,mode=2); $outvar = $curvar(*sel_ptr(1));\r" 
		   expect ">"
	      }
	  }
	  if {$ptype == 1} {
	      ##for bathymetry
	    	if {$dtype == 1} {
	      	  if {$ymin == 1 && $ymax == 1} {
		   exp_send "$outvar = $curvar\(where(($curvar.elevation+$curvar.depth >= $min_elv*100) & ($curvar.elevation+$curvar.depth <= $max_elv*100)));\r"
		   expect ">"
	          } else {
		   if {$ymin == 1} {
                     exp_send "$outvar = $curvar\(where(($curvar.elevation+$curvar.depth) >= $min_elv\*100));\r"
		     expect ">"
                   }
                   if {$ymax == 1} {
                     exp_send "$outvar = $curvar\(where(($curvar.elevation+$curvar.depth) <= $max_elv*100));\r"
		     expect ">"
                   }
		  }
                  if {$yrange == 1} {
                     exp_send "sel_ptr = rcf(($curvar.elevation+$curvar.depth),$range_elv*100,mode=2); $outvar = $curvar\(*sel_ptr(1));\r"
		     expect ">"
                  }
		}
		if {$dtype == 0} {
	      	  if {$ymin == 1 && $ymax == 1} {
		   exp_send "$outvar = $curvar\(where(($curvar.elevation >= $min_elv*100) & ($curvar.elevation <= $max_elv*100)));\r"
		   expect ">"
	          } else {
		   if {$ymin == 1} {
                     exp_send "$outvar = $curvar\(where($curvar.elevation >= $min_elv*100));\r"
		     expect ">"
                   }
                   if {$ymax == 1} {
                     exp_send "$outvar = $curvar\(where($curvar.elevation <= $max_elv*100));\r"
		     expect ">"
                   }
		  }
                   if {$yrange == 1} {
                     exp_send "sel_ptr = rcf($curvar.elevation,$range_elv*100,mode=2); $outvar = $curvar\(*sel_ptr(1));\r"
		     expect ">"
                   }
		}
		if {$dtype == 2} {
	      	  if {$ymin == 1 && $ymax == 1} {
		   exp_send "$outvar = $curvar\(where(($curvar.depth >= $min_elv*100) & ($curvar.depth <= $max_elv*100)));\r"
		   expect ">"
	          } else {
		   if {$ymin == 1} {
                     exp_send "$outvar = $curvar\(where($curvar.depth >= $min_elv*100));\r"
                   }
                   if {$ymax == 1} {
                     exp_send "$outvar = $curvar\(where($curvar.depth <= $max_elv*100));\r"
                   }
		  }
                   if {$yrange == 1} {
                     exp_send "sel_ptr = rcf($curvar.depth,$range_elv*100,mode=2); $outvar = $curvar\(*sel_ptr(1));\r"
                   }
		}

	  }
	  if {$ptype == 2} {
		##for vegetation
		if {$dtype == 0} {
	      	  if {$ymin == 1 && $ymax == 1} {
		   exp_send "$outvar = $curvar\(where(($curvar.elevation >= $min_elv*100) & ($curvar.elevation <= $max_elv*100)));\r"
		   expect ">"
	          } else {
		   if {$ymin == 1} {
                     exp_send "$outvar = $curvar(where\($curvar.elevation >= $min_elv*100));\r"
                   }
                   if {$ymax == 1} {
                     exp_send "$outvar = $curvar(where\($curvar.elevation <= $max_elv*100));\r"
                   }
		  }
                  if {$yrange == 1} {
                     exp_send "sel_ptr = rcf($curvar.elevation,$range_elv*100,mode=2); $outvar = $curvar\(*sel_ptr(1));\r"
                  }
		}
		if {$dtype == 3} {
	      	  if {$ymin == 1 && $ymax == 1} {
		   exp_send "$outvar = $curvar\(where(($curvar.lelv >= $min_elv*100) & ($curvar.lelv <= $max_elv*100)));\r"
		   expect ">"
	          } else {
		   if {$ymin == 1} {
                     exp_send "$outvar = $curvar\(where($curvar.lelv >= $min_elv*100));\r"
                   }
                   if {$ymax == 1} {
                     exp_send "$outvar = $curvar\(where($curvar.lelv <= $max_elv*100));\r"
                   }
		  }
                  if {$yrange == 1} {
                     exp_send "sel_ptr = rcf($curvar.lelv,$range_elv*100,mode=2); $outvar = $curvar\(*sel_ptr(1));\r"
                  }
		}
	  }
	    destroy .l1clip
          }
 
 	Button .l1clip.4.dismiss -text "Close" -width 5 -command {
	   destroy .l1clip
 	}

	pack .l1clip.05.varname .l1clip.05.varlist -side left -padx 5 
	pack .l1clip.1.ymin .l1clip.1.min -side left -padx 5 
	pack .l1clip.2.ymax .l1clip.2.max -side left -padx 5
	pack .l1clip.3.yrange .l1clip.3.range -side left -fill x
	
	pack .l1clip.4.ok .l1clip.4.dismiss -side left -padx 5
	pack .l1clip.05 .l1clip.1 .l1clip.2 .l1clip.3 .l1clip.35 .l1clip.4 -side top -pady 5	

	.l1clip.3.range.sb configure -state disabled
	.l1clip.3.range.lb configure -state disabled
	.l1clip.3.range.sc configure -state disabled 
	set range_elv 0
  }

#
# Button .l1wid.bf45.q.5 -text "Landscape:5" -command {
#        exp_send "window,5,style=\"landscape11x85.gs\"\r";
# }

Button .l1wid.bf45.q.44 -text "Overlay\nGrid" -command {
  exp_send "draw_grid, $win_no\r"
}

Button .l1wid.bf45.q.45 -text "Show\nGrid Name" -command {
  exp_send "show_grid_location, $win_no\r"
}

frame .l1wid.bf45.q.f46
Button .l1wid.bf45.q.f46.1 -text "QQ Grid" -command {
   exp_send "draw_qq_grid, $win_no\r"
} -font {Helvetica -8}

Button .l1wid.bf45.q.f46.2 -text "QQ Name" -command {
   exp_send "show_qq_grid_location, $win_no\r"
} -font {Helvetica -8}

##.l1wid.bf45.q.4 configure -state disabled


checkbutton .l1wid.bf45.q.5 -text "Set Plot Limits" -variable usecentroid 

frame  .l1wid.bf45.sc.1

ComboBox .l1wid.bf45.r.1 -text "Copy points using..." -width 16\
   	 -values { \
	 	Rubberband\ Box \
	  	Points\ in\ Polygon \
		Single\ Pixel\
		Select\ Cell\/Quad\/Tile \
		} \
	 -helptext "Copy points to \'workdata\' using any of the following methods:\n Rubberband Box\n Points in Polygon\n Single Pixel" -editable 0 -modifycmd {
   global varlist

# Deleted to reduce clicks required to work.  This should be changed to
# a message box that times out in 1 or 2 seconds on its own.
#   tk_messageBox  -icon info \
#   -message "Region Selected will be saved in variable \"workdata\"" \
#   -type ok -title "Message"

    set selr [.l1wid.bf45.r.1 getvalue]
    if {$selr == 0} {
        set var_no [.l1wid.bf45.p.15 getvalue]
        set var_type [lindex $varlist $var_no]
       	set selection [tk_messageBox  -icon info \
        -message "Drag a Rectangular Box in Window $win_no to define region." \
        -type okcancel -title "Message"]
        if {$selection == "ok"} {
          exp_send "workdata = sel_data_rgn($var_type, mode=2, win=$win_no)\r"
          expect ">"
        }
    }
    if {$selr == 1} {
        set selection  [tk_messageBox  -icon info \
        -message "Draw a Polygon in Window $win_no to define a region using a series of left mouse clicks.  To complete the polygon, middle mouse click OR <Ctrl> and left mouse click." \
        -type okcancel -title "Message" ]
       if {$selection == "ok"} { 
	exp_send "workdata = sel_data_rgn($var_type, mode=3, win=$win_no)\r"
        expect ">"
       }
    }
    if {$selr == 2} {

# Deleted to reduce clicks required to work. # Perhaps we need a general 
# message or status bar somehwere...
#      	tk_messageBox  -icon info \
#        -message "Select pixels with the following mouse controls: Left = View Waveform; Middle = Select recently viewed waveform; Right = Quit" \
#        -type ok -title "Message"
       exp_send "workdata = select_points($var_type, win=$win_no);\r"
       expect ">"
    }
    if {$selr == 3} {
       set selection  [tk_messageBox  -icon info \
        -message "Select a cell (250m by 250m) region by dragging a region in window $win_no within the required cell."\
        -type okcancel -title "Message" ]
       if {$selection == "ok"} { 
	exp_send "workdata = select_region($var_type, win=$win_no, plot=1);\r"
        expect ">"
       }
    }
   if {$selr == -1} {
	error "Please Define Region."
   }
   append_varlist workdata
} 

ComboBox .l1wid.bf45.r.7 -text " Filter tools..." -width 16\
   	 -values { \
		Keep \
	 	Remove \
		Replace \
	  	RCF \
		Re-Process \
		Datum-Convert \
		} \
	 -helptext "Choose any of the following tools:" -editable 0 -modifycmd {
             global varlist

    	     set self [.l1wid.bf45.r.7 getvalue]
             if {$self == 0} {
		keep_proc
             }
             if {$self == 1} {
		removing_proc
             }
             if {$self == 2} {
		replace_proc
             }
             if {$self == 3} {
    		rcf_region
             }
             if {$self == 4} {
             }
	     if {$self == 5} {
		datum_proc
	     }
             if {$self == -1} {
	        error "Please Define Region."
             }
          } 
proc removing_proc {} {
       global varlist curvar cmin cmax
       destroy .rem
       toplevel .rem
       frame .rem.05
       frame .rem.07 -relief raised -bd 1
       frame .rem.08 -relief raised -bd 1
       frame .rem.09
       wm title .rem "Remove Points Using..."
       Label .rem.05.varname -text "Input Variable:"
       ComboBox .rem.05.varlist  -values \
  	$varlist \
	-helptext "Select any one of the following variables" \
	-editable 0 \
        -modifycmd { 
         global varlist curvar
         set curvar [lindex $varlist [.rem.05.varlist getvalue]]
	 set curidx [.rem.05.varlist getvalue]
	 .l1wid.bf45.p.15 setvalue @$curidx
	 retrieve_plot_settings [expr ($curidx+1)]
       }

       set curidx [.l1wid.bf45.p.15 getvalue]
       set curvar [lindex $varlist $curidx]
       .rem.05.varlist setvalue @$curidx

       frame .rem.06 
       Label .rem.06.typetext -text "Data type:"
### IMPORTANT NOTE: Do not change the order of GEO and VEG__ for the values of the ComboBox below.
### A function parameter for the pipthresh function for this gui is dependent on the index number of the selection.
       ComboBox .rem.06.type -textvariable remove_type -editable 1 -width 12\
         -values {\
	          GEO\ or\ VEG__\
                  FS\
                 }
      if {[.l1wid.bf45.p.5 getvalue] == 0} {
	.rem.06.type setvalue @1
      } else {
	.rem.06.type setvalue @0
      }

       ComboBox .rem.1 -text "Remove points using..." -width 16\
   	 -values { \
	 	Rubberband\ Box \
	  	Points\ in\ Polygon \
		Single\ Pixel\
		PIP-Thresh\
		} \
	 -helptext "Remove points from \'workdata\' using any of the following methods:\n Rubberband Box\n Points in Polygon\n Single Pixel" -editable 0\
	 -modifycmd {
		set removemode [.rem.1 getvalue]
		if {$removemode == 3} {
		  pack forget .rem.2 .rem.3 .rem.4
		  pack .rem.08 .rem.07
		  pack .rem.07.a .rem.07.min .rem.07.minthresh -side left 
		  pack .rem.08.a .rem.08.max .rem.08.maxthresh -side left
		  pack .rem.09 .rem.09.a
                  pack .rem.2 .rem.3 -side left -padx 5 -pady 5
		  set min_thresh $cmin
		  set max_thresh $cmax
		} else {
		  pack forget .rem.2 .rem.3 .rem.4
		  pack forget .rem.07 .rem.08 .rem.09
		  pack .rem.2 .rem.3 .rem.4 -side left -padx 5 -pady 5
		}
	   } 
       Label .rem.07.a -text "Min. Threshold:"
       Label .rem.08.a -text "Max. Threshold:"
       Label .rem.09.a -text "WARNING: Cannot undo action." -justify center
       checkbutton .rem.07.min -variable min\
		-command {
		   if {$min == 1} {
			.rem.07.minthresh configure -state normal
		   }
		   if {$min == 0} {
			.rem.07.minthresh configure -state disabled
		   }
		}
       checkbutton .rem.08.max -variable max\
		-command {
		   if {$max == 1} {
			.rem.08.maxthresh configure -state normal
		   }
		   if {$max == 0} {
			.rem.08.maxthresh configure -state disabled
		   }
		}
       SpinBox .rem.07.minthresh -range {-100.0 5000.0 0.1} -textvariable min_thresh 
       SpinBox .rem.08.maxthresh -range {-100.0 5000.0 0.1} -textvariable max_thresh 
       set min 1
       set max 1
       .rem.07.min select
       .rem.08.max select
	set min_thresh $cmin
	set max_thresh $cmax

       Button .rem.2 -width 8 -text "Go" \
       -command {
         global varlist outvar selr curvar

         set selr [.rem.1 getvalue]
         if {$selr == 0} {
            set var_no [.l1wid.bf45.p.15 getvalue]
            set var_type [lindex $varlist $var_no]
       	    set selection [tk_messageBox  -icon info \
            -message "Drag a Rectangular Box in Window $win_no to define region." \
            -type okcancel -title "Message"]
            if {$selection == "ok"} {
               exp_send "croppeddata=\[\];$curvar = sel_data_rgn($curvar, mode=2, win=$win_no, exclude=1)\r"
               expect ">"
            }
         }
         if {$selr == 1} {
            set selection  [tk_messageBox  -icon info \
            -message "Draw a Polygon in Window $win_no to define a region using a series of left mouse clicks.  To complete the polygon, middle mouse click OR <Ctrl> and left mouse click." \
            -type okcancel -title "Message" ]
            if {$selection == "ok"} { 
	    exp_send "croppeddata=\[\];$curvar = sel_data_rgn($curvar, mode=3, win=$win_no, exclude=1)\r"
            expect ">"
            }
         }
         if {$selr == 2} {
       	    set selection [tk_messageBox  -icon info \
            -message "Select points to remove from window $win_no" \
            -type okcancel -title "Message"]
           if {$selection == "ok"} {
             exp_send "croppeddata=\[\];$curvar = select_points($curvar, win=$win_no, exclude=1);\r"
             expect ">"
	   }
         }
         if {$selr == 3} {
		if {[.rem.06.type getvalue] == 1} {
 			set val [.rem.06.type getvalue] 
		} else {
			set val " "
		} 
		if { $min == 0 && $max == 0 } {
		   tk_messageBox -icon warning -message "You have not set any threshold limits!" -type ok -title "ERROR!"
		} elseif { $min == 0 } {
		   exp_send "croppeddata=\[\];$curvar = pipthresh($curvar, maxthresh=$max_thresh, mode=$val);\r"
		} elseif { $max == 0 } {
		   exp_send "croppeddata=\[\];$curvar = pipthresh($curvar, minthresh=$min_thresh, mode=$val);\r"
		} else {
		   exp_send "croppeddata=\[\];$curvar = pipthresh($curvar, minthresh=$min_thresh, maxthresh=$max_thresh, mode=$val);\r"
		}
	 }
         if {$selr == -1} {
	   error "Please Define Region."
         } else {
           append_varlist $curvar
#	   destroy .rem
         }
      } 
      Button .rem.3 -width 8 -text "Dismiss" -command {
	 destroy .rem
      }
      Button .rem.4 -width 8 -text "Undo Last\nRemove" -command {
	 exp_send "if (is_array(croppeddata)) $curvar = grow($curvar,croppeddata);\r"
	 expect ">"
      }

     
      pack .rem.05.varname .rem.05.varlist -side left -padx 5
      pack .rem.06.typetext .rem.06.type -side left
      pack .rem.05 .rem.06 .rem.1 -pady 8
      pack .rem.08 .rem.07 .rem.09
      pack .rem.2 .rem.3 .rem.4 -side left -padx 5 -pady 5
   }


proc datum_proc {} {
       global varlist curvar
       destroy .con
       toplevel .con

       wm title .con "Convert data from w84 to n88..."

       frame .con.05

       Label .con.05.varname -text "Input Variable:"
       ComboBox .con.05.varlist  -values \
        $varlist \
        -helptext "Select any one of the following variables" \
        -editable 0 \
        -modifycmd {
         global varlist curvar
         set curvar [lindex $varlist [.con.05.varlist getvalue]]
         set curidx [.con.05.varlist getvalue]
         .l1wid.bf45.p.15 setvalue @$curidx
         retrieve_plot_settings [expr ($curidx+1)]
       }

       set curidx [.l1wid.bf45.p.15 getvalue]
       set curvar [lindex $varlist $curidx]

       .con.05.varlist setvalue @$curidx

	Label .con.02 -text "The converted variable is named n88_(currentvariablename)"
	Button .con.1 -width 8 -text "Go" \
        -command {
		
	       set convar "n88_$curvar" 
               exp_send "$convar = data_datum_converter($curvar);\r"
          	expect ">" 

        }

      pack .con.05.varname .con.05.varlist -side left -padx 5
      pack .con.05 .con.02 .con.1  -side top -pady 10

      append_varlist "n88_$curvar"

}

proc keep_proc {} {
       global varlist curvar
       destroy .sel
       toplevel .sel
       wm title .sel "Keep Points Using..."
       frame .sel.05

       Label .sel.05.varname -text "Input Variable:"
       ComboBox .sel.05.varlist  -values \
  	$varlist \
	-helptext "Select any one of the following variables" \
	-editable 0 \
        -modifycmd { 
         global outvar varlist curvar
         set curvar [lindex $varlist [.sel.05.varlist getvalue]]
	 set curidx [.sel.05.varlist getvalue]
	 .l1wid.bf45.p.15 setvalue @$curidx
	 retrieve_plot_settings [expr ($curidx+1)]
       }

       set curidx [.l1wid.bf45.p.15 getvalue]
       set curvar [lindex $varlist $curidx]
       
       .sel.05.varlist setvalue @$curidx

       ComboBox .sel.1 -text "Keep points using..." -width 16\
   	 -values { \
	 	Rubberband\ Box \
	  	Points\ in\ Polygon \
		Single\ Pixel\
		} \
	 -modifycmd { 
	        global sels keep_var
		set sels [.sel.1 getvalue]
	        if {$sels == 2} {
      		    set grow_keep 1
		    set keep_var "finaldata"
		} else {
		    set keep_var $curvar
		}
	 } \
	 -helptext "Keep points from \'workdata\' using any of the following methods:\n Rubberband Box\n Points in Polygon\n Single Pixel" -editable 0 

      checkbutton .sel.grow -text "Grow output variable" -variable grow_keep 
      LabelEntry .sel.15 -relief sunken -label "Output Variable:" -helptext "Define output variable" \
	-textvariable keep_var -text "workdata"

       Button .sel.2 -width 8 -text "Go" \
       -command {
         global varlist outvar sels keep_var curvar

         set sels [.sel.1 getvalue]
         if {$sels == 0} {
            set var_no [.l1wid.bf45.p.15 getvalue]
            set var_type [lindex $varlist $var_no]
       	    set selection [tk_messageBox  -icon info \
            -message "Drag a Rectangular Box in Window $win_no to define region." \
            -type okcancel -title "Message"]
            if {$selection == "ok"} {
	     if {$grow_keep == 0} {
               exp_send "$keep_var = sel_data_rgn($curvar, mode=2, win=$win_no)\r"
               expect ">"
	     } else {
               exp_send "$keep_var = grow($keep_var, sel_data_rgn($curvar, mode=2, win=$win_no));\r"
               expect ">"
	     }
	      
            }
         }
         if {$sels == 1} {
            set selection  [tk_messageBox  -icon info \
            -message "Draw a Polygon in Window $win_no to define a region using a series of left mouse clicks.  To complete the polygon, middle mouse click OR <Ctrl> and left mouse click." \
            -type okcancel -title "Message" ]
            if {$selection == "ok"} { 
	     if {$grow_keep == 0} {
	       exp_send "$keep_var = sel_data_rgn($curvar, mode=3, win=$win_no)\r"
               expect ">"
	     } else {
	       exp_send "$keep_var = grow($keep_var, sel_data_rgn($curvar, mode=3, win=$win_no));\r"
               expect ">"
	    }
	       
           }
       }
       if {$sels == 2} {
       	    set selection [tk_messageBox  -icon info \
            -message "Select points to keep from window $win_no" \
            -type okcancel -title "Message"]
           if {$selection == "ok"} {
	    if {$grow_keep == 0} {
             exp_send "$keep_var = select_points($curvar, win=$win_no);\r"
             expect ">"
	    } else {
             exp_send "$keep_var = grow($keep_var, select_points($curvar, win=$win_no));\r"
             expect ">"
	    }
	     
	   }
         }
         if {$sels == -1} {
	   error "Please Define Region."
         } else {
           append_varlist $curvar
#	   destroy .sel
         }
      } 
      Button .sel.3 -width 8 -text "Dismiss" -command {
	 destroy .sel
      }

     
      pack .sel.05.varname .sel.05.varlist -side left -padx 5
      pack .sel.05 .sel.1 .sel.grow .sel.15 -side top -pady 10
      pack .sel.2 .sel.3 -side left -padx 5 -pady 5
   }

proc replace_proc {} {
       global varlist curvar croppeddata have_replaced have_undone rcf_buf_rgn
       set have_undone 0
       set have_replaced 0
       destroy .rep
       toplevel .rep
       wm title .rep "Replace Points Using..."
       frame .rep.05
       frame .rep.005
       frame .rep.15

       set sameinput 0
       Label .rep.05.varname -text "Input Variable:"
       ComboBox .rep.05.varlist  -values \
  	$varlist \
	-helptext "Select any one of the following variables" \
	-editable 0 \
        -modifycmd { 
         global outvar varlist curvar
         set curvar [lindex $varlist [.rep.05.varlist getvalue]]
	 set curidx [.rep.05.varlist getvalue]
	 .l1wid.bf45.p.15 setvalue @$curidx
       }

       set curidx [.l1wid.bf45.p.15 getvalue]
       set curvar [lindex $varlist $curidx]
       .rep.05.varlist setvalue @$curidx

       Label .rep.005.varname -text "Original Data Variable:"
       ComboBox .rep.005.varlist  -values \
  	$varlist \
	-helptext "This variable should contain the original data that will be refiltered" \
	-editable 0 \
        -modifycmd { 
         global outvar varlist origvar
         set origvar [lindex $varlist [.rep.005.varlist getvalue]]
	 set origidx [.rep.005.varlist getvalue]
	 .l1wid.bf45.p.15 setvalue @$origidx
       }
       set origidx [.l1wid.bf45.p.15 getvalue]
       set origvar [lindex $varlist $curidx]
       .rep.005.varlist setvalue @$origidx

       #Note: In code below, the yorick variables "croppeddata" and "workdata" are created through sel_data_rgn
       #      croppeddata = (selected filtered points);    workdata = (selected original data points);
       ComboBox .rep.1 -text "Select points to replace using..." -width 28 \
   	 -values { \
	 	Rubberband\ Box \
	  	Points\ in\ Polygon \
		Window\ Limits \
		} \
	 -helptext "Select points to replace using any of the following methods:\n Rubberband Box\n Points in Polygon\n Window Limits.\nSelected points from the original data array will be written to variable \"workdata\"" -editable 0 \
	-modifycmd {
	   set curidx [.rep.05.varlist getvalue]
           set curvar [lindex $varlist $curidx]
    	   set defr [.rep.1 getvalue]
           set sel_points buf_points
	   set buffered_var bufferdata
	   global rcf_buf_rgn
	   if {$rcf_buf_rgn > 0} {
		if {$defr == 0} {
       		   set result [tk_messageBox  -icon info \
        	   -message "Drag a Rectangular Box in Window $win_no to define region." \
        	   -type okcancel -title "Message"]
		   if {$result == "ok"} {
		      exp_send "$keep_var = $curvar;\r"
		      exp_send "$sel_points = mouse(1,1,\"Hold the left mouse button down, select a region:\");"
		      expect ">"
		      exp_send "temp_rgn = add_buffer_rgn($sel_points,$rcf_buf_rgn,mode=1);\r"
		      expect ">"
		      exp_send "workdata = sel_data_rgn($origvar, mode=4, win=$win_no, rgn=temp_rgn);\r"
		      expect ">"
		   }
		} elseif {$defr == 1} {
		   set result [tk_messageBox -icon info \
		   -message "Draw a Polygon in Window $win_no to define a region using a series of left mouse clicks.  To complete the polygon, middle mouse click OR <Ctrl> and left mouse click." \
                   -type okcancel -title "Message"]
                   if {$result == "ok"} {
		      exp_send "$keep_var = $curvar;\r"
		      #For eval purposes, success stores if getPoly_add_buffer command was successful
		      #The yorick variables buf_points, temp_rgn, and workdata are made
		      exp_send "success = getPoly_add_buffer($rcf_buf_rgn, origdata=$origvar, windw=$win_no);\r"
		      expect ">"
		   }
		} elseif {$defr == 2} {
		   exp_send "$keep_var = $curvar;\r"
		   exp_send "window,$win_no;$sel_points=limits()(1:4);temp_rgn = add_buffer_rgn($sel_points,$rcf_buf_rgn,mode=3);\r"
		   expect ">"
		   exp_send "workdata = sel_data_rgn($origvar, mode=4, win=$win_no, rgn=temp_rgn);\r"
		   expect ">"
		}
		set have_replaced 0
                set have_undone 0
	   } else {
    	   	if {$defr == 0} {
       		   set result [tk_messageBox  -icon info \
        	   -message "Drag a Rectangular Box in Window $win_no to define region." \
        	   -type okcancel -title "Message"]
        	   if {$result == "ok"} {
	              exp_send "$keep_var = sel_data_rgn($curvar, mode=2, win=$win_no, exclude=1, make_workdata=1, origdata=$origvar);\r"
         	      expect ">"
                      set have_replaced 0
                      set have_undone 0
        	   }
    	   	}
    	   	if {$defr == 1} {
       	           set result [tk_messageBox  -icon info \
        	   -message "Draw a Polygon in Window $win_no to define a region using a series of left mouse clicks.  To complete the polygon, middle mouse click OR <Ctrl> and left mouse click." \
        	   -type okcancel -title "Message"]
        	   if {$result == "ok"} {
	              exp_send "$keep_var = sel_data_rgn($curvar, mode=3, win=$win_no, exclude=1, make_workdata=1, origdata=$origvar);\r"
         	      expect ">"
                      set have_replaced 0
                      set have_undone 0
        	   }
    	   	}
    	   	if {$defr == 2} {
		   exp_send "$keep_var = sel_data_rgn($curvar, mode=1, win=$win_no, exclude=1, make_workdata=1, origdata=$origvar);\r"
                   set have_replaced 0
                   set have_undone 0
		}
	   #end if/else rcf_buf_rgn
	   }
	}

      Button .rep.type -text "Filter selected points" -width 15 -bd 5 \
	-command {
	     global curvar have_replaced have_undone croppeddata outvar rcf_buf_rgn sel_points
             if {$have_undone == 1} {
		if {$rcf_buf_rgn > 0} {
		   exp_send "workdata = tempdata;\r"
		} else {
                   exp_send "$keep_var = $keep_var (1: - numberof(croppeddata));\r"
		}
             } elseif {$have_replaced == 1} {
		if {$rcf_buf_rgn > 0} {
		   exp_send "workdata = tempdata;\r"
		} else {
		   exp_send "$keep_var = $keep_var (1: - numberof($outvar));\r"
		}
             }
	     rcf_region
    	     .rcf.2.varlist setvalue @4
	     set curvar [.rcf.2.varlist getvalue]
	     set outvar rcf_workdata
             set have_replaced 0
             set have_undone 0
	}


      LabelEntry .rep.15.1 -relief sunken -label "Output Variable:" -helptext "Define output variable" \
	-textvariable keep_var -text "finaldata"
      checkbutton .rep.15.2 -text "Same as input variable" -variable sameinput \
	-command { 
		if {$sameinput == 1} {
		  set keep_var $curvar
	        }
  	}
      LabelEntry .rep.15.3 -relief sunken -label "Buffer Region (m):" -width 5 -helptext "Define the amount of buffer used in filtering for the selected points" \
        -textvariable rcf_buf_rgn -text "0"

      Button .rep.15.4 -text "Click \[HERE\] for info" -bd 0 \
        -command {
           tk_messageBox -icon info \
            -message "Points in the buffer region will be used for filtering, but will not be replaced into the output array." \
            -type ok -title "Use a buffer region help"
      }
		  
       # Significant change made by Jeremy Bracone 4/4/05
       # Do No Replace as been fixed and now acts as an undo while Replace acts as a redo
       # Replace will put filtered data into output array, "Do Not Replace" will put original data into output array
       # If a replace or "Do Not Replace" has already been done, hitting replace or Do not will have no effect
       # If replace or "Do Not Replace" has already been done, hitting one will undo the action of the other and perform
       #            the expected operation; i.e. Replace was done, now hit Do Not Replace and it will take out the data
       #            inserted in the Replace and put in the original data.  Same is true for opposite situation.
       Button .rep.2 -width 8 -text "Replace..." -bd 5 \
       -command {
         global varlist outvar reps keep_var curvar origvar have_replaced have_undone croppeddata
	 set selection [tk_messageBox -icon question \
	    -message "Append array $outvar to $keep_var?" \
            -type yesno -title "Warning" ]
         if {$selection == "yes" && $have_replaced == 0 && $have_undone == 0} {
	   if {$rcf_buf_rgn > 0} {
              #have to save workdata since sel_data_rgn with exclude set to 1 will over-write it
	      set $outvar rcf_workdata
	      exp_send "tempdata = workdata;\r"
              exp_send "$keep_var = sel_data_rgn($keep_var,mode=4,rgn=$sel_points,win=$win_no,exclude=1,make_workdata=1,origdata=$origvar);\r"
              expect ">"
	      # This is kind of confusing, but $outvar = rcf_workdata (love this confuciated variable hiding)
	      exp_send "workdata=tempdata;$outvar = sel_data_rgn($outvar, mode=4, win=$win_no, rgn=$sel_points);\r"
           }
           exp_send "$keep_var = grow($keep_var,$outvar);\r"
         }
         if {$selection == "yes" && $have_replaced == 0 && $have_undone == 1} {
           exp_send "$keep_var = $keep_var (1: - numberof(croppeddata));\r"
           exp_send "$keep_var = grow($keep_var, $outvar);\r"
           set have_undone 0
         }
         expect ">"
         set have_replaced 1
       }
       Button .rep.4 -width 10 -text "Do Not Replace..." -bd 5 \
       -command {
         global varlist outvar reps keep_var curvar origvar
	 set selection [tk_messageBox -icon question \
	    -message "Append ORIGINAL cropped array croppeddata to $keep_var?" \
            -type yesno -title "Warning" ]
           if {$selection == "yes"} {
              if {$have_replaced == 0 && $have_undone == 0} {
                 if {$rcf_buf_rgn > 0} {
               #have to save workdata since sel_data_rgn with exclude set to 1 will over-write it
		    set $outvar rcf_workdata
                    exp_send "tempdata = workdata;\r"
                    exp_send "$keep_var = sel_data_rgn($keep_var,mode=4,rgn=$sel_points,win=$win_no,exclude=1,make_workdata=1,origdata=$origvar);\r"
                    expect ">"
                    exp_send "workdata=tempdata;$outvar = sel_data_rgn($outvar, mode=4, win=$win_no, rgn=$sel_points);\r"
                 }
              exp_send "$keep_var = grow($keep_var,croppeddata);\r"
           }
           if {$have_replaced == 1 && $have_undone == 0} {
              exp_send "$keep_var = $keep_var (1: - numberof($outvar));\r"
              exp_send "$keep_var = grow($keep_var, croppeddata);\r"
           }
           expect ">"
           set have_undone 1
           set have_replaced 0
         }
       }
      Button .rep.3 -width 8 -text "Close" -command {
	 destroy .rep
      }

      Button .rep.5 -width 3 -text "Help" -command {
         tk_messageBox -icon info \
            -message "Hitting replace adds new filtered array to the output array which Do Not Replace adds the original data back in." \
            -type ok -title "Info 1 of 3"
         tk_messageBox -icon info \
            -message "Once a replace or Do Not Replace has been done, the effects of one can be replaced by the other." \
            -type ok -title "Info 2 of 3"
         tk_messageBox -icon info \
            -message "Example: Hit replace and insert filtered data, then hit DO NOT REPLACE, and inserted data is taken out and original put in." \
            -type ok -title "Info 3 of 3"
      }
     
      pack .rep.05.varname .rep.05.varlist -side left -padx 5
      pack .rep.005.varname .rep.005.varlist -side left -padx 5
      pack .rep.15.1 .rep.15.2 -side top -pady 3 
      pack .rep.15.4 .rep.15.3 -side right 
      pack .rep.05 .rep.005 .rep.15 .rep.1 .rep.type  -side top -pady 10
      pack .rep.2 .rep.4 .rep.3 -side left -padx 5 -pady 5
      pack .rep.5 -side left -pady 5
}
Button .l1wid.bf45.r.5 -text "Append2Tile" -command {
    set curvar  [lindex $varlist [.l1wid.bf45.p.15 getvalue]]
    set selection  [tk_messageBox  -icon question \
      -message "Append \'$curvar\' array to final data array?" \
            -type yesno -title "Warning" ]
    if {$selection == "yes"} {
      exp_send "finaldata = grow(finaldata,$curvar);\r"
      expect ">" 
    }
  }
Button .l1wid.bf45.r.6 -text "Save Tile" -command {
    global tilefname initialpath
    
    if {[info exists initialpath] == 0} {set initialpath "~/"}
    exp_send "if (is_void(curzone)) curzone = 17; tilefname = set_tile_filename(win=$win_no);\r"
    expect ">"
    #puts "$tilefname\n"
    if {[info exists tilefname] == 0} {
	set tilefname ""
    }
    set ofname [tk_getSaveFile -initialdir $initialpath \
		-defaultextension "*.pbd" \
		-initialfile $tilefname \
	       ]
    if {$ofname != ""} {
        exp_send "$tilename = ifinaldata; vname=tilename; save, createb(\"$ofname\"), vname, $tilename;\r"
	expect ">"
    }
  }


## This procedure builds a widget composed of a
## Label, a Spinbox, and a scale so one can enter 
## values by direct entry, the spin clicks, or 
## the scale.
proc sst  { w var lbl rg } {
  frame $w
  SpinBox $w.sb -textvariable $var \
	-range $rg \
	-width 6
  scale $w.sc -showvalue 0 -orient horizontal  \
	-variable $var \
	-from [ lindex $rg 0 ] \
	-to   [ lindex $rg 1 ] \
	-resolution [ lindex $rg 2 ]
  label $w.lb -text $lbl
  pack $w.lb $w.sb $w.sc -side left -fill x -expand 1
  return $w
}

proc ud { a b c } {
global cmax cmin cdelta min_thresh max_thresh
  switch $a {
   cmax   { set cdelta [ expr $cmax - $cmin ];  }
   cmin   { set cdelta [ expr $cmax - $cmin ];  }
   #cmin   { set cmax   [ expr $cmin + $cdelta ]; } 
   #cdelta { set cmax   [ expr $cmin + $cdelta ]; }
  }
  if { [ winfo exists .rem ] } {
	set min_thresh $cmin
	set max_thresh $cmax
  }
}

#trace vdelete cdelta w ud 
trace vdelete cmin w ud 
trace vdelete cmax w ud 

#trace variable cdelta w ud
trace variable cmin   w ud
trace variable cmax   w ud

#trace variable tilefname w ud

 sst .l1wid.bf45.sc.1.cmax   cmax   "Cmax:"	  { -50 5000.0 0.1  }
 sst .l1wid.bf45.sc.1.cmin   cmin   "Cmin:"	  { -100 5000.0 0.1  }
 sst .l1wid.bf45.sc.1.cdelta cdelta "Cdelta:"  { 0.0  2000.0 0.1 }
 grid .l1wid.bf45.sc.1.cmax   -in .l1wid.bf45.sc.1 -column 0 -row 0 -sticky "e"
 grid .l1wid.bf45.sc.1.cdelta -in .l1wid.bf45.sc.1 -column 0 -row 1 -sticky "e"
 grid .l1wid.bf45.sc.1.cmin   -in .l1wid.bf45.sc.1 -column 0 -row 2 -sticky "e"

# pack .l1wid.bf45.sc.1.cmax .l1wid.bf45.sc.1.cdelta .l1wid.bf45.sc.1.cmin -side top

  .l1wid.bf45.sc.1.cdelta.sc configure -state disabled
  .l1wid.bf45.sc.1.cdelta.sb configure -state disabled

LabelFrame  .l1wid.bf45.sc.f -relief sunken -borderwidth 3 -text "Marker:"
  SpinBox .l1wid.bf45.sc.f.msize \
        -range {0.1 10.0 0.1}  \
        -textvariable msize \
	-helptext "Enter Marker Size (msize)" \
	-width 5

  SpinBox .l1wid.bf45.sc.f.marker \
        -range {0 9 1}  \
        -textvariable markerv \
	-helptext "Enter Marker Type (See help, marker for more details)" \
 	-width 5

frame .l1wid.bf45.sc.g 
LabelFrame .l1wid.bf45.sc.g.sk -relief groove -borderwidth 3 -text "Skip:"
  SpinBox .l1wid.bf45.sc.g.sk.skip \
	-range {1 1000 1} \
	-textvariable skip \
	-helptext "Enter plot points to skip" \
	-width 5

checkbutton .l1wid.bf45.sc.g.fma -text "Auto Fma" -variable l1pro_fma 

Button .l1wid.bf45.sc.pl -text "Plot" -width 6 -height 2 -bd 5 -command {
 plot_fltlines 0
}
 pack \
	.l1wid.bf45.sc.f.msize \
	.l1wid.bf45.sc.f.marker \
	 -side top
 pack .l1wid.bf45.sc.g.sk.skip
 pack \
	.l1wid.bf45.sc.g.fma \
	.l1wid.bf45.sc.g.sk \
	-side top -pady 5 





##### Button .l1wid.bf5.3 -text "Write Ascii Data File" -width 20 


 Button .l1wid.bf4.2.proc -text "Process Now" -width 20 -bd 5\
		-command \
     {
  	   global list lrnindx
           set list {}
           set lrnindx {}
	   exp_send "utm = $utm\n"
	   set ptype [.l1wid.bf4.1.p getvalue]
           set defr [.l1wid.bf4.1.d getvalue]
	   exp_send "ptype = $ptype\n\r"
	   if {$defr == 3} {
	     exp_send "q = gga_win_sel(2, win=6, llarr=\[$mnlon, $mxlon, $mnlat, $mxlat\]);\r"
	   }
          #exp_send "make_bathy, opath=\"$opath\", ofname=\"$ofname\",\
          #    ext_bad_att=$xba, ext_bad_depth=$xbd, latutm = 1, llarr=\[$mnlon,\
          #    $mxlon, $mnlat, $mxlat\];\r"
	 if {$ptype == 0} {
	    exp_send "fs_all = make_fs(latutm=1, q=q, ext_bad_att=1, usecentroid=$usecentroid);\r"
	    expect ">"
	    .l1wid.bf45.p.15 setvalue @0
	 }
	 if {$ptype == 1} {
           exp_send "depth_all = make_bathy(latutm = 1, q = q, ext_bad_depth=1, ext_bad_att=1, avg_surf=$avg_surf);\r"
	   expect ">"
	   .l1wid.bf45.p.15 setvalue @1
	 }
	 if {$ptype == 2} {
	    exp_send "veg_all = make_veg(latutm=1, q=q, ext_bad_att=1, ext_bad_veg=1, use_centroid=$usecentroid);\r"
	    expect ">"
	   .l1wid.bf45.p.15 setvalue @2
	 }
	 if {$ptype == 3} {
	    exp_send "cveg_all = make_veg(latutm=1, q=q, use_peak=$usecentroid, multi_peaks=1);\r"
	    expect ">"
	   .l1wid.bf45.p.15 setvalue @3
 	 } 
         if { $ptype == 4 }  {
           exp_send "process_for_dws,q\r"
	   expect ">"
         }
              
    }


#pack  .l1wid.bf2.utm.1 .l1wid.bf2.utm.2 -side left 
#pack .l1wid.bf2.op  .l1wid.bf2.of .l1wid.bf2.utm -side top -pady 8
#pack .l1wid.bf2.utm -side top -pady 8
#pack .l1wid.bf3.lon.but.1 .l1wid.bf3.lon.but.2 -side top -padx 4
#pack .l1wid.bf3.lon.mn .l1wid.bf3.lon.mx -side left -padx 4
#pack .l1wid.bf3.lat1 .l1wid.bf3.lon .l1wid.bf3.lat2 -side top -pady 5
#pack  .l1wid.bf4.1.cb .l1wid.bf4.1.xba .l1wid.bf4.1.xbd .l1wid.bf4.1.xbv -side top -padx 20 -pady 5
#pack  .l1wid.bf4.1 -side top -padx 20 -pady 5
pack \
  .l1wid.bf4.1.d \
  .l1wid.bf4.1.p \
  .l1wid.bf4.1.m \
  .l1wid.bf4.1.lw \
  .l1wid.bf4.1.sw \
  -side left \
  -padx 5

#pack  .l1wid.bf4.2.cll .l1wid.bf4.2.cen -side left -padx 3
pack  .l1wid.bf4.2.cen .l1wid.bf4.2.surf .l1wid.bf4.2.proc -side left -padx 10
pack .l1wid.bf4.1 .l1wid.bf4.2 -side top -pady 10
####pack .l1wid.bf5.1  -side right -padx 35 

pack \
	.l1wid.bf1 \
	.l1wid.bf2 \
	.l1wid.bf3 \
	.l1wid.bf4 \
	-side top -expand 1 -fill both

pack .l1wid.bf45.sc.1  -side left  -padx 3
#<<<<<<< l1pro.ytk
#pack .l1wid.bf45.sc.f  .l1wid.bf45.sc.sk -side left -padx 5
#pack .l1wid.bf45.q.1 .l1wid.bf45.q.2  .l1wid.bf45.q.3 .l1wid.bf45.q.4 \
#       .l1wid.bf45.q.5 -side left
#pack 	.l1wid.bf45.p.fma \
#	.l1wid.bf45.p.1 \
#=======
pack .l1wid.bf45.sc.f .l1wid.bf45.sc.g .l1wid.bf45.sc.pl -side left -padx 5

pack \
	.l1wid.bf45.r.1 \
	.l1wid.bf45.r.7 \
	.l1wid.bf45.r.5 \
	.l1wid.bf45.r.6 \
	-side left

pack \
   .l1wid.bf45.q.f46.1 \
   .l1wid.bf45.q.f46.2 \
   -side top

pack \
	.l1wid.bf45.q.1 \
	.l1wid.bf45.q.2  \
	.l1wid.bf45.q.3 \
	.l1wid.bf45.q.4  \
	.l1wid.bf45.q.44 \
	.l1wid.bf45.q.45 \
   .l1wid.bf45.q.f46 \
	-side left 

##	.l1wid.bf45.p.fma 
##	.l1wid.bf45.p.1 
pack \
	.l1wid.bf45.p.14 \
	.l1wid.bf45.p.15 \
	.l1wid.bf45.p.25 \
	.l1wid.bf45.p.5 \
	.l1wid.bf45.p.2 \
	.l1wid.bf45.p.3 \
	-side left -fill x  -padx 2

pack \
	.l1wid.bf45.p \
	.l1wid.bf45.sc \
	.l1wid.bf45.q \
	.l1wid.bf45.r \
	-side top -fill x -expand 1

pack \
	.l1wid.bf5 \
	.l1wid.bf45 \
	-side top -pady 3 -fill x


proc send_latlon_to_l1pro {minlon maxlon minlat maxlat utm} {
   global mnlon mxlon mnlat mxlat utm
   # .l1widc.utm.1 setvalue @$utm
   set mnlon $minlon
   set mxlon $maxlon
   set mnlat $minlat
   set mxlat $maxlat
}


proc send_rnarr_to_l1pro {bstart bstop brnindx} {
   global start stop list lrnindx
   set start $bstart
   set stop $bstop
   set rnindx $brnindx
   set list1 [concat $start $stop]
   if {[llength $list] == 0} {
    set list $list1 
    set lrnindx $rnindx
   } else {
    set list [concat $list $list1 ]
    set lrnindx [concat $lrnindx $rnindx]
   }
}



proc plot_fltlines {sel} {
  
 global l1pro_fma win_no cmin cmax cdelta msize markerv varlist skip plot_dpi setll \
	changed_dpi
     #fill in later using what to plot
     set fs 0
     set ba 0
     set de 0
     set lelv 0
     set fint 0
     set lint 0
     set cht 0
     set disp_type [.l1wid.bf45.p.5 getvalue]
     set var_no [.l1wid.bf45.p.15 getvalue]
     set var_type [lindex $varlist $var_no]
     if {$disp_type == -1} {
       	tk_messageBox  -icon warning \
        -message "You need to specify the type of data to display!" \
        -type ok
     }
     if {$disp_type == 0} { set fs  1}
     if {$disp_type == 1} { set ba  1}
     if {$disp_type == 2} { set de  1}
     if {$disp_type == 3} { set lelv  1}
     if {$disp_type == 4} { set fint 1}
     if {$disp_type == 5} { set lint 1}
     if {$disp_type == 6} { set cht 1}
     set ptype [.l1wid.bf4.1.p getvalue]
     if {$ptype == -1} {
       	tk_messageBox  -icon warning \
        -message "You need to specify the type of processed data i.e. topo, bathy or veg!" \
        -type ok
     } else {
         if { $l1pro_fma } {
           
          if {$changed_dpi == 1} {
           switch  $plot_dpi  {
  	   "75" {
	      exp_send "winkill, $win_no; window,$win_no,dpi=$plot_dpi,width=450, height=450, style=\"work.gs\"; fma;limits, square=1;window, $win_no, width=0, height=0;\r";
	    }
  	   "100" {
	      exp_send "winkill, $win_no; window,$win_no,dpi=$plot_dpi,width=600, height=600, style=\"work.gs\"; fma; limits, square=1;window, $win_no, width=0, height=0;\r"
	    }
	   "1100" {
	      exp_send "winkill, $win_no; window, $win_no, dpi=100, width=1100, height=850, style=\"landscape11x85.gs\";fma; limits, square=1;window, $win_no, width=0, height=0;\r"
              expect ">"
	    }
           }
	   set changed_dpi 0
	  } else {
	      exp_send "window, $win_no; fma;\r";
              expect ">"
	  }
	   
	 }
	 if {$setll} {
	      exp_send "limits, _ytk_ll(1), _ytk_ll(2), _ytk_ll(3), _ytk_ll(4);\r"
              expect ">"
	 }
     }

     # set cmax [ expr $cmin + $cdelta ]
     ycbar;		;# Set the color bar values in yorick
     if {$ptype == 0} {
       set cmax1 [expr $cmax*100.]
       set cmin1 [expr $cmin*100.]
       if {$disp_type == 0} {
         if {$sel == 0} {
	   # using display_veg instead of display since it plots faster and works with the skip keyword.
           exp_send "window, $win_no; display_veg, $var_type, win=$win_no, cmin=$cmin, cmax = $cmax, size = $msize, edt=1, felv = $fs, lelv=$lelv, fint=$fint, lint=$lint, cht = $cht, marker=$markerv, skip=$skip;\r"
           #exp_send "window, $win_no; display, $var_type, win=$win_no, cmin=$cmin1, cmax = $cmax1, size = $msize, marker=$markerv, edt=1;\r"
         } else {
           exp_send "window, $win_no; display, fs_some, win=$win_no, cmin=$cmin1, cmax = $cmax1, size = $msize, marker=$markerv, edt=1;\r"
         }
         expect ">"
       } elseif { $disp_type == 4 } {
         if {$sel == 0} {
           exp_send "window, $win_no; display_veg, $var_type, win=$win_no, cmin=$cmin, cmax = $cmax, size = $msize, edt=1, felv = $fs, lelv=$lelv, fint=$fint, lint=$lint, cht = $cht, marker=$markerv, skip=$skip;\r"
           #exp_send "window, $win_no; display, $var_type, mode=\"intensity\", win=$win_no, cmin=$cmin1, cmax = $cmax1, size = $msize, marker=$markerv;\r"
         } else {
           exp_send "window, $win_no; display, fs_some, mode=\"intensity\", win=$win_no, cmin=$cmin1, cmax = $cmax1, size = $msize, marker=$markerv;\r"
         }
         expect ">"
       }
     }
     if {$ptype == 1} {
       if {$sel == 0} {
         exp_send "window, $win_no; plot_bathy, $var_type, win=$win_no, ba=$ba, fs = $fs, de = $de , fint = $fint, lint = $lint, cmin=$cmin, cmax=$cmax, msize = $msize, marker=$markerv, skip=$skip; \r"
       } else {
         exp_send "window, $win_no; plot_bathy, depth_some, win=$win_no, ba=$ba, fs = $fs, de = $de , fint = $fint, lint = $lint, cmin=$cmin, cmax=$cmax, msize = $msize, marker=$markerv, skip=$skip; \r"
       }
       expect ">"
       exp_send "\r"
     }
     if {$ptype == 2} {
        if {$sel == 0} {
         exp_send "window, $win_no; display_veg, $var_type, win=$win_no, cmin=$cmin, cmax = $cmax, size = $msize, edt=1, felv = $fs, lelv=$lelv, fint=$fint, lint=$lint, cht = $cht, marker=$markerv, skip=$skip;\r"
        } else {
         exp_send "window, $win_no; display_veg, veg_some, win=$win_no, cmin=$cmin, cmax = $cmax, size = $msize, edt=1, felv = $fs, lelv=$lelv, fint=$fint, lint=$lint, cht = $cht, marker=$markerv, skip=$skip;\r"
        }
         expect ">"
         exp_send "\r"
     }
     if {$ptype == 3} {
       set cmax1 [expr $cmax*100.]
       set cmin1 [expr $cmin*100.]
       if {$disp_type == 0} {
         if {$sel == 0} {
           exp_send "display, $var_type, win=$win_no, cmin=$cmin1, cmax = $cmax1, size = $msize, marker=$markerv, edt=1, skip=$skip;\r"
         } else {
           exp_send "display, cveg_some, win=$win_no, cmin=$cmin1, cmax = $cmax1, size = $msize, marker=$markerv, edt=1, skip=$skip;\r"
         }
         expect ">"
         exp_send "\r"
       } elseif { $disp_type == 4 } {
         if {$sel == 0} {
           exp_send "display, $var_type, mode=\"intensity\", win=$win_no, cmin=$cmin1, cmax = $cmax1, size = $msize, marker=$markerv, skip=$skip;\r"
         } else {
           exp_send "display, cveg_some, mode=\"intensity\", win=$win_no, cmin=$cmin1, cmax = $cmax1, size = $msize, marker=$markerv, skip=$skip;\r"
         }
         expect ">"
         exp_send "\r"
       }
     }
}

proc limits_tool { } {
  #Added by Jeremy Bracone 4/15/05
  #Opens a limits tool that makes a few functions a little quicker to perform.
  #The main function it provides is to set the limits from one window equal to another.
  destroy .limitstool
  toplevel .limitstool
  wm title .limitstool "Limits Tool"
  frame .limitstool.1 -relief groove -bd 4
  label .limitstool.1.t1 -text "Apply limits from window "
  ComboBox .limitstool.1.c1 -text "0" -width 2 -editable 0 \
        -values { 0 1 2 3 4 5 6 7 } \
        -takefocus 0

  label .limitstool.1.t2 -text " to window "
  ComboBox .limitstool.1.c2 -text "0" -width 2 -editable 0 \
        -values { 0 1 2 3 4 5 6 7 } \
        -takefocus 0


  Button .limitstool.1.limits -text "Set Limits" \
    -helptext "Set Limits in window from box 2 equal to limits in window from box 1\n i.e. make the second window look like the first" \
    -command {
        set window1 [.limitstool.1.c1 getvalue]
        set window2 [.limitstool.1.c2 getvalue]
        if {$window1 >= 0 && $window2 >= 0} {
           #This function provided by l1pro.i
           exp_send "winlimits($window1,$window2); \r"
        }
  }
  
  frame .limitstool.2
  Button .limitstool.2.l -text "Limits()" \
        -helptext "Set current window limits to view entire plot" \
        -command {
        exp_send "limits\r" 
        expect ">"
  } 
  Button .limitstool.2.dismiss -text "Dismiss" -command {
           destroy .limitstool
  }
  pack .limitstool.1 -side top
  pack .limitstool.1.t1 .limitstool.1.c1 .limitstool.1.t2 .limitstool.1.c2 .limitstool.1.limits -side left -fill both
  pack .limitstool.2 -side right 
  pack .limitstool.2.dismiss .limitstool.2.l -padx 4 -side right 
}

proc write_binary_file { ofname } {
	global ply_type q_type write_some var_type
	if { $ofname != "" }  {
         switch [ file extension $ofname ] {
          ".pbd" {
 	      if {($ply_type == "") && ($q_type == "")} {
		exp_send "vname=\"$var_type\"; save, createb(\"$ofname\"), vname, $var_type; \r";
	      } elseif {($ply_type == "") && !($q_type == "")} {
		exp_send "vname=\"$var_type\"; qname = \"$q_type\"; save, createb(\"$ofname\"), vname, $var_type, qname, $q_type; \r";
	      } elseif {!($ply_type == "") && !($q_type == "")} {
		exp_send "vname=\"$var_type\"; qname = \"$q_type\"; plyname = \"$ply_type\"; save, createb(\"$ofname\"), vname, $var_type, qname, $q_type, plyname, $ply_type; \r";
	      } else { ;# !($ply_type == "") && ($q_type == "")
		exp_send "vname=\"$var_type\"; plyname = \"$ply_type\"; save, createb(\"$ofname\"), vname, $var_type, plyname, $ply_type; \r";
	      }
	      destroy .l1write
          }
          ".bin" - 
          ".edf" {
          set opath  "[ file dirname $ofname ]/";
	  set ofname [ file tail    $ofname ];
    	  if { ![ string equal  "" $ofname ] } {
 	    if {$ptype == 0} {
	     if {$write_some == 0} {
 	       exp_send "write_topo, \"$opath\", \"$ofname\", $var_type; \r";
	       expect ">"
	     } else {
 	       exp_send "write_topo, \"$opath\", \"$ofname\", fs_some; \r";
	       expect ">"
	     }  
	    } elseif {$ptype == 1} {
	     if {$write_some == 0} {
      	       exp_send "write_bathy, \"$opath\", \"$ofname\", $var_type; \r";
	       expect ">"
	     } else {
      	       exp_send "write_bathy, \"$opath\", \"$ofname\", depth_some; \r";
	       expect ">"
   	     }
	    } elseif {$ptype == 2} {
	     if {$write_some == 0} {
      	       exp_send "write_veg, \"$opath\", \"$ofname\", $var_type; \r";
	       expect ">"
	     } else {
      	       exp_send "write_veg, \"$opath\", \"$ofname\", veg_some; \r";
	       expect ">"
   	     }	
	    } elseif {$ptype == 3} {
	     if {$write_some == 0} {
      	       exp_send "write_multipeak_veg, $var_type, opath=\"$opath\", ofname=\"$ofname\"; \r";
	       expect ">"
	     } else {
      	       exp_send "write_multipeak_veg, cveg_some, opath=\"$opath\", ofname=\"$ofname\"; \r";
	       expect ">"
   	     }	
	    }
    	  } else { 
       	    tk_messageBox  -icon warning \
            -message "You need to specify an output file name" \
            -type ok
          }
	  set write_some 0
        }
        default {
          tk_messageBox -icon warning \
          -message "You need to specify an output file with a valid file extension (pbd, bin, or edf)" \
          -type ok
        }
       }
      } else {
       	    tk_messageBox  -icon warning \
            -message "You need to specify an output file name" \
            -type ok
      }
}
source "$src_path/bathctl.ytk"; 
#.l1wid.mb.options entryconfigure 3 -state disabled


