# vim: set tabstop=2 softtabstop=2 shiftwidth=2 autoindent shiftround expandtab:
#
# Orginal Amar Nayegandhi aka "anayegan"
#
# For info on using the Bwidget NoteBoook see:  http://mini.net/tcl/2298
#

# plot_settings
# var_settings

package require BWidget
package require Tktable
package require struct::list
package require struct::set
package require misc
package require tooltip
package require l1pro::deprecated
package require l1pro::dirload
package require l1pro::vars
package require l1pro::file
package require l1pro::tools

if {![winfo exists .l1wid]} {
  set l1pro_data(processing_mode) [list \
    "First Return Topo" \
    "Submerged Topo" \
    "Topo Under Veg" \
    "Multi Peak Veg" \
    "Direct. Wave Spectra" \
  ]

  set l1pro_data(display_types) [list \
    "First Return Topography" \
    "Submerged Topography" \
    "Water Depth" \
    "Bare Earth Topography" \
    "Surface Amplitude" \
    "Bottom Amplitude" \
    "Canopy Height" \
  ]

  set _l1pro_processing_mode [lindex $l1pro_data(processing_mode) 0]
  set ofname ""
  set curvar ""
  set outvar ""
  set win_no 5
  set win_load 6;    # used by EAARL Data Loader
  set usecentroid 1

  set cmax_max 5000
  set cmin_min -100
  set cmax_inc 0.1

  set list {}
  set lrnindx {}
  set write_some 0
  set ssvar "*.pbd"
  set avg_surf 1
  set rcf_buf_rgn 0; #Used in proc replace_proc
  set autoclean_after_process 1

  set gridtype grid

  set show_pro_gui 1
  set data_file_path ""

  proc show_pro_gui_update {a b c} {
    global show_pro_gui
    if {$show_pro_gui} {
      grid .l1wid.bf4
    } else {
      grid remove .l1wid.bf4
    }
  }

  trace remove variable show_pro_gui write show_pro_gui_update
  trace add variable show_pro_gui write show_pro_gui_update

  set varlist {fs_all depth_all veg_all cveg_all workdata}

  set cdelta 80
  set var_common [list \
    win_no 5 \
    cmin -40 \
    cmax 40 \
    msize 1.0 \
    mtype 1]

  set var_settings(fs_all) [linsert $var_common end \
    var fs_all \
    processing_mode "First Return Topo" \
    display_type "First Return Topography"]

  set var_settings(depth_all) [linsert $var_common end \
    var depth_all \
    processing_mode "Submerged Topo" \
    display_type "Submerged Topography"]

  set var_settings(veg_all) [linsert $var_common end \
    var veg_all \
    processing_mode "Topo Under Veg" \
    display_type "Bare Earth Topography"]

  set var_settings(cveg_all) [linsert $var_common end \
    var cveg_all \
    processing_mode "Multi Peak Veg" \
    display_type "First Return Topography"]

  set var_settings(workdata) [linsert $var_common end \
    var workdata \
    processing_mode "Submerged Topo" \
    display_type "Submerged Topography"]

  set pro_var fs_all
  array set plot_settings $var_settings($pro_var)

  set plot_dpi 75
  array set cbvc {cmin cmin cmax cmax msize msize mtype mtype}

  set cbvc(cmin) $plot_settings(cmin)
  set cbvc(cmax) $plot_settings(cmax)
  set cbvc(msize) $plot_settings(msize)
  set cbvc(mtype) $plot_settings(mtype)

  set constant_win_no 0
  set l1pro_square_limits 1

  #load all yorick support functions
  ybkg require \"l1pro.i\"

  toplevel .l1wid
  wm withdraw .l1wid
  wm protocol .l1wid WM_DELETE_WINDOW {
    wm withdraw .l1wid
  }

  wm title .l1wid "Process EAARL Data"
  frame .l1wid.bf4
  frame .l1wid.bf4.1
  frame .l1wid.bf45 -relief groove -borderwidth 3
  frame .l1wid.bf45.sc -relief groove -borderwidth 3
  ttk::panedwindow .l1wid.bf45.p -orient horizontal
  .l1wid.bf45.p add [frame .l1wid.bf45.p.left] -weight 1
  .l1wid.bf45.p add [frame .l1wid.bf45.p.right] -weight 1
  frame .l1wid.bf45.q -relief groove -borderwidth 3
  LabelFrame .l1wid.bf45.r -relief groove -borderwidth 7 -text "FILTER:"

  .l1wid configure -menu .l1wid.mb
  menu .l1wid.mb
  menu .l1wid.mb.file
  menu .l1wid.mb.load
  menu .l1wid.mb.options
  menu .l1wid.mb.options.processing
  menu .l1wid.mb.graph
  menu .l1wid.mb.util
  menu .l1wid.mb.cmd
  menu .l1wid.mb.dep


  .l1wid.mb add cascade -label File -underline 0 -menu .l1wid.mb.file
  .l1wid.mb.file add command -label "Load ALPS data..." \
    -underline 0 -command ::l1pro::file::load_pbd
  .l1wid.mb.file add command -label "Save ALPS data..." \
    -underline 0 -command ::l1pro::file::save_pbd

  .l1wid.mb.file add separator

  .l1wid.mb.file add command -label "Load ALPS data as..." \
    -underline 15 -command ::l1pro::file::load_pbd_as
  .l1wid.mb.file add command -label "Load ALPS data directory..." \
    -underline 10 -command ::l1pro::dirload
  .l1wid.mb.file add command -label "Save ALPS data as..." \
    -underline 0 -command ::l1pro::file::save_pbd_as

  .l1wid.mb.file add separator

  menu .l1wid.mb.file.bin
  .l1wid.mb.file add cascade -label "Binary (edf/bin) data..." \
    -underline 0 -menu .l1wid.mb.file.bin
  .l1wid.mb.file.bin add command -label "Load data from file..." \
    -underline 0 -command ::l1pro::file::load_bin
  .l1wid.mb.file.bin add command -label "Save data to file..." \
    -underline 0 -command ::l1pro::file::save_bin
  .l1wid.mb.file.bin add command -label "Load directory..." \
    -underline 5 -command ::l1pro::dirload_bin

  .l1wid.mb.file add command -label "Import ASPRS LAS..." \
    -underline 0 -command ::l1pro::file::load_las

  .l1wid.mb.file add command -label "Export ASCII..." \
    -underline 1 -command ::l1pro::file::export_ascii

  .l1wid.mb.file add separator

  menu .l1wid.mb.file.vars
  .l1wid.mb.file add cascade -label "Variables..." -underline 0 -menu .l1wid.mb.file.vars
  .l1wid.mb.file.vars add command -label "Load from file..." \
    -command ::l1pro::vars::load_from_file
  .l1wid.mb.file.vars add command -label "Save to file..." \
    -command ::l1pro::vars::save_to_file

  .l1wid.mb.file add command -label "Capture a display..." -command scap \
    -underline 0
  .l1wid.mb.file add separator
  .l1wid.mb.file add command -label "Dismiss" -underline 0 \
    -command {wm withdraw .l1wid}

  .eaarl.mb clone .l1wid.mb.eaarl menubar
  .l1wid.mb add cascade -label EAARL -underline 0 -menu .l1wid.mb.eaarl

  .l1wid.mb add cascade -label "Load" -underline 0 -menu .l1wid.mb.load
  .l1wid.mb.load add command -label "Mission configuration manager" \
    -underline 0 -command ::mission::launch_gui
  .l1wid.mb.load add command -label "Plotting tool" -underline 0 \
    -command ::plot::menu
  .l1wid.mb.load add separator
  .l1wid.mb.load add command -label "Load TANS Data .. " -underline 5 \
    -command {exp_send "tans = rbtans();\r"}
  .l1wid.mb.load  add command -label "Load DMARS PBD Data .. " -underline 5 \
    -command load_dmars

  .l1wid.mb.load add command -label "Load PNAV Data .. " -underline 5 \
    -command {exp_send "pnav = rbpnav(); \r"}

  .l1wid.mb.load add command -label "Load Ops_conf Settings..." -underline 5 \
    -command load_ops_conf

  .l1wid.mb.load add command -label "Load Bathymetry Settings .." -underline 21 \
    -command bathctl::gui


  .l1wid.mb add cascade -label Options -underline 0 -menu .l1wid.mb.options

  .l1wid.mb.options add cascade -label "Processing options..." -underline 2 \
    -menu .l1wid.mb.options.processing

  .l1wid.mb.options.processing add checkbutton -variable usecentroid \
    -label "Correct range walk with centroid"

  .l1wid.mb.options.processing add checkbutton -variable avg_surf \
    -label "Use Fresnel reflections to determine water surface (submerged only)"

  .l1wid.mb.options.processing add checkbutton \
    -variable autoclean_after_process \
    -label "Automatically test and clean after processing"

  .l1wid.mb.options.processing add checkbutton \
    -label "Show Processing section of GUI" \
    -variable show_pro_gui

  .l1wid.mb.options add command \
    -label "Show Flightlines with No Raster Data..." -underline 25 \
    -command {exp_send "plot_no_raster_fltlines(gga, edb);\r"}

  .l1wid.mb.options add command -label "Show Flightlines with No TANS Data..." \
    -underline 25 \
    -command {exp_send "plot_no_tans_fltlines(tans, gga);\r"}

  namespace eval varplot {
    namespace eval v {
      variable win .varplot
      variable lb ""
      variable var_add ""
      variable fixed_vars [list fs_all depth_all veg_all cveg_all]
    }
  }

  proc varplot::gui {} {
    set w $v::win
    destroy $w
    toplevel $w
    wm title $w "List"

    set f $w
    set v::lb $f.slbVars
    iwidgets::scrolledlistbox $v::lb \
      -width 12 -listvariable ::varlist \
      -hscrollmode dynamic -vscrollmode dynamic \
      -selectmode extended \
      -scrollmargin 0 -sbwidth 10

    button $f.btnSelect -text "Select" -command ::varplot::cmd_select
    LabelEntry $f.lbeAdd -width 8 -relief sunken -label "Add:" \
      -helptext "Add variable name to list" \
      -textvariable ::varplot::v::var_add
    $f.lbeAdd bind <Return> ::varplot::bind_add_enter
    button $f.btnDelete -text "Delete" -command ::varplot::cmd_delete
    button $f.btnRename -text "Rename" -command ::varplot::cmd_rename
    button $f.btnDismiss -text "Dismiss" -command [list destroy $v::win]

    grid $v::lb -sticky news
    grid $f.btnSelect -sticky news
    grid $f.lbeAdd -sticky news
    grid $f.btnDelete -sticky news
    grid $f.btnRename -sticky news
    grid $f.btnDismiss -sticky news

    grid columnconfigure $f 0 -weight 1 -minsize 110
    grid rowconfigure $f 0 -weight 1 -minsize 200
  }

  proc varplot::cmd_select {} {
    set selected [$v::lb getcurselection]
    if {[llength $selected] == 1} {
      set ::pro_var [lindex $selected 0]
    } elseif {[llength $selected] > 1} {
      tk_messageBox -icon warning -type ok \
        -message "You cannot select multiple variables. Select only one."
    }
  }

  proc varplot::bind_add_enter {} {
    append_varlist $v::var_add
    set v::var_add ""
  }

  proc varplot::cmd_delete {} {
    set selected [$v::lb getcurselection]

    ::struct::list split $selected [list ::struct::set contains $v::fixed_vars] \
      pass fail

    if {[llength $pass]} {
      set this_variable [this_variable [llength $pass]]
      tk_messageBox -icon warning -type ok \
        -message "Aborting. You cannot delete ${this_variable}: $pass"
    } else {
      ::struct::list split $::varlist [list ::struct::set contains $selected] \
        pass fail

      set this_variable [this_variable [llength $pass]]
      set response [tk_messageBox -icon question -type yesno -title Warning \
        -message "Are you sure you want to delete ${this_variable}?\n$pass"]

      if {$response eq "yes"} {
        foreach var $pass {
          yset $var = {[]}
        }
        set ::varlist $fail
      }
    }
  }

  proc varplot::cmd_rename {} {
    set selected [$v::lb getcurselection]

    ::struct::list split $selected [list ::struct::set contains $v::fixed_vars] \
      pass fail

    if {[llength $pass]} {
      set this_variable [this_variable [llength $pass]]
      tk_messageBox -icon warning -type ok \
        -message "Aborting. You cannot delete ${this_variable}: $pass"
    } else {
      ::struct::list split $::varlist [list ::struct::set contains $selected] \
        pass fail

      if {[llength $pass] == 1} {
        set old [lindex $pass 0]
        set new $old
        set prompt "What would you like to rename '$old' to?"
        if {[::getstring::tk_getString $v::win.gs new $prompt]} {
          if {$old ne $new} {
            exp_send "eq_nocopy, $new, $old; $old = \[\];\r"
            set idx [lsearch -exact $::varlist $old]
            set ::varlist [lreplace $::varlist $idx $idx $new]
            if {[info exists ::plot_settings($old)]} {
              if {![info exists ::plot_settings($new)]} {
                set ::plot_settings($new) $::plot_settings($old)
              }
            }
            if {$::pro_var eq $old} {
              set ::pro_var $new
            }
          }
        }
      } else {
        tk_messageBox -icon warning -type ok -title Warning \
          -message "You cannot rename multiple variables at once. Select only one."
      }
    }
  }

  proc varplot::this_variable count {
    # Utility function that returns "this variable" or "these variables"
    # depending on the count given.
    return [lindex [list "this variable" "these variables"] [expr {$count > 1}]]
  }

  proc append_varlist {newvar} {
    global varlist
    if {[lsearch -exact $varlist $newvar] == -1} {
      lappend varlist $newvar
      logger info "(l1pro) appended to varlist: $newvar"
    }
  }

  .l1wid.mb.options add checkbutton -label "Constant Colorbar for Variables" \
    -variable cbv \
    -command {
      if {$cbv == 1} {
        global cbvc plot_settings
        set cbvc(cmin) $plot_settings(cmin)
        set cbvc(cmax) $plot_settings(cmax)
        set cbvc(msize) $plot_settings(msize)
        set cbvc(mtype) $plot_settings(mtype)
      }
    }
  .l1wid.mb.options add checkbutton -label "Constant Window for Variables" \
    -variable constant_win_no

  .l1wid.mb.options add checkbutton -label "Autodraw colorbar when plotting" \
    -variable l1pro_cbar

  .l1wid.mb.options add checkbutton -label "Plot with square limits" \
    -variable l1pro_square_limits

  proc make_selected_arrays {} {
    global lrnindx list
    set curlist [.l1plot.1.lb curselection]
    set ptype [processing_mode]
    if {$ptype == 0} {
      exp_send "fs_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {($lidx != "")} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, fs_some, fs_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, fs_some, fs_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
    if {$ptype == 1} {
      exp_send "depth_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {$lidx != ""} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, depth_some, depth_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, depth_some, depth_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
    if {$ptype == 2} {
      exp_send "veg_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {$lidx != ""} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, veg_some, veg_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, veg_some, veg_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
    if {$ptype == 3} {
      exp_send "cveg_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {$lidx != ""} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, cveg_some, cveg_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, cveg_some, cveg_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
  }

  .l1wid.mb   add cascade -label Graph -underline 0 -menu .l1wid.mb.graph
  .l1wid.mb.graph add command -label "Open the Limits Tool" -underline 0 \
    -command limits_tool
  .l1wid.mb.graph add separator
  .l1wid.mb.graph add command -label "Change current window to 75 DPI / 450x450" \
    -command [list ycmd change_window_size [list window() 1 0]]
  .l1wid.mb.graph add command -label "Change current window to 100 DPI / 600x600" \
    -command [list ycmd change_window_size [list window() 2 0]]
  .l1wid.mb.graph add command -label "Change current window to 75 DPI / 825x638" \
    -command [list ycmd change_window_size [list window() 3 0]]
  .l1wid.mb.graph add command -label "Change current window to 100 DPI / 1100x850" \
    -command [list ycmd change_window_size [list window() 4 0]]
  .l1wid.mb.graph add separator
  menu .l1wid.mb.graph.pal
  .l1wid.mb.graph add cascade -label Palette... -under 0 -menu .l1wid.mb.graph.pal
  foreach __p [list earth stern rainbow yarg heat gray] {
  .l1wid.mb.graph.pal add command -label $__p -under 0 -command [list ypalette $__p]
  }
  unset __p

  proc ypalette p {
    exp_send "palette, \"${p}.gp\";\r"
    expect "> "
  }

  .l1wid.mb add cascade -label Utilities -underline 0 -menu .l1wid.mb.util

  .l1wid.mb.util add command -label "Pixel Analysis" \
    -command [list ::pixelwf::gui::launch_full_panel .pixelwf]

  .l1wid.mb.util add command -label "Histogram Elevations" \
    -command ::l1pro::tools::histelev::gui

  .l1wid.mb.util add separator

  .l1wid.mb.util add command -label "Transect Tool" \
    -command [list source [file join $src_path transrch.ytk]]

  menu .l1wid.mb.util.seg
  .l1wid.mb.util add cascade -label "Launch segments by..." -menu .l1wid.mb.util.seg
  .l1wid.mb.util.seg add command -label "Flightline" \
    -command [list segment_data_launcher fltlines]
  .l1wid.mb.util.seg add command -label "Flightline and digitizer" \
    -command [list segment_data_launcher fltlines_digitizer]
  .l1wid.mb.util.seg add command -label "Day" \
    -command [list segment_data_launcher days]
  .l1wid.mb.util.seg add command -label "Day and digitizer" \
    -command [list segment_data_launcher days_digitizer]
  .l1wid.mb.util.seg add command -label "Manual selection" \
    -command select_data_segments

  menu .l1wid.mb.util.stat
  .l1wid.mb.util add cascade -label "Launch statistics by..." \
    -menu .l1wid.mb.util.stat
  .l1wid.mb.util.stat add command -label "Flightline" \
    -command [list segment_stat_launcher fltlines]
  .l1wid.mb.util.stat add command -label "Flightline and digitizer" \
    -command [list segment_stat_launcher fltlines_digitizer]
  .l1wid.mb.util.stat add command -label "Day" \
    -command [list segment_stat_launcher days]
  .l1wid.mb.util.stat add command -label "Day and digitizer" \
    -command [list segment_stat_launcher days_digitizer]

  .l1wid.mb.util add command -label "Open Fit Gaussian GUI" \
    -command open_fit_gaussian_gui

  .l1wid.mb.util add command -label "Determine Roll Bias" -underline 0 \
    -command determine_roll_bias

  proc determine_roll_bias {} {
      global win_no varlist bias pro_var

      destroy .l1bias
      toplevel .l1bias
      wm title .l1bias "Determine Roll Bias"

      foreach x {1 2 3 4 5 6} {
        frame .l1bias.$x
        pack .l1bias.$x -side top
      }

      if { [info exists bias ] == 0 } {
        exp_send "updatebias\r"
        expect ">"
        exp_send "updatebias\r"
        expect ">"
      }
      set slope 0
      set inout 1
      set width 5
      set flwin 4
      set var $pro_var

      LabelEntry .l1bias.1.var -relief sunken -borderwidth 3 -width 10 \
        -label "Variable:" -helptext "EAARL source data" \
        -textvariable var -text $var

      Label .l1bias.1.winl -text "in window:"
      spinbox .l1bias.1.win -justify center -width 2 \
        -textvariable win_no -from 0 -to 63 -increment 1

      Label .l1bias.1.transl -text "Then click"
      Button .l1bias.1.transbutton -text "Get Transect" \
        -helptext "Click to get transect" \
        -command {
          exp_send "transdata = get_transect($var, win=$win_no, update=1,\
            width=$width)\r"
          expect ">"
          .l1bias.3.plot configure -state normal
          .l1bias.3.winl configure -state normal
          .l1bias.3.win configure -state normal
          .l1bias.3.pick configure -state normal
          .l1bias.3.inout configure -state normal
          .l1bias.3.auto configure -state normal
        }

      Button .l1bias.1.help -text "Help!" -helptext "Click for directions" \
        -command {
          tk_messageBox -icon warning \
            -message "1) Start with data array plotted in a window and raw EAARL\
              data loaded. Set the variable and window and click Get Transect.\
              \r2) Drag a line perpendicular to the flightlines you wish to\
              examine. In the window that appears, zoom into the top, type\
              something, and hit enter. Now drag a box over the section of the\
              transect you wish to keep.\
              \r3) Click the plot button to display the loaded transect. In\
              order to determine the bias automatically all flightlines must be\
              traveling the same direction, so you'll need to remove whichever\
              direction is the minority.\
              \r4) Click 'select flightlines' and simply type 'y' or 'n' to keep\
              or remove each flightline. Now you have a set of flightlines going\
              the same direction.\
              \r5) Finally, determine whether the flightlines are going into or\
              out of the screen. If they are going INTO the screen, check the\
              box." \
            -type ok
        }

      LabelEntry .l1bias.2.width -relief sunken -width 3 \
        -label "Width:" -helptext "Transect width" \
        -textvariable width -text $width

      LabelEntry .l1bias.2.bias -relief sunken -width 10 \
        -label "Current Roll Bias:" -helptext "Current Roll Bias" \
        -textvariable bias -text $bias

      LabelEntry .l1bias.2.slope -relief sunken -width 10 \
        -label "Current Slope:" -helptext "Current slope" \
        -textvariable slope -text $slope

      Button .l1bias.3.plot -text "Plot" \
        -helptext "Click to plot flightline transect" \
        -command {exp_send "plot_flightline_transect(transdata, $flwin)\r"}

      Label .l1bias.3.winl -text "in win:"
      spinbox .l1bias.3.win -justify center \
        -width 2 -textvariable flwin -from 0 -to 63 -increment 1

      Button .l1bias.3.pick -text "Select Flightlines" \
        -helptext "Click to select which flightlines to keep" \
        -command {exp_send "transdata=selgoodflightlines(transdata, win=$flwin)\r"}

      checkbutton .l1bias.3.inout -text "in/out:" \
        -variable inout -onvalue -1 -offvalue 1

      Button .l1bias.3.auto -text "Determine bias" \
        -helptext "Click to automatically determine roll bias" \
        -command {exp_send "goodroll=find_roll_bias(transdata,0,$inout,update=1)\r"}

      pack .l1bias.1.var .l1bias.1.winl .l1bias.1.win .l1bias.1.transl \
        .l1bias.1.transbutton .l1bias.1.help -side left
      pack .l1bias.2.width .l1bias.2.bias .l1bias.2.slope -side left
      pack .l1bias.3.plot .l1bias.3.winl .l1bias.3.win .l1bias.3.pick \
        .l1bias.3.inout .l1bias.3.auto -side left

      foreach w {plot winl win pick inout auto} {
        .l1bias.3.$w configure -state disabled
      }
    }

  .l1wid.mb add cascade -label CmdLine -underline 1 -menu .l1wid.mb.cmd
  foreach ycmd {
    mtransect batch_process mbatch_process batch_rcf batch_datum_convert
    batch_veg_lfpw batch_pbd2las batch_write_xyz
  } {
    .l1wid.mb.cmd add command -label $ycmd \
      -command [list exp_send "help, $ycmd\r"]
  }

  .l1wid.mb add cascade -label Deprecated -underline 1 -menu .l1wid.mb.dep

  .l1wid.mb.dep add command -label "Old Pixel Waveform" \
    -command ::l1pro::deprecated::pixelwf

  .l1wid.mb.dep add checkbutton \
    -label "Show raw and processed waveforms when using Pixel Waveform" \
    -variable bconst

  .l1wid.mb.dep add separator

  ### DEPRECATED 2009-12-22 ###
  # Replaced by "Read PBD Data Directory..." and "Read Binary Data (edf/bin)
  # Directory..." entries, supported by l1pro::dirload.
  .l1wid.mb.dep add command -label "Old Read Data Directory..." \
    -underline 10 -command ::l1pro::deprecated::l1dir::gui

  ### DEPRECATED 2009-02-02 ###
  # This menu entry and its code are deprecated. They have been replaced by the
  # code in namespace l1dir, which is invoked from the non-deprecated
  # "Read Data Directory..." menu entry above it.
  .l1wid.mb.dep add command -label "Even Older Read Data Directory..." \
    -command ::l1pro::deprecated::read_data_dir_older

  .l1wid.mb.dep add separator

  ### DEPRECATED 2010-01-03 ###
  # Following entries replaced by file-1.0.tm functionality.
  .l1wid.mb.dep add command -label "Read Binary Data file..." -underline 0 \
    -command ::l1pro::deprecated::read_binary_data_file
  .l1wid.mb.dep add command -label "Write Binary Data File..." -underline 0 \
    -command ::l1pro::deprecated::write_binary_data_file
  .l1wid.mb.dep add command -label "Read SubSampled Data File..." -underline 5 \
    -command ::l1pro::deprecated::read_subsampled_data_file
  .l1wid.mb.dep add command -label "Load EAARL data from map limits" \
    -underline 21 \
    -command ::l1pro::deprecated::load_eaarl_data_from_map_limits
  .l1wid.mb.dep add command -label "Ascii output ..." -underline 0 \
    -command ::l1pro::deprecated::ascii_output

  .l1wid.mb.dep add separator

  .l1wid.mb.dep add command -label "Configure elevation scale limits..." \
    -underline 0 \
    -command ::l1pro::deprecated::configure_elevation_scale_limits

  .l1wid.mb.dep add command -label "Plot/Write Individual Flightlines..." \
    -underline 0 \
    -command ::l1pro::deprecated::plot_write_individual_flightlines

  .l1wid.mb.dep add command -label "Test and Clean" \
    -command {exp_send "$::pro_var = test_and_clean($::pro_var);\r"}

  .l1wid.mb.dep add command -label "Append2Tile" \
    -command ::l1pro::deprecated::append2tile
  .l1wid.mb.dep add command -label "Save Tile" \
    -command ::l1pro::deprecated::savetile

  proc open_fit_gaussian_gui {} {
    source [file join $::src_path fit_gauss.ytk]
    fit_gauss::create_gui
  }

  proc rcf_region {} {
    global varlist l1pro_data pro_var rcf_var
    destroy .rcf
    destroy .ircf
    toplevel .rcf
    wm title .rcf "Random Consensus Filter"
    frame .rcf.0 -relief groove -borderwidth 3
    frame .rcf.1
    frame .rcf.2
    frame .rcf.3
    frame .rcf.4
    frame .rcf.5
    frame .rcf.6

    ::misc::combobox .rcf.0.mode -text "Select RCF type" -width 18 \
      -values [list RCF "Iterative RCF"] \
      -state readonly \
      -modifycmd {
        set rcfmode [.rcf.0.mode getvalue]
        if {$rcfmode == -1} {
          set rcfmode 0
        }
        if {$rcfmode == 1} {
          pack forget .rcf.3
          pack .rcf.0 .rcf.1 .rcf.2 .rcf.5 .rcf.6 .rcf.3 -side top -pady 10
        } else {
          pack forget .rcf.5 .rcf.6
        }
      }
    ::tooltip::tooltip .rcf.0.mode "Select the type of RCF filter"

    Button .rcf.0.help -text "Help" -width 8 -bd 5 \
      -command {
        set rcfmode [.rcf.0.mode getvalue]
        if {$rcfmode == -1} {
          tk_messageBox  -icon info \
            -message "Select one of the filtering methods in the drop down\
              menu. Click Help on each selection to learn more about the\
              filtering method" \
            -type ok -title "Select RCF Type -- Help"
        }
        if {$rcfmode == 0} {
          exp_send "help, rcfilter_eaarl_pts\r"
        }
        if {$rcfmode == 1} {
          exp_send "help, rcf_triag_filter\r"
        }
      }


    LabelEntry .rcf.1.buf -width 4 -relief sunken -label "Input Window (cm):" \
      -helptext "The input window size that will slide through the data set (in\
        centimeters)" \
      -textvariable buf -text 500
    LabelEntry .rcf.1.w -width 4 -relief sunken -label "Elevation width (cm):" \
      -helptext "The vertical extent or range of the filter (in centimeters)" \
      -textvariable w -text 20
    LabelEntry .rcf.1.no -width 4 -relief sunken -label "Minimum winners:" \
      -helptext "The minimum number of winners" \
      -textvariable no_rcf -text 3

    Label .rcf.2.varname -text "Input Variable:"

    ::misc::combobox .rcf.2.varlist \
      -textvariable rcf_var \
      -listvariable varlist \
      -state readonly -width 10 \
      -modifycmd {
        set outvar "rcf_$rcf_var"
      }

    set rcf_var $pro_var

    Label .rcf.2.dispname -text "Mode:"
    ::misc::combobox .rcf.2.disp -width 20 -state readonly \
      -values $l1pro_data(processing_mode)
    ::tooltip::tooltip .rcf.2.disp "Select any one of the following"

    set curproc [processing_mode]
    .rcf.2.disp setvalue @$curproc

    LabelEntry .rcf.2.outvar -relief sunken \
      -label "Output Variable:" -helptext "Define output variable" \
      -textvariable outvar -text "rcf_$rcf_var" -width 10

    LabelEntry .rcf.5.premin -relief sunken \
      -label "Pre-filter Elevations (m): Min" \
      -helptext "Use this minimum elevation (in m) before applying RCF. Leave\
        blank for no value" \
      -textvariable prefilter_min -text "" -width 4

    LabelEntry .rcf.5.premax -relief sunken -label "Max" \
      -helptext "Use this maximum elevation (in m) before applying RCF. Leave\
        blank for no value" \
      -textvariable prefilter_max -text "" -width 4

    LabelEntry .rcf.5.tai -relief sunken -label "No. of iterations" \
      -helptext "Number of RCF iterations to perform (default = 3)" \
      -textvariable tai -text 3 -width 2

    LabelEntry .rcf.5.tw -relief sunken -label "TIN elev width (cm)" \
      -helptext "Vertical range (in cm) used in each iteration to densify the\
        point cloud after triangulating" \
      -textvariable tw -text 20 -width 4

    checkbutton .rcf.6.inter -text "Interactive?" -variable interactive \
      -command {
        if {($interactive == 1) && ($plottriagwin == "")} {
          set plottriagwin 4
        }
      }
    set interactive 0

    LabelEntry .rcf.6.triagwin -relief sunken -label "Plot TIN in win:" \
      -helptext "Plot TIN during each iteration in this window number. Leave\
        blank to not plot the TINs. If interactive is set, default window is 4." \
      -textvariable plottriagwin -width 4

    LabelEntry .rcf.6.distthresh -relief sunken -label "Distance Threshold (m):" \
      -textvariable distthresh -text 100  -width 4 \
      -helptext "Enter distance threshold (in meters) that sets the maximum\
        allowable length of any side of a triangle in the TIN model.  Set to 0\
        if you don't want to use it.  Defaults to 100m."

    Button .rcf.3.go -width 8 -text "Go" \
      -command {
        global varlist outvar
        switch [.rcf.2.disp getvalue] {
          "0" {set mode 1}
          "1" {set mode 2}
          "2" {set mode 3}
        }
        append_varlist $outvar
        set rcfmode [.rcf.0.mode getvalue]
        if { $rcfmode == 1 } {
          if {$plottriagwin != ""} {
            set plottriag 1
          } else {
            set plottriag ""
          }
          set datawin $::win_no
          exp_send "$outvar = rcf_triag_filter($rcf_var, buf=$buf, w=$w,\
            no_rcf=$no_rcf, mode=$mode, tw=$tw, interactive=$interactive,\
            tai=$tai, plottriag=$plottriag, plottriagwin=$plottriagwin,\
            prefilter_min=$prefilter_min, prefilter_max=$prefilter_max,\
            distthresh=$distthresh, datawin=$datawin );\r\n"
        } else {
          exp_send "$outvar = rcfilter_eaarl_pts($rcf_var, buf=$buf, w=$w,\
            no_rcf=$no_rcf, mode=$mode);\r\n"
        }
        destroy .rcf
      }
    Button .rcf.3.cancel -text "Cancel" -width 8 -command {
      destroy .rcf
    }
    pack .rcf.1.buf .rcf.1.w .rcf.1.no -side left -padx 3
    pack .rcf.2.varname \
      .rcf.2.varlist \
      .rcf.2.dispname \
      .rcf.2.disp \
      .rcf.2.outvar \
      -side left -padx 3
    pack .rcf.3.go .rcf.3.cancel -side left -padx 5
    pack .rcf.0.mode .rcf.0.help -side left -padx 5
    pack .rcf.5.premin .rcf.5.premax .rcf.5.tai .rcf.5.tw -side left -padx 5
    pack .rcf.6.inter .rcf.6.triagwin .rcf.6.distthresh -side left -padx 5
    pack .rcf.0 .rcf.1 .rcf.2 .rcf.5 .rcf.6 .rcf.3 -side top -pady 10
    pack forget .rcf.5 .rcf.6
  }

  ::misc::combobox .l1wid.bf4.1.d -text "Define Region..." -width 15 \
    -values [list "Rubberband Box" "Points in Polygon" "Rectangular Coords"] \
    -state readonly \
    -modifycmd {
      set defr [.l1wid.bf4.1.d getvalue]
      puts $defr
      if {$defr == 0} {
        if { $_ytk(annoying_help) == "Yes" } {
          set result [tk_messageBox  -icon info \
            -message "Drag a Rectangular Box in Window $_map(window) to define\
              the region." \
            -type okcancel -title "Message"]
        } else {
          set result "ok"
        }
        if {$result == "ok"} {
          exp_send "q = gga_win_sel(2, win=$_map(window));\r"
          expect ">"
        }
      }
      if {$defr == 1} {
        if { $_ytk(annoying_help) == "Yes" } {
          set result [tk_messageBox  -icon info \
            -message "Draw a Polygon in Window $_map(window) to define a region\
              using a series of left mouse clicks. To complete the polygon,\
              middle mouse click OR <Ctrl> and left mouse click." \
            -type okcancel -title "Message"]
        } else {
          set result "ok"
        }
        if {$result == "ok"} {
          exp_send "q = gga_pip_sel(1, win=$_map(window));\r"
          expect ">"
        }
      }
      if {$defr == 2} {
        destroy .l1widc
        toplevel .l1widc
        frame .l1widc.lon
        frame .l1widc.1
        frame .l1widc.utm
        ::misc::combobox .l1widc.utm.1 -text "Coordinate System" -width 18 \
          -values [list LatLon UTM] -state readonly
        ::tooltip::tooltip .l1widc.utm.1 "Select the Coordinate System."
        LabelEntry .l1widc.utm.2 -width 6 -relief sunken -label "UTM Zone: " \
          -helptext "Enter UTM Zone Here" \
          -textvariable zone

        LabelEntry .l1widc.lat1 -width 12 -relief sunken \
          -label "NorthLat/Max.Northing " \
          -helptext "Enter Maximum Latitude in degrees or Maximum UTM Northing\
            in meters Here"\
          -textvariable mxlat
        LabelEntry .l1widc.lat2 -width 12 -relief sunken \
          -label "SouthLat/Min.Northing " \
          -helptext "Enter Minimum Latitude in degrees or Minimum UTM Northing\
            in meters Here"\
          -textvariable mnlat

        LabelEntry .l1widc.lon.mn -width 12 -relief sunken \
          -label "WestLon/Min.Easting " \
          -helptext "Enter Westernmost Longitude in degrees or Minimum UTM\
            Easting in meters Here"\
          -textvariable mnlon
        LabelEntry .l1widc.lon.mx -width 12 -relief sunken \
          -label "EastLon/Max.Easting " \
          -helptext "Enter Easternmost Longitude in degrees or Maximum UTM\
            Easting in meters Here"\
          -textvariable mxlon
        Button .l1widc.1.ok -text "OK" -width 5 -command {
          set utm [.l1widc.utm.1 getvalue]
          exp_send "utm = $utm;\
            q = gga_win_sel(2, win=$_map(window),\
              llarr=\[$mnlon, $mxlon, $mnlat, $mxlat\]);\r"
          destroy .l1widc
        }
        Button .l1widc.1.box -text "Plot Region" -width 7 -command {
          exp_send "a_x=\[$mnlon, $mxlon, $mxlon, $mnlon, $mnlon\];\r"
          exp_send "a_y=\[$mnlat, $mnlat, $mxlat, $mxlat, $mnlat\];\r"
          exp_send "window, $_map(window); plg, a_y, a_x;\r"
        }

        Button .l1widc.1.cancel -text "Cancel" -width 5 -command {
          destroy .l1widc
        }
        pack .l1widc.utm.1 .l1widc.utm.2 -side left
        pack .l1widc.lon.mn .l1widc.lon.mx -side left -padx 4
        pack .l1widc.utm .l1widc.lat1 .l1widc.lon .l1widc.lat2 -side top -pady 5
        pack .l1widc.1.ok .l1widc.1.box .l1widc.1.cancel -side left
        pack .l1widc.1 -side top

      }
      if {$defr == -1} {
        error "Please Define Region."
      }
    }
  ::tooltip::tooltip .l1wid.bf4.1.d \
    "Select region to process using any of the following methods"

  proc processing_mode {} {
    global plot_settings l1pro_data
    return [lsearch -exact $l1pro_data(processing_mode) \
      $plot_settings(processing_mode)]
  }

  proc processing_mode_changed {a b c} {
    global curs
    if {$b eq "processing_mode"} {
      set curs [processing_mode]
    }
  }

  trace remove \
    variable plot_settings(processing_mode) write processing_mode_changed
  trace add \
    variable plot_settings(processing_mode) write processing_mode_changed

  ::misc::combobox .l1wid.bf4.1.p \
    -textvariable plot_settings(processing_mode) \
    -state readonly \
    -values $l1pro_data(processing_mode)

  proc processing_mode_by_index {index} {
    global plot_settings l1pro_data
    set plot_settings(processing_mode) \
      [lindex $l1pro_data(processing_mode) $index]
  }

  Label .l1wid.bf4.1.lw -text "in Win:"
  spinbox .l1wid.bf4.1.sw -justify center -from 0 -to 63 -increment 1 \
    -width 2 -textvariable _map(window)

  Button .l1wid.bf45.p.left.14 -text "Variable:" -command ::varplot::gui

  proc pro_var_changed {a b c} {
    global var_settings plot_settings pro_var cbv win_no constant_win_no

    # Currently saved version -- to be replaced
    if {[info exists var_settings($plot_settings(var))]} {
      set stored $var_settings($plot_settings(var))
    } else {
      set stored [array get plot_settings]
    }

    # Update processing_mode and display_type
    dict set stored processing_mode $plot_settings(processing_mode)
    dict set stored display_type $plot_settings(display_type)

    # Update cbar if appropriate
    if {$cbv == 0} {
      foreach key {cmin cmax msize mtype} {
        dict set stored $key $plot_settings($key)
      }
    }

    # Update win_no if appropriate
    if {$constant_win_no == 0} {
      dict set stored win_no $win_no
    }

    # Replace saved version with new values
    set var_settings($plot_settings(var)) $stored

    # Load stored settings to be used
    if {[info exists var_settings($pro_var)]} {
      set stored $var_settings($pro_var)
    } else {
      set stored [array get plot_settings]
    }

    # Update processing_mode and display_type
    set plot_settings(var) $pro_var
    set plot_settings(processing_mode) [dict get $stored processing_mode]
    set plot_settings(display_type) [dict get $stored display_type]

    # Update cbar if appropriate
    if {$cbv == 0} {
      foreach key {cmin cmax msize mtype} {
        set plot_settings($key) [dict get $stored $key]
      }
    }

    # Update win_no if appropriate
    if {$constant_win_no == 0} {
      set plot_settings(win_no) [dict get $stored win_no]
      set win_no $plot_settings(win_no)
    }
  }

  trace remove variable pro_var write pro_var_changed
  trace add variable pro_var write pro_var_changed

  ::misc::combobox .l1wid.bf45.p.left.15 \
    -textvariable pro_var \
    -state readonly \
    -listvariable varlist

  trace add variable pro_var write {apply {{v1 v2 op} {
    ::tooltip::tooltip .l1wid.bf45.p.left.15 $::pro_var
  }}}
  # Trigger the trace
  set pro_var $pro_var

  Label .l1wid.bf45.p.right.2 -text "in Win:"
  spinbox .l1wid.bf45.p.right.3 -justify center -from 0 -to 63 -increment 1 \
    -width 2 -textvariable win_no

  proc display_type {} {
    global plot_settings
    switch -- $plot_settings(display_type) {
      "First Return Topography" {
        return 0
      }
      "Submerged Topography" {
        return 1
      }
      "Water Depth" {
        return 2
      }
      "Bare Earth Topography" {
        return 3
      }
      "Surface Amplitude" {
        return 4
      }
      "Bottom Amplitude" {
        return 5
      }
      "Canopy Height" {
        return 6
      }
      default {
        return -1
      }
    }
  }

  Label .l1wid.bf45.p.right.25 -text "Mode:"
  ::misc::combobox .l1wid.bf45.p.right.5 \
    -textvariable plot_settings(display_type) \
    -state readonly \
    -values $l1pro_data(display_types)

  proc display_type_by_index {index} {
    global plot_settings l1pro_data
    set plot_settings(display_type) \
      [lindex $l1pro_data(display_types) $index]
  }

  Button .l1wid.bf45.q.2 -text "Histogram\nElevations" \
    -helptext "Generate and display a histogram of all the first return\
      elevations" \
    -command ::l1pro::tools::histelev

  Button .l1wid.bf45.q.1 -text "Pixel\nAnalysis" \
    -helptext "Click to jump to raster, pulse, and image for xyz point." \
    -command [list ycmd pixelwf_enter_interactive]

  Button .l1wid.bf45.q.3 -text "Color\nBar" \
    -command {
      global win_no plot_settings
      exp_send "window, $win_no;\
        colorbar, $plot_settings(cmin), $plot_settings(cmax), drag=1\r"
    }
  Button .l1wid.bf45.q.rcf -text "RCF" -command rcf_region
  Button .l1wid.bf45.q.datum -text "Datum\nConvert" -command datum_proc
  Button .l1wid.bf45.q.4 -text "Elevation\nClipper" \
    -command ::l1pro::tools::histclip::gui

  misc::combobox::mapping .l1wid.bf45.q.gridtype \
    -width 0 \
    -state readonly \
    -altvariable ::gridtype \
    -mapping {
      "2km Data Tile" grid
      "Quarter Quad" qq_grid
    }
  button .l1wid.bf45.q.gridplot -text "Plot" -width 0 \
    -command {exp_send "draw_${::gridtype}, $::win_no\r"}
  button .l1wid.bf45.q.gridname -text "Name" -width 0 \
    -command {exp_send "show_${::gridtype}_location, $::win_no\r"}

  ::tooltip::tooltip .l1wid.bf45.q.gridtype \
    "Select the tiling system to use\ for \"Plot\" and \"Name\" below."
  ::tooltip::tooltip .l1wid.bf45.q.gridplot \
    "Plots a grid showing tile boundaries for the currently selected tiling\
    \nsystem."
  ::tooltip::tooltip .l1wid.bf45.q.gridname \
    "After clicking this button, you will be prompted to click on the current\
    \nplotting window. You will then be told which tile corresponds to the\
    \nlocation you clicked."

  frame  .l1wid.bf45.sc.1

  ::misc::combobox .l1wid.bf45.r.1 -text "Copy points using..." -width 16 \
    -state readonly \
    -values [list "Rubberband Box" "Points in Polygon" "Single Pixel" \
      "Select Cell/Quad/Tile"] \
    -modifycmd {
      global varlist pro_var

      set selr [.l1wid.bf45.r.1 getvalue]
      if {$selr == 0} {
        set var_type $pro_var
        set selection [tk_messageBox -icon info \
          -message "Drag a Rectangular Box in Window $win_no to define region." \
          -type okcancel -title "Message"]
        if {$selection == "ok"} {
          exp_send "workdata = sel_data_rgn($var_type, mode=2, win=$win_no)\r"
          expect ">"
        }
      }
      if {$selr == 1} {
        set selection  [tk_messageBox -icon info \
          -message "Draw a Polygon in Window $win_no to define a region using a\
            series of left mouse clicks.  To complete the polygon, middle mouse\
            click OR <Ctrl> and left mouse click." \
          -type okcancel -title "Message" ]
        if {$selection == "ok"} {
          exp_send "workdata = sel_data_rgn($var_type, mode=3, win=$win_no)\r"
          expect ">"
        }
      }
      if {$selr == 2} {
        exp_send "workdata = select_points($var_type, win=$win_no);\r"
        expect ">"
      }
      if {$selr == 3} {
        set selection [tk_messageBox -icon info \
          -message "Select a cell (250m by 250m) region by dragging a region in\
            window $win_no within the required cell."\
          -type okcancel -title "Message" ]
        if {$selection == "ok"} {
          exp_send "workdata = select_region($var_type, win=$win_no, plot=1);\r"
          expect ">"
        }
      }
      if {$selr == -1} {
        error "Please Define Region."
      }
      append_varlist workdata
    }
  ::tooltip::tooltip .l1wid.bf45.r.1 \
    "Copy points to 'workdata' using any of the following methods:\
     \n  Rubberband Box\
     \n  Points in Polygon\
     \n  Single Pixel"

  ::misc::combobox .l1wid.bf45.r.7 -text "Filter tools..." -width 16 \
    -values [list Keep Remove Replace] \
    -state readonly \
    -modifycmd {
      global varlist
      switch -- [.l1wid.bf45.r.7 getvalue] {
        0 keep_proc
        1 removing_proc
        2 replace_proc
        default {error "Please Define Region."}
      }
    }
  ::tooltip::tooltip .l1wid.bf45.r.7 "Choose any of the following tools:"

  proc removing_proc {} {
    global varlist rmv_var plot_settings pro_var
    destroy .rem
    toplevel .rem
    frame .rem.05
    frame .rem.07 -relief raised -bd 1
    frame .rem.08 -relief raised -bd 1
    frame .rem.09
    wm title .rem "Remove Points Using..."
    Label .rem.05.varname -text "Input Variable:"

    ::misc::combobox .rem.05.varlist \
      -textvariable ::rmv_var -state readonly \
      -listvariable ::varlist
    set rmv_var $pro_var

    frame .rem.06
    Label .rem.06.typetext -text "Data type:"
    # IMPORTANT NOTE: Do not change the order of GEO and VEG__ for the values of
    # the combobox below. A function parameter for the pipthresh function for
    # this gui is dependent on the index number of the selection.
    ::misc::combobox .rem.06.type -textvariable remove_type -width 12 \
      -values [list "GEO or VEG__" "FS"]
    if {[display_type] == 0} {
      .rem.06.type setvalue @1
    } else {
      .rem.06.type setvalue @0
    }

    ::misc::combobox .rem.1 -width 18 -state readonly \
      -text "Remove points using..." \
      -values [list "Rubberband Box" "Points in Polygon" "Single Pixel" \
        "Pip-Thresh"] \
      -modifycmd {
        set removemode [.rem.1 getvalue]
        if {$removemode == 3} {
          pack forget .rem.2 .rem.3 .rem.4
          pack .rem.08 .rem.07
          pack .rem.07.a .rem.07.min .rem.07.minthresh -side left
          pack .rem.08.a .rem.08.max .rem.08.maxthresh -side left
          pack .rem.09 .rem.09.a
          pack .rem.2 .rem.3 -side left -padx 5 -pady 5
          set min_thresh $plot_settings(cmin)
          set max_thresh $plot_settings(cmax)
        } else {
          pack forget .rem.2 .rem.3 .rem.4
          pack forget .rem.07 .rem.08 .rem.09
          pack .rem.2 .rem.3 .rem.4 -side left -padx 5 -pady 5
        }
      }
    ::tooltip::tooltip .rem.1 \
      "Remove points from 'workdata' using any of the following methods:\
      \n  Rubberband Box\
      \n  Points in Polygon\
      \n  Single Pixel"
    Label .rem.07.a -text "Min. Threshold:"
    Label .rem.08.a -text "Max. Threshold:"
    Label .rem.09.a -text "WARNING: Cannot undo action." -justify center
    checkbutton .rem.07.min -variable min \
      -command {
        set state [lindex {disabled normal} $min]
        .rem.07.minthresh configure -state $state
      }
    checkbutton .rem.08.max -variable max \
      -command {
        set state [lindex {disabled normal} $max]
        .rem.08.maxthresh configure -state $state
      }
    spinbox .rem.07.minthresh -textvariable min_thresh -width 10 \
      -from -100 -to 5000 -increment 0.1 -format %.2f
    spinbox .rem.08.maxthresh -textvariable max_thresh -width 10 \
      -from -100 -to 5000 -increment 0.1 -format %.2f
    set min 1
    set max 1
    .rem.07.min select
    .rem.08.max select
    set min_thresh $plot_settings(cmin)
    set max_thresh $plot_settings(cmax)

    Button .rem.2 -width 8 -text "Go" \
      -command {
        global varlist outvar selr rmv_var pro_var

        set selr [.rem.1 getvalue]
        if {$selr == 0} {
          set var_type $pro_var
          set selection [tk_messageBox -icon info \
            -message "Drag a Rectangular Box in Window $win_no to define a\
              region." \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            exp_send "croppeddata=\[\];\
              $rmv_var = sel_data_rgn($rmv_var, mode=2, win=$win_no, exclude=1)\r"
            expect ">"
          }
        }
        if {$selr == 1} {
          set selection  [tk_messageBox  -icon info \
            -message "Draw a Polygon in Window $win_no to define a region using\
              a series of left mouse clicks. To complete the polygon, middle\
              mouse click OR <Ctrl> and left mouse click." \
            -type okcancel -title "Message" ]
          if {$selection == "ok"} {
            exp_send "croppeddata=\[\];\
              $rmv_var = sel_data_rgn($rmv_var, mode=3, win=$win_no, exclude=1)\r"
            expect ">"
          }
        }
        if {$selr == 2} {
          set selection [tk_messageBox  -icon info \
            -message "Select points to remove from window $win_no" \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            exp_send "croppeddata=\[\];\
              $rmv_var = select_points($rmv_var, win=$win_no, exclude=1);\r"
            expect ">"
          }
        }
        if {$selr == 3} {
          if {[.rem.06.type getvalue] == 1} {
            set val [.rem.06.type getvalue]
          } else {
            set val ""
          }
          if { $min == 0 && $max == 0 } {
            tk_messageBox -icon warning \
              -message "You have not set any threshold limits!" \
              -type ok -title "ERROR!"
          } else {
            # If we don't want to use a threshhold, we set it to void
            set min_arg [expr {$min ? $min_thresh : ""}]
            set max_arg [expr {$max ? $max_thresh : ""}]
            exp_send "croppeddata=\[\];\
              $rmv_var = pipthresh($rmv_var, mode=$val,\
                minthresh=$min_arg, maxthresh=$max_arg);\r"
          }
        }
        if {$selr == -1} {
          error "Please Define Region."
        } else {
          append_varlist $rmv_var
        }
      }
    Button .rem.3 -width 8 -text "Dismiss" -command {
      destroy .rem
    }
    Button .rem.4 -width 8 -text "Undo Last\nRemove" -command {
      exp_send "if(is_array(croppeddata))\
        $rmv_var = grow($rmv_var,croppeddata);\r"
      expect ">"
    }

    pack .rem.05.varname .rem.05.varlist -side left -padx 5
    pack .rem.06.typetext .rem.06.type -side left
    pack .rem.05 .rem.06 .rem.1 -pady 8
    pack .rem.08 .rem.07 .rem.09
    pack .rem.2 .rem.3 .rem.4 -side left -padx 5 -pady 5
  }


  proc datum_proc {} {
    global varlist datum_var pro_var
    destroy .con
    toplevel .con

    wm title .con "Convert data from w84 to n88..."

    frame .con.05

    Label .con.05.varname -text "Input Variable:"

    ::misc::combobox .con.05.varlist \
      -textvariable ::datum_var -state readonly \
      -listvariable ::varlist
    set datum_var $pro_var

    Label .con.02 -text "The converted variable is named\
      n88_(currentvariablename)"
    Button .con.1 -width 8 -text "Go" \
      -command {
        set convar "n88_$datum_var"

        exp_send "$convar = datum_convert_data($datum_var);\r"
        expect ">"

        append_varlist $convar
      }

    pack .con.05.varname .con.05.varlist -side left -padx 5
    pack .con.05 .con.02 .con.1  -side top -pady 10
  }

  proc keep_proc {} {
    global varlist keep_in_var keep_out_var pro_var
    destroy .sel
    toplevel .sel
    wm title .sel "Keep Points Using..."
    frame .sel.05

    Label .sel.05.varname -text "Input Variable:"
    ::misc::combobox .sel.05.varlist \
      -textvariable ::keep_in_var -state readonly \
      -listvariable ::varlist
    set keep_in_var $pro_var

    ::misc::combobox .sel.1 -state readonly -width 16 \
      -text "Keep points using..." \
      -values [list "Rubberband Box" "Points in Polygon" "Single Pixel"] \
      -modifycmd {
        global sels keep_in_var keep_out_var grow_keep
        set sels [.sel.1 getvalue]
        if {$sels == 2} {
          set grow_keep 1
          set keep_out_var "finaldata"
        } else {
          set keep_out_var $keep_in_var
        }
      }
    ::tooltip::tooltip .sel.1 \
      "Keep points from 'workdata' using any of the following methods:\
      \n  Rubberband Box\
      \n  Points in Polygon\
      \n  Single Pixel"

    checkbutton .sel.grow -text "Grow output variable" -variable grow_keep
    LabelEntry .sel.15 -relief sunken -label "Output Variable:" \
      -helptext "Define output variable" \
      -textvariable keep_out_var -text "workdata"

    Button .sel.2 -width 8 -text "Go" \
      -command {
        global varlist outvar sels keep_in_var keep_out_var pro_var

        set sels [.sel.1 getvalue]
        if {$sels == 0} {
          set var_type $pro_var
          set selection [tk_messageBox  -icon info \
            -message "Drag a Rectangular Box in Window $win_no to define\
              region." \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            if {$grow_keep == 0} {
              exp_send "$keep_out_var =\
                sel_data_rgn($keep_in_var, mode=2, win=$win_no)\r"
              expect ">"
            } else {
              exp_send "grow, $keep_out_var,\
                sel_data_rgn($keep_in_var, mode=2, win=$win_no);\r"
              expect ">"
            }
          }
        }
        if {$sels == 1} {
          set selection  [tk_messageBox  -icon info \
            -message "Draw a Polygon in Window $win_no to define a region using\
              a series of left mouse clicks.To complete the polygon, middle\
              mouse click OR <Ctrl> and left mouse click." \
            -type okcancel -title "Message" ]
          if {$selection == "ok"} {
            if {$grow_keep == 0} {
              exp_send "$keep_out_var =\
                sel_data_rgn($keep_in_var, mode=3, win=$win_no)\r"
              expect ">"
            } else {
              exp_send "grow, $keep_out_var,\
                sel_data_rgn($keep_in_var, mode=3, win=$win_no);\r"
              expect ">"
            }
          }
        }
        if {$sels == 2} {
          set selection [tk_messageBox  -icon info \
            -message "Select points to keep from window $win_no" \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            if {$grow_keep == 0} {
              exp_send "$keep_out_var =\
                select_points($keep_in_var, win=$win_no);\r"
              expect ">"
            } else {
              exp_send "grow, $keep_out_var,\
                select_points($keep_in_var, win=$win_no));\r"
              expect ">"
            }
          }
        }
        if {$sels == -1} {
          error "Please Define Region."
        } else {
          append_varlist $keep_out_var
        }
      }
    Button .sel.3 -width 8 -text "Dismiss" -command {
      destroy .sel
    }

    pack .sel.05.varname .sel.05.varlist -side left -padx 5
    pack .sel.05 .sel.1 .sel.grow .sel.15 -side top -pady 10
    pack .sel.2 .sel.3 -side left -padx 5 -pady 5
  }

  proc replace_proc {} {
    global varlist croppeddata have_replaced have_undone rcf_buf_rgn \
      pro_var replace_in_var replace_orig_var replace_out_var
    set have_undone 0
    set have_replaced 0
    destroy .rep
    toplevel .rep
    wm title .rep "Replace Points Using..."
    frame .rep.05
    frame .rep.005
    frame .rep.15

    set sameinput 0
    Label .rep.05.varname -text "Input Variable:"

    ::misc::combobox .rep.05.varlist \
      -textvariable replace_in_var -state readonly \
      -listvariable ::varlist
    set replace_in_var $pro_var

    Label .rep.005.varname -text "Original Data Variable:"

    ::misc::combobox .rep.005.varlist \
      -textvariable replace_orig_var -state readonly \
      -listvariable ::varlist
    set replace_orig_var $pro_var

    # Note: In code below, the yorick variables "croppeddata" and "workdata" are
    # created through sel_data_rgn
    #   croppeddata = (selected filtered points);
    #   workdata = (selected original data points);
    ::misc::combobox .rep.1 -state readonly -width 28 \
      -text "Select points to replace using..." \
      -values [list "Rubberband Box" "Points in Polygon" "Window Limits"] \
      -modifycmd {
        set defr [.rep.1 getvalue]
        set sel_points buf_points
        set buffered_var bufferdata
        global rcf_buf_rgn
        if {$rcf_buf_rgn > 0} {
          if {$defr == 0} {
            set result [tk_messageBox  -icon info \
              -message "Drag a Rectangular Box in Window $win_no to define\
                region." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = $replace_in_var;\r"
              exp_send "$sel_points = mouse(1,1,\
                \"Hold the left mouse button down, select a region:\");"
              expect ">"
              exp_send "temp_rgn = add_buffer_rgn($sel_points,\
                $rcf_buf_rgn, mode=1);\r"
              expect ">"
              exp_send "workdata = sel_data_rgn($replace_orig_var, mode=4,\
                win=$win_no, rgn=temp_rgn);\r"
              expect ">"
            }
          } elseif {$defr == 1} {
            set result [tk_messageBox -icon info \
              -message "Draw a Polygon in Window $win_no to define a region\
                using a series of left mouse clicks. To complete the polygon,\
                middle mouse click OR <Ctrl> and left mouse click." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = $replace_in_var;\r"
              # For eval purposes, success stores if getPoly_add_buffer command
              # was successful. The yorick variables buf_points, temp_rgn, and
              # workdata are made.
              exp_send "success = getPoly_add_buffer($rcf_buf_rgn,\
                origdata=$replace_origvar, windw=$win_no);\r"
              expect ">"
            }
          } elseif {$defr == 2} {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = $replace_in_var;\r"
            exp_send "window, $win_no;\
              $sel_points=limits()(1:4);\
              temp_rgn = add_buffer_rgn($sel_points, $rcf_buf_rgn, mode=3);\r"
            expect ">"
            exp_send "workdata = sel_data_rgn($replace_orig_var, mode=4,\
              win=$win_no, rgn=temp_rgn);\r"
            expect ">"
          }
          set have_replaced 0
          set have_undone 0
        } else {
          if {$defr == 0} {
            set result [tk_messageBox  -icon info \
              -message "Drag a Rectangular Box in Window $win_no to define\
                region." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = sel_data_rgn($replace_in_var,\
                mode=2, win=$win_no, exclude=1, make_workdata=1,\
                origdata=$replace_orig_var);\r"
              expect ">"
              set have_replaced 0
              set have_undone 0
            }
          }
          if {$defr == 1} {
            set result [tk_messageBox  -icon info \
              -message "Draw a Polygon in Window $win_no to define a region\
                using a series of left mouse clicks. To complete the polygon,\
                middle mouse click OR <Ctrl> and left mouse click." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = sel_data_rgn($replace_in_var,\
                mode=3, win=$win_no, exclude=1, make_workdata=1,\
                origdata=$replace_orig_var);\r"
              expect ">"
              set have_replaced 0
              set have_undone 0
            }
          }
          if {$defr == 2} {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = sel_data_rgn($replace_in_var,\
              mode=1, win=$win_no, exclude=1, make_workdata=1,\
              origdata=$replace_orig_var);\r"
            set have_replaced 0
            set have_undone 0
          }
        #end if/else rcf_buf_rgn
        }
      }
    ::tooltip::tooltip .rep.1 \
      "Select points to replace using any of the following methods:\
      \n Rubberband Box\
      \n Points in Polygon\
      \n Window Limits.\
      \nSelected points from the original data array will be written\
      \nto variable \"workdata\"."

    Button .rep.type -text "Filter selected points" -width 15 -bd 5 \
      -command {
        global curvar have_replaced have_undone croppeddata outvar rcf_buf_rgn \
          sel_points
        set outvar rcf_workdata
        if {$have_undone == 1} {
          if {$rcf_buf_rgn > 0} {
            exp_send "workdata = tempdata;\r"
          } else {
            append_varlist $replace_out_var
            exp_send "$replace_out_var =\
              $replace_out_var (1: - numberof(croppeddata));\r"
          }
        } elseif {$have_replaced == 1} {
          if {$rcf_buf_rgn > 0} {
            exp_send "workdata = tempdata;\r"
          } else {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = $replace_out_var (1: - numberof($outvar));\r"
          }
        }
        rcf_region
        set rcf_var [lindex $varlist 4]
        set have_replaced 0
        set have_undone 0
      }

    LabelEntry .rep.15.1 -relief sunken -label "Output Variable:" \
      -helptext "Define output variable" \
      -textvariable replace_out_var -text "finaldata"
    checkbutton .rep.15.2 -text "Same as input variable" -variable sameinput \
      -command {
        if {$sameinput == 1} {
          set replace_out_var $replace_in_var
          .rep.15.1 configure -state disabled
        } else {
          .rep.15.1 configure -state normal
        }
      }
    LabelEntry .rep.15.3 -relief sunken -label "Buffer Region (m):" -width 5 \
      -helptext "Define the amount of buffer used in filtering for the selected\
        points" \
      -textvariable rcf_buf_rgn -text "0"

    Button .rep.15.4 -text "Click \[HERE\] for info" -bd 0 \
      -command {
        tk_messageBox -icon info \
          -message "Points in the buffer region will be used for filtering, but\
            will not be replaced into the output array." \
          -type ok -title "Use a buffer region help"
      }

  # Significant change made by Jeremy Bracone 4/4/05
  # Do No Replace as been fixed and now acts as an undo while Replace acts as a
  # redo. Replace will put filtered data into output array, "Do Not Replace" will
  # put original data into output array. If a replace or "Do Not Replace" has
  # already been done, hitting replace or Do not will have no effect. If replace
  # or "Do Not Replace" has already been done, hitting one will undo the action
  # of the other and perform the expected operation; i.e. Replace was done, now
  # hit Do Not Replace and it will take out the data inserted in the Replace and
  # put in the original data. Same is true for opposite situation.
    Button .rep.2 -width 8 -text "Replace..." -bd 5 \
      -command {
        global varlist outvar reps keep_var curvar origvar have_replaced \
          have_undone croppeddata
        set $outvar rcf_workdata
        set selection [tk_messageBox -icon question \
          -message "Append array $outvar to $replace_out_var?" \
          -type yesno -title "Warning" ]
        if {$selection == "yes" && $have_replaced == 0 && $have_undone == 0} {
          if {$rcf_buf_rgn > 0} {
            # have to save workdata since sel_data_rgn with exclude set to 1 will
            # over-write it
            exp_send "tempdata = workdata;\r"
            exp_send "$replace_out_var = sel_data_rgn($replace_out_var,\
              mode=4, rgn=$sel_points, win=$win_no, exclude=1, make_workdata=1,\
              origdata=$replace_orig_var);\r"
            expect ">"
            # This is kind of confusing, but $outvar = rcf_workdata (love this
            # confuciated variable hiding)
            exp_send "workdata = tempdata;\
              $outvar = sel_data_rgn($outvar, mode=4, win=$win_no,\
                rgn=$sel_points);\r"
          }
          append_varlist $replace_out_var
          exp_send "$replace_out_var = grow($replace_out_var, $outvar);\r"
        }
        if {$selection == "yes" && $have_replaced == 0 && $have_undone == 1} {
          append_varlist $replace_out_var
          exp_send "$replace_out_var = $replace_out_var\
            (1: - numberof(croppeddata));\r"
          exp_send "$replace_out_var = grow($replace_out_var, $outvar);\r"
          set have_undone 0
        }
        expect ">"
        set have_replaced 1
      }
    Button .rep.4 -width 10 -text "Do Not Replace..." -bd 5 \
      -command {
        global varlist outvar reps replace_out_var curvar origvar
        set selection [tk_messageBox -icon question \
          -message "Append ORIGINAL cropped array croppeddata to\
            $replace_out_var?" \
          -type yesno -title "Warning" ]
        if {$selection == "yes"} {
          if {$have_replaced == 0 && $have_undone == 0} {
            if {$rcf_buf_rgn > 0} {
              # have to save workdata since sel_data_rgn with exclude set to 1
              # will over-write it
              set $outvar rcf_workdata
              exp_send "tempdata = workdata;\r"
              exp_send "$replace_out_var = sel_data_rgn($replace_out_var,\
                mode=4, rgn=$sel_points, win=$win_no, exclude=1,\
                make_workdata=1, origdata=$replace_orig_var);\r"
              expect ">"
              exp_send "workdata = tempdata;\
                $outvar = sel_data_rgn($outvar, mode=4, win=$win_no,\
                  rgn=$sel_points);\r"
            }
            append_varlist $replace_out_var
            exp_send "$replace_out_var = grow($replace_out_var, croppeddata);\r"
          }
          if {$have_replaced == 1 && $have_undone == 0} {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = $replace_out_var\
              (1: - numberof($outvar));\r"
            exp_send "$replace_out_var = grow($replace_out_var, croppeddata);\r"
          }
          expect ">"
          set have_undone 1
          set have_replaced 0
        }
      }
    Button .rep.3 -width 8 -text "Close" -command [list destroy .rep]

    Button .rep.5 -width 3 -text "Help" -command {
      tk_messageBox -icon info \
        -message "Hitting replace adds new filtered array to the output array\
          which Do Not Replace adds the original data back in." \
        -type ok -title "Info 1 of 3"
      tk_messageBox -icon info \
        -message "Once a replace or Do Not Replace has been done, the effects of\
          one can be replaced by the other." \
        -type ok -title "Info 2 of 3"
      tk_messageBox -icon info \
        -message "Example: Hit replace and insert filtered data, then hit DO NOT\
          REPLACE, and inserted data is taken out and original put in." \
        -type ok -title "Info 3 of 3"
    }

    pack .rep.05.varname .rep.05.varlist -side left -padx 5
    pack .rep.005.varname .rep.005.varlist -side left -padx 5
    pack .rep.15.1 .rep.15.2 -side top -pady 3
    pack .rep.15.4 .rep.15.3 -side right
    pack .rep.05 .rep.005 .rep.15 .rep.1 .rep.type  -side top -pady 10
    pack .rep.2 .rep.4 .rep.3 -side left -padx 5 -pady 5
    pack .rep.5 -side left -pady 5
  }

  proc sst {w var lbl rg} {
  # This procedure builds a widget composed of a Label, a spinbox, and a scale so
  # one can enter values by direct entry, the spin clicks, or the scale.
    frame $w
    lassign $rg rmin rmax rinc
    spinbox $w.sb -textvariable $var -format %.2f \
      -from $rmin -to $rmax -increment $rinc -width 6
    scale $w.sc -showvalue 0 -orient horizontal  \
      -variable $var \
      -from $rmin \
      -to   $rmax \
      -resolution $rinc
    label $w.lb -text $lbl
    pack $w.lb $w.sb $w.sc -side left -fill x -expand 1
    return $w
  }

  proc ud { a b c } {
    global cdelta min_thresh max_thresh plot_settings
    switch -- $b {
      cmax -
      cmin {
        set cdelta [format %.2f [expr {$plot_settings(cmax) - $plot_settings(cmin)}]]
      }
    }
    if { [ winfo exists .rem ] } {
      set min_thresh $plot_settings(cmin)
      set max_thresh $plot_settings(cmax)
    }
  }

  trace remove variable plot_settings(cmin) write ud
  trace remove variable plot_settings(cmax) write ud

  trace add variable plot_settings(cmin) write ud
  trace add variable plot_settings(cmax) write ud

  sst .l1wid.bf45.sc.1.cmax plot_settings(cmax) "Cmax:" { -50 5000.0 0.1 }
  sst .l1wid.bf45.sc.1.cmin plot_settings(cmin) "Cmin:" { -100 5000.0 0.1 }
  sst .l1wid.bf45.sc.1.cdelta cdelta "Cdelta:"  { 0.0  2000.0 0.1 }
  grid .l1wid.bf45.sc.1.cmax   -in .l1wid.bf45.sc.1 -column 0 -row 0 -sticky "e"
  grid .l1wid.bf45.sc.1.cdelta -in .l1wid.bf45.sc.1 -column 0 -row 1 -sticky "e"
  grid .l1wid.bf45.sc.1.cmin   -in .l1wid.bf45.sc.1 -column 0 -row 2 -sticky "e"

  .l1wid.bf45.sc.1.cdelta.sc configure -state disabled
  .l1wid.bf45.sc.1.cdelta.sb configure -state disabled

  LabelFrame  .l1wid.bf45.sc.f -relief sunken -borderwidth 3 -text "Marker:"
  spinbox .l1wid.bf45.sc.f.msize \
    -from 0.1 -to 10.0 -increment 0.1 \
    -textvariable plot_settings(msize) \
    -width 5
  ::tooltip::tooltip .l1wid.bf45.sc.f.msize "Enter Marker Size (msize)"

  spinbox .l1wid.bf45.sc.f.marker \
    -from 0 -to 9 -increment 1 \
    -textvariable plot_settings(mtype) \
    -width 5
  ::tooltip::tooltip .l1wid.bf45.sc.f.marker \
    "Enter Marker Type (See help, marker for more details)"

  frame .l1wid.bf45.sc.g
  LabelFrame .l1wid.bf45.sc.g.sk -relief groove -borderwidth 3 -text "Skip:"
  spinbox .l1wid.bf45.sc.g.sk.skip \
    -from 1 -to 1000 -increment 1 \
    -textvariable skip \
    -width 5
  ::tooltip::tooltip .l1wid.bf45.sc.g.sk.skip "Enter plot points to skip"

  checkbutton .l1wid.bf45.sc.g.fma -text "Auto Clear" -variable l1pro_fma

  Button .l1wid.bf45.sc.pl -text "Plot" -width 6 -height 2 -bd 5 -command {
    display_data
  }
  pack \
    .l1wid.bf45.sc.f.msize \
    .l1wid.bf45.sc.f.marker \
    -side top
  pack .l1wid.bf45.sc.g.sk.skip
  pack \
    .l1wid.bf45.sc.g.fma \
    .l1wid.bf45.sc.g.sk \
    -side top

  Button .l1wid.bf4.1.proc -text "Process" -bd 5\
    -command {
      global list lrnindx pro_var varlist autoclean_after_process
      set list {}
      set lrnindx {}
      exp_send "utm = $utm\n"
      set ptype [processing_mode]
      set defr [.l1wid.bf4.1.d getvalue]
      exp_send "ptype = $ptype\n\r"

      # Deprecated as of 2009-03-16 by DBN
      # The widget .l1wid.bf4.1.d currently will never have a value of 3, so
      # the following code is obsolete. I've commented it out for now, but it
      # should be removed eventually.
      #
      #if {$defr == 3} {
      #  exp_send "q = gga_win_sel(2, win=6,\
      #    llarr=\[$mnlon, $mxlon, $mnlat, $mxlat\]);\r"
      #}

      switch -- $ptype {
        0 {
          exp_send "fs_all = make_fs(latutm=1, q=q, ext_bad_att=1,\
            usecentroid=$usecentroid);\r"
          expect ">"
          set pro_var fs_all
        }
        1 {
          exp_send "depth_all = make_bathy(latutm = 1, q = q, ext_bad_depth=1,\
            ext_bad_att=1, avg_surf=$avg_surf);\r"
          expect ">"
          set pro_var depth_all
        }
        2 {
          exp_send "veg_all = make_veg(latutm=1, q=q, ext_bad_att=1,\
            ext_bad_veg=1, use_centroid=$usecentroid);\r"
          expect ">"
          set pro_var veg_all
        }
        3 {
          exp_send "cveg_all = make_veg(latutm=1, q=q, use_centroid=$usecentroid,\
            multi_peaks=1);\r"
          expect ">"
          set pro_var cveg_all
        }
        4 {
          exp_send "require, \"waves.i\";process_for_dws,q;\r"
          expect ">"
        }
      }

      if {$autoclean_after_process} {
        yset $pro_var test_and_clean [list $pro_var]
      }
    }

  grid \
    .l1wid.bf4.1.d \
    .l1wid.bf4.1.p \
    .l1wid.bf4.1.lw \
    .l1wid.bf4.1.sw \
    .l1wid.bf4.1.proc \
    -sticky ew \
    -padx 5
  grid columnconfigure .l1wid.bf4.1 {0 1} -weight 1

  grid .l1wid.bf4.1 -pady 5 -sticky ew
  grid columnconfigure .l1wid.bf4 0 -weight 1
  #pack .l1wid.bf4.1 .l1wid.bf4.2 -side top -pady 10

  #pack \
  #  .l1wid.bf4 \
  #  -side top -expand 1 -fill both

  pack .l1wid.bf45.sc.1  -side left  -padx 3
  pack .l1wid.bf45.sc.f .l1wid.bf45.sc.g .l1wid.bf45.sc.pl -side left -padx 5

  pack \
    .l1wid.bf45.r.1 \
    .l1wid.bf45.r.7 \
    -side left

  grid .l1wid.bf45.q.1 .l1wid.bf45.q.2 .l1wid.bf45.q.3 \
    .l1wid.bf45.q.rcf .l1wid.bf45.q.datum .l1wid.bf45.q.4 \
    .l1wid.bf45.q.gridtype - -sticky news
  grid ^ ^ ^ ^ ^ ^ \
    .l1wid.bf45.q.gridplot .l1wid.bf45.q.gridname -sticky news
  grid columnconfigure .l1wid.bf45.q 1000 -weight 1
  grid columnconfigure .l1wid.bf45.q {6 7} -uniform g

  grid .l1wid.bf45.p.left.14 .l1wid.bf45.p.left.15 -padx 2 -sticky ew -row 1
  grid columnconfigure .l1wid.bf45.p.left 1 -weight 1
  grid rowconfigure .l1wid.bf45.p.left {0 2} -weight 1

  grid .l1wid.bf45.p.right.25 .l1wid.bf45.p.right.5 .l1wid.bf45.p.right.2 \
    .l1wid.bf45.p.right.3 -padx 2 -sticky ew -row 1
  grid columnconfigure .l1wid.bf45.p.right 1 -weight 1
  grid rowconfigure .l1wid.bf45.p.right {0 2} -weight 1

  pack \
    .l1wid.bf45.p \
    .l1wid.bf45.sc \
    .l1wid.bf45.q \
    .l1wid.bf45.r \
    -side top -fill x -expand 1

  grid .l1wid.bf4 -sticky ew
  grid .l1wid.bf45 -pady 3 -sticky ew
  grid columnconfigure .l1wid 0 -weight 1


  proc send_latlon_to_l1pro {minlon maxlon minlat maxlat utmarg} {
    global mnlon mxlon mnlat mxlat utm
    set mnlon $minlon
    set mxlon $maxlon
    set mnlat $minlat
    set mxlat $maxlat
    set utm $armarg
  }


  proc send_rnarr_to_l1pro {bstart bstop brnindx} {
    global start stop list lrnindx
    set start $bstart
    set stop $bstop
    set rnindx $brnindx
    set list1 [concat $start $stop]
    if {[llength $list] == 0} {
      set list $list1
      set lrnindx $rnindx
    } else {
      set list [concat $list $list1 ]
      set lrnindx [concat $lrnindx $rnindx]
    }
  }

  proc display_data {} {
    set cmd "display_data, $::pro_var"
    append cmd ", mode=\"[lindex {fs ba de be fint lint ch} [display_type]]\""
    if {$::skip > 1} {
      append cmd ", skip=$::skip"
    }
    append cmd ", msize=$::plot_settings(msize)"
    append cmd ", marker=$::plot_settings(mtype)"
    append cmd ", win=$::win_no"
    if {! $::l1pro_square_limits} {
      append cmd ", square=0"
    }
    if {$::l1pro_cbar} {
      append cmd ", showcbar=1"
    }
    if {$::l1pro_fma} {
      append cmd ", dofma=1"
    }
    append cmd ", cmin=$::plot_settings(cmin)"
    append cmd ", cmax=$::plot_settings(cmax)"

    exp_send "$cmd;\r"
  }

  proc limits_tool {} {
    # Added by Jeremy Bracone 4/15/05
    # Opens a limits tool that makes a few functions a little quicker to perform.
    # The main function it provides is to set the limits from one window equal to
    # another.
    destroy .limitstool
    toplevel .limitstool
    wm title .limitstool "Limits Tool"
    frame .limitstool.1 -relief groove -bd 4
    label .limitstool.1.t1 -text "Apply limits from window "
    ::misc::combobox .limitstool.1.c1 -text 0 -width 3 -state readonly \
      -values [::struct::list iota 64] \
      -takefocus 0
    label .limitstool.1.t2 -text " to window "
    ::misc::combobox .limitstool.1.c2 -text 0 -width 3 -state readonly \
      -values [::struct::list iota 64] \
      -takefocus 0

    Button .limitstool.1.limits -text "Set Limits" \
      -helptext "Set Limits in window from box 2 equal to limits in window from\
        box 1.\
        \ni.e. Make the second window look like the first." \
      -command {
        set window1 [.limitstool.1.c1 getvalue]
        set window2 [.limitstool.1.c2 getvalue]
        if {$window1 >= 0 && $window2 >= 0} {
          #This function provided by l1pro.i
          exp_send "winlimits($window1,$window2); \r"
        }
      }

    frame .limitstool.2
    Button .limitstool.2.l -text "Limits()" \
      -helptext "Set current window limits to view entire plot" \
      -command {
        exp_send "limits\r"
        expect ">"
      }
    Button .limitstool.2.dismiss -text "Dismiss" -command {
      destroy .limitstool
    }
    pack .limitstool.1 -side top
    pack .limitstool.1.t1 .limitstool.1.c1 .limitstool.1.t2 .limitstool.1.c2 \
      .limitstool.1.limits -side left
    pack .limitstool.2 -side right
    pack .limitstool.2.dismiss .limitstool.2.l -padx 4 -side right
  }

  proc ycbar { } {
    global cdelta plot_settings
    if { ![ info exists plot_settings(cmax) ] } {
      set plot_settings(cmax) 0
      set plot_settings(cmin) 0
      set cdelta 0
    }
    exp_send "cbar.cmax=$plot_settings(cmax);\
      cbar.cmin=$plot_settings(cmin);\
      cbar.cdelta=$cdelta;\r"
  }
}

source "$src_path/plot.ytk"
source "$src_path/bathctl.ytk"
source "$src_path/data_segments.ytk"
source "$src_path/pixelwf.ytk"
