# vim: set tabstop=2 softtabstop=2 shiftwidth=2 autoindent shiftround expandtab:
#
# Orginal Amar Nayegandhi aka "anayegan"
#
# For info on using the Bwidget NoteBoook see:  http://mini.net/tcl/2298
#

# plot_settings
# var_settings

package require BWidget
package require Tktable
package require struct::list
package require struct::set
package require misc
package require mixin
package require tooltip
package require l1pro::deprecated
package require l1pro::main
package require l1pro::dirload
package require l1pro::vars
package require l1pro::file
package require l1pro::tools
package require l1pro::settings
package require l1pro::drast
package require l1pro::ascii
package require l1pro::processing

if {![winfo exists .l1wid]} {
  set l1pro_data(processing_mode) [list \
    "First Return Topo" \
    "Submerged Topo" \
    "Topo Under Veg" \
    "Multi Peak Veg" \
    "Direct. Wave Spectra" \
  ]

  set l1pro_data(display_types) [list \
    "First Return Topography" \
    "Submerged Topography" \
    "Water Depth" \
    "Bare Earth Topography" \
    "Surface Amplitude" \
    "Bottom Amplitude" \
    "Canopy Height" \
  ]

  set _l1pro_processing_mode [lindex $l1pro_data(processing_mode) 0]
  set ofname ""
  set curvar ""
  set outvar ""
  set win_no 5
  set win_load 6;    # used by EAARL Data Loader
  set usecentroid 1

  set cbar_locked cdelta

  set list {}
  set lrnindx {}
  set write_some 0
  set ssvar "*.pbd"
  set avg_surf 1
  set rcf_buf_rgn 0; #Used in proc replace_proc
  set autoclean_after_process 1
  set l1pro_fma 0

  set gridtype grid

  set data_file_path ""

  set varlist {fs_all depth_all veg_all cveg_all workdata}

  set cdelta 80
  set var_common [list \
    win_no 5 \
    cmin -40 \
    cmax 40 \
    msize 1.0 \
    mtype 1]

  set var_settings(fs_all) [linsert $var_common end \
    var fs_all \
    processing_mode "First Return Topo" \
    display_type "First Return Topography"]

  set var_settings(depth_all) [linsert $var_common end \
    var depth_all \
    processing_mode "Submerged Topo" \
    display_type "Submerged Topography"]

  set var_settings(veg_all) [linsert $var_common end \
    var veg_all \
    processing_mode "Topo Under Veg" \
    display_type "Bare Earth Topography"]

  set var_settings(cveg_all) [linsert $var_common end \
    var cveg_all \
    processing_mode "Multi Peak Veg" \
    display_type "First Return Topography"]

  set var_settings(workdata) [linsert $var_common end \
    var workdata \
    processing_mode "Submerged Topo" \
    display_type "Submerged Topography"]

  set pro_var fs_all
  set pro_var_next fs_all
  array set plot_settings $var_settings($pro_var)

  set plot_dpi 75
  array set cbvc {cmin cmin cmax cmax msize msize mtype mtype}

  set cbv 0
  set cbvc(cmin) $plot_settings(cmin)
  set cbvc(cmax) $plot_settings(cmax)
  set cbvc(msize) $plot_settings(msize)
  set cbvc(mtype) $plot_settings(mtype)

  set constant_win_no 0
  set l1pro_square_limits 1

  #load all yorick support functions
  ybkg require \"l1pro.i\"

  toplevel .l1wid
  wm withdraw .l1wid
  wm protocol .l1wid WM_DELETE_WINDOW {
    wm withdraw .l1wid
  }
  wm resizable .l1wid 1 0

  wm title .l1wid "Process EAARL Data"
  LabelFrame .l1wid.filter -relief groove -borderwidth 7 -text "FILTER:"

  .l1wid configure -menu .l1wid.mb
  menu .l1wid.mb
  menu .l1wid.mb.file
  menu .l1wid.mb.mission
  menu .l1wid.mb.graph
  menu .l1wid.mb.util
  menu .l1wid.mb.cmd
  menu .l1wid.mb.dep


  .l1wid.mb add cascade -label File -underline 0 -menu .l1wid.mb.file
  .l1wid.mb.file add command -label "Load ALPS data..." \
    -underline 0 -command ::l1pro::file::load_pbd
  .l1wid.mb.file add command -label "Save ALPS data..." \
    -underline 0 -command ::l1pro::file::save_pbd

  .l1wid.mb.file add separator

  .l1wid.mb.file add command -label "Load ALPS data as..." \
    -underline 15 -command ::l1pro::file::load_pbd_as
  .l1wid.mb.file add command -label "Load ALPS data directory..." \
    -underline 10 -command ::l1pro::dirload
  .l1wid.mb.file add command -label "Save ALPS data as..." \
    -underline 0 -command ::l1pro::file::save_pbd_as

  .l1wid.mb.file add separator

  .l1wid.mb.file add command -label "Import ASPRS LAS..." \
    -underline 0 -command ::l1pro::file::load_las

  .l1wid.mb.file add command -label "Import ASCII..." \
    -underline 1 -command ::l1pro::ascii::launch

  .l1wid.mb.file add command -label "Export ASCII..." \
    -underline 1 -command ::l1pro::file::export_ascii

  .l1wid.mb.file add separator

  menu .l1wid.mb.file.vars
  .l1wid.mb.file add cascade -label "Variables..." -underline 0 -menu .l1wid.mb.file.vars
  .l1wid.mb.file.vars add command -label "Load from file..." \
    -command ::l1pro::vars::load_from_file
  .l1wid.mb.file.vars add command -label "Save to file..." \
    -command ::l1pro::vars::save_to_file

  .l1wid.mb.file add command -label "Capture a display..." -command scap \
    -underline 0
  .l1wid.mb.file add separator
  .l1wid.mb.file add command -label "Dismiss" -underline 0 \
    -command {wm withdraw .l1wid}

  .eaarl.mb clone .l1wid.mb.eaarl menubar
  .l1wid.mb add cascade -label EAARL -underline 0 -menu .l1wid.mb.eaarl

  .l1wid.mb add cascade -label "Mission" -underline 0 -menu .l1wid.mb.mission
  .l1wid.mb.mission add command -label "Mission configuration manager" \
    -underline 0 -command ::mission::launch_gui
  .l1wid.mb.mission add command -label "Plotting tool" -underline 0 \
    -command ::plot::menu
  .l1wid.mb.mission add separator
  .l1wid.mb.mission add command -label "Load TANS Data .. " -underline 5 \
    -command {exp_send "tans = rbtans();\r"}
  .l1wid.mb.mission  add command -label "Load DMARS PBD Data .. " -underline 5 \
    -command load_dmars

  .l1wid.mb.mission add command -label "Load PNAV Data .. " -underline 5 \
    -command {exp_send "pnav = rbpnav(); \r"}

  .l1wid.mb.mission add command -label "Load Ops_conf Settings..." -underline 5 \
    -command load_ops_conf

  .l1wid.mb.mission add command -label "Load Bathymetry Settings .." -underline 21 \
    -command bathctl::gui

  .l1wid.mb.mission add separator
  .l1wid.mb.mission add command -label "Configure ops_conf..." -underline 0 \
    -command ::l1pro::settings::ops_conf::gui
  .l1wid.mb.mission add command -label "Save ops_conf..." -underline 0 \
    -command ::l1pro::settings::ops_conf::save

  namespace eval varplot {
    namespace eval v {
      variable win .varplot
      variable lb ""
      variable var_add ""
      variable fixed_vars [list fs_all depth_all veg_all cveg_all]
    }
  }

  proc varplot::gui {} {
    set w $v::win
    destroy $w
    toplevel $w
    wm title $w "List"

    set f $w
    set v::lb $f.slbVars
    iwidgets::scrolledlistbox $v::lb \
      -width 12 -listvariable ::varlist \
      -hscrollmode dynamic -vscrollmode dynamic \
      -selectmode extended \
      -scrollmargin 0 -sbwidth 10

    button $f.btnSelect -text "Select" -command ::varplot::cmd_select
    LabelEntry $f.lbeAdd -width 8 -relief sunken -label "Add:" \
      -helptext "Add variable name to list" \
      -textvariable ::varplot::v::var_add
    $f.lbeAdd bind <Return> ::varplot::bind_add_enter
    button $f.btnDelete -text "Delete" -command ::varplot::cmd_delete
    button $f.btnRename -text "Rename" -command ::varplot::cmd_rename
    button $f.btnDismiss -text "Dismiss" -command [list destroy $v::win]

    grid $v::lb -sticky news
    grid $f.btnSelect -sticky news
    grid $f.lbeAdd -sticky news
    grid $f.btnDelete -sticky news
    grid $f.btnRename -sticky news
    grid $f.btnDismiss -sticky news

    grid columnconfigure $f 0 -weight 1 -minsize 110
    grid rowconfigure $f 0 -weight 1 -minsize 200
  }

  proc varplot::cmd_select {} {
    set selected [$v::lb getcurselection]
    if {[llength $selected] == 1} {
      set ::pro_var [lindex $selected 0]
    } elseif {[llength $selected] > 1} {
      tk_messageBox -icon warning -type ok \
        -message "You cannot select multiple variables. Select only one."
    }
  }

  proc varplot::bind_add_enter {} {
    append_varlist $v::var_add
    set v::var_add ""
  }

  proc varplot::cmd_delete {} {
    set selected [$v::lb getcurselection]

    ::struct::list split $selected [list ::struct::set contains $v::fixed_vars] \
      pass fail

    if {[llength $pass]} {
      set this_variable [this_variable [llength $pass]]
      tk_messageBox -icon warning -type ok \
        -message "Aborting. You cannot delete ${this_variable}: $pass"
    } else {
      ::struct::list split $::varlist [list ::struct::set contains $selected] \
        pass fail

      set this_variable [this_variable [llength $pass]]
      set response [tk_messageBox -icon question -type yesno -title Warning \
        -message "Are you sure you want to delete ${this_variable}?\n$pass"]

      if {$response eq "yes"} {
        foreach var $pass {
          exp_send "$var = \[\];\r"
        }
        set ::varlist $fail
      }
    }
  }

  proc varplot::cmd_rename {} {
    set selected [$v::lb getcurselection]

    ::struct::list split $selected [list ::struct::set contains $v::fixed_vars] \
      pass fail

    if {[llength $pass]} {
      set this_variable [this_variable [llength $pass]]
      tk_messageBox -icon warning -type ok \
        -message "Aborting. You cannot delete ${this_variable}: $pass"
    } else {
      ::struct::list split $::varlist [list ::struct::set contains $selected] \
        pass fail

      if {[llength $pass] == 1} {
        set old [lindex $pass 0]
        set new $old
        set prompt "What would you like to rename '$old' to?"
        if {[::getstring::tk_getString $v::win.gs new $prompt]} {
          if {$old ne $new} {
            exp_send "eq_nocopy, $new, $old; $old = \[\];\r"
            set idx [lsearch -exact $::varlist $old]
            set ::varlist [lreplace $::varlist $idx $idx $new]
            if {[info exists ::plot_settings($old)]} {
              if {![info exists ::plot_settings($new)]} {
                set ::plot_settings($new) $::plot_settings($old)
              }
            }
            if {$::pro_var eq $old} {
              set ::pro_var $new
            }
          }
        }
      } else {
        tk_messageBox -icon warning -type ok -title Warning \
          -message "You cannot rename multiple variables at once. Select only one."
      }
    }
  }

  proc varplot::this_variable count {
    # Utility function that returns "this variable" or "these variables"
    # depending on the count given.
    return [lindex [list "this variable" "these variables"] [expr {$count > 1}]]
  }

  proc append_varlist {newvar} {
    global varlist
    if {[lsearch -exact $varlist $newvar] == -1} {
      lappend varlist $newvar
      init_var_settings $newvar
    }
  }

  proc make_selected_arrays {} {
    global lrnindx list
    set curlist [.l1plot.1.lb curselection]
    set ptype [processing_mode]
    if {$ptype == 0} {
      exp_send "fs_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {($lidx != "")} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, fs_some, fs_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, fs_some, fs_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
    if {$ptype == 1} {
      exp_send "depth_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {$lidx != ""} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, depth_some, depth_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, depth_some, depth_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
    if {$ptype == 2} {
      exp_send "veg_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {$lidx != ""} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, veg_some, veg_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, veg_some, veg_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
    if {$ptype == 3} {
      exp_send "cveg_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {$lidx != ""} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, cveg_some, cveg_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, cveg_some, cveg_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
  }

  .l1wid.mb   add cascade -label Graph -underline 0 -menu .l1wid.mb.graph
  .l1wid.mb.graph add command -label "Open the Limits Tool" -underline 0 \
    -command limits_tool
  .l1wid.mb.graph add separator
  .l1wid.mb.graph add command -label "Change current window to 75 DPI / 450x450" \
    -command [list exp_send "change_window_size, window(), 1, 0;\r"]
  .l1wid.mb.graph add command -label "Change current window to 100 DPI / 600x600" \
    -command [list exp_send "change_window_size, window(), 2, 0;\r"]
  .l1wid.mb.graph add command -label "Change current window to 75 DPI / 825x638" \
    -command [list exp_send "change_window_size, window(), 3, 0;\r"]
  .l1wid.mb.graph add command -label "Change current window to 100 DPI / 1100x850" \
    -command [list exp_send "change_window_size, window(), 4, 0;\r"]
  .l1wid.mb.graph add separator
  menu .l1wid.mb.graph.pal
  .l1wid.mb.graph add cascade -label Palette... -under 0 -menu .l1wid.mb.graph.pal
  foreach __p [list earth stern rainbow yarg heat gray] {
  .l1wid.mb.graph.pal add command -label $__p -under 0 -command [list ypalette $__p]
  }
  unset __p

  proc ypalette p {
    exp_send "palette, \"${p}.gp\";\r"
    expect "> "
  }

  .l1wid.mb add cascade -label Utilities -underline 0 -menu .l1wid.mb.util

  .l1wid.mb.util add command -label "Pixel Analysis" \
    -command [list ::pixelwf::gui::launch_full_panel .pixelwf]

  .l1wid.mb.util add command -label "Histogram Elevations" \
    -command ::l1pro::tools::histelev::gui

  .l1wid.mb.util add separator

  .l1wid.mb.util add command -label "Transect Tool" \
    -command [list source [file join $src_path transrch.ytk]]

  menu .l1wid.mb.util.seg
  .l1wid.mb.util add cascade -label "Launch segments by..." -menu .l1wid.mb.util.seg
  .l1wid.mb.util.seg add command -label "Flightline" \
    -command [list segment_data_launcher fltlines]
  .l1wid.mb.util.seg add command -label "Flightline and digitizer" \
    -command [list segment_data_launcher fltlines_digitizer]
  .l1wid.mb.util.seg add command -label "Day" \
    -command [list segment_data_launcher days]
  .l1wid.mb.util.seg add command -label "Day and digitizer" \
    -command [list segment_data_launcher days_digitizer]
  .l1wid.mb.util.seg add command -label "Manual selection" \
    -command select_data_segments

  menu .l1wid.mb.util.stat
  .l1wid.mb.util add cascade -label "Launch statistics by..." \
    -menu .l1wid.mb.util.stat
  .l1wid.mb.util.stat add command -label "Flightline" \
    -command [list segment_stat_launcher fltlines]
  .l1wid.mb.util.stat add command -label "Flightline and digitizer" \
    -command [list segment_stat_launcher fltlines_digitizer]
  .l1wid.mb.util.stat add command -label "Day" \
    -command [list segment_stat_launcher days]
  .l1wid.mb.util.stat add command -label "Day and digitizer" \
    -command [list segment_stat_launcher days_digitizer]

  .l1wid.mb.util add command -label "Open Fit Gaussian GUI" \
    -command open_fit_gaussian_gui
  .l1wid.mb.util add command -label "Determine Roll Bias" -underline 0 \
    -command determine_roll_bias
  .l1wid.mb.util add command -label "Browse Rasters" -underline 7 \
    -command ::l1pro::drast::gui
  .l1wid.mb.util add separator
  .l1wid.mb.util add command \
    -label "Show Flightlines with No Raster Data..." -underline 25 \
    -command {exp_send "plot_no_raster_fltlines(gga, edb);\r"}
  .l1wid.mb.util add command -label "Show Flightlines with No TANS Data..." \
    -underline 25 \
    -command {exp_send "plot_no_tans_fltlines(tans, gga);\r"}


  proc determine_roll_bias {} {
      global win_no varlist bias pro_var

      destroy .l1bias
      toplevel .l1bias
      wm title .l1bias "Determine Roll Bias"

      foreach x {1 2 3 4 5 6} {
        frame .l1bias.$x
        pack .l1bias.$x -side top
      }

      if { [info exists bias ] == 0 } {
        exp_send "updatebias\r"
        expect ">"
        exp_send "updatebias\r"
        expect ">"
      }
      set slope 0
      set inout 1
      set width 5
      set flwin 4
      set var $pro_var

      LabelEntry .l1bias.1.var -relief sunken -borderwidth 3 -width 10 \
        -label "Variable:" -helptext "EAARL source data" \
        -textvariable var -text $var

      Label .l1bias.1.winl -text "in window:"
      spinbox .l1bias.1.win -justify center -width 2 \
        -textvariable win_no -from 0 -to 63 -increment 1

      Label .l1bias.1.transl -text "Then click"
      Button .l1bias.1.transbutton -text "Get Transect" \
        -helptext "Click to get transect" \
        -command {
          exp_send "transdata = get_transect($var, win=$win_no, update=1,\
            width=$width)\r"
          expect ">"
          .l1bias.3.plot configure -state normal
          .l1bias.3.winl configure -state normal
          .l1bias.3.win configure -state normal
          .l1bias.3.pick configure -state normal
          .l1bias.3.inout configure -state normal
          .l1bias.3.auto configure -state normal
        }

      Button .l1bias.1.help -text "Help!" -helptext "Click for directions" \
        -command {
          tk_messageBox -icon warning \
            -message "1) Start with data array plotted in a window and raw EAARL\
              data loaded. Set the variable and window and click Get Transect.\
              \r2) Drag a line perpendicular to the flightlines you wish to\
              examine. In the window that appears, zoom into the top, type\
              something, and hit enter. Now drag a box over the section of the\
              transect you wish to keep.\
              \r3) Click the plot button to display the loaded transect. In\
              order to determine the bias automatically all flightlines must be\
              traveling the same direction, so you'll need to remove whichever\
              direction is the minority.\
              \r4) Click 'select flightlines' and simply type 'y' or 'n' to keep\
              or remove each flightline. Now you have a set of flightlines going\
              the same direction.\
              \r5) Finally, determine whether the flightlines are going into or\
              out of the screen. If they are going INTO the screen, check the\
              box." \
            -type ok
        }

      LabelEntry .l1bias.2.width -relief sunken -width 3 \
        -label "Width:" -helptext "Transect width" \
        -textvariable width -text $width

      LabelEntry .l1bias.2.bias -relief sunken -width 10 \
        -label "Current Roll Bias:" -helptext "Current Roll Bias" \
        -textvariable bias -text $bias

      LabelEntry .l1bias.2.slope -relief sunken -width 10 \
        -label "Current Slope:" -helptext "Current slope" \
        -textvariable slope -text $slope

      Button .l1bias.3.plot -text "Plot" \
        -helptext "Click to plot flightline transect" \
        -command {exp_send "plot_flightline_transect(transdata, $flwin)\r"}

      Label .l1bias.3.winl -text "in win:"
      spinbox .l1bias.3.win -justify center \
        -width 2 -textvariable flwin -from 0 -to 63 -increment 1

      Button .l1bias.3.pick -text "Select Flightlines" \
        -helptext "Click to select which flightlines to keep" \
        -command {exp_send "transdata=selgoodflightlines(transdata, win=$flwin)\r"}

      checkbutton .l1bias.3.inout -text "in/out:" \
        -variable inout -onvalue -1 -offvalue 1

      Button .l1bias.3.auto -text "Determine bias" \
        -helptext "Click to automatically determine roll bias" \
        -command {exp_send "goodroll=find_roll_bias(transdata,0,$inout,update=1)\r"}

      pack .l1bias.1.var .l1bias.1.winl .l1bias.1.win .l1bias.1.transl \
        .l1bias.1.transbutton .l1bias.1.help -side left
      pack .l1bias.2.width .l1bias.2.bias .l1bias.2.slope -side left
      pack .l1bias.3.plot .l1bias.3.winl .l1bias.3.win .l1bias.3.pick \
        .l1bias.3.inout .l1bias.3.auto -side left

      foreach w {plot winl win pick inout auto} {
        .l1bias.3.$w configure -state disabled
      }
    }

  .l1wid.mb add cascade -label CmdLine -underline 1 -menu .l1wid.mb.cmd
  foreach ycmd {
    mtransect batch_process mbatch_process batch_merge_tiles new_batch_rcf
    batch_rcf batch_datum_convert batch_veg_lfpw batch_pbd2edf batch_pbd2las
    batch_las2pbd batch_write_xyz batch_convert_ascii2pbd batch_tile
  } {
    .l1wid.mb.cmd add command -label $ycmd \
      -command [list exp_send "help, $ycmd\r"]
  }

  .l1wid.mb add cascade -label Deprecated -underline 1 -menu .l1wid.mb.dep

  .l1wid.mb.dep add command -label "Old Pixel Waveform" \
    -command ::l1pro::deprecated::pixelwf

  .l1wid.mb.dep add checkbutton \
    -label "Show raw and processed waveforms when using Pixel Waveform" \
    -variable bconst

  .l1wid.mb.dep add separator

  ### DEPRECATED 2009-12-22 ###
  # Replaced by "Read PBD Data Directory..." and "Read Binary Data (edf/bin)
  # Directory..." entries, supported by l1pro::dirload.
  .l1wid.mb.dep add command -label "Old Read Data Directory..." \
    -underline 10 -command ::l1pro::deprecated::l1dir::gui

  ### DEPRECATED 2009-02-02 ###
  # This menu entry and its code are deprecated. They have been replaced by the
  # code in namespace l1dir, which is invoked from the non-deprecated
  # "Read Data Directory..." menu entry above it.
  .l1wid.mb.dep add command -label "Even Older Read Data Directory..." \
    -command ::l1pro::deprecated::read_data_dir_older

  .l1wid.mb.dep add separator

  ### DEPRECATED 2010-01-03 ###
  # Following entries replaced by file-1.0.tm functionality.
  .l1wid.mb.dep add command -label "Read Binary Data file..." -underline 0 \
    -command ::l1pro::deprecated::read_binary_data_file
  .l1wid.mb.dep add command -label "Write Binary Data File..." -underline 0 \
    -command ::l1pro::deprecated::write_binary_data_file
  .l1wid.mb.dep add command -label "Read SubSampled Data File..." -underline 5 \
    -command ::l1pro::deprecated::read_subsampled_data_file
  .l1wid.mb.dep add command -label "Load EAARL data from map limits" \
    -underline 21 \
    -command ::l1pro::deprecated::load_eaarl_data_from_map_limits
  .l1wid.mb.dep add command -label "Ascii output ..." -underline 0 \
    -command ::l1pro::deprecated::ascii_output

  .l1wid.mb.dep add separator

  .l1wid.mb.dep add command -label "Configure elevation scale limits..." \
    -underline 0 \
    -command ::l1pro::deprecated::configure_elevation_scale_limits

  .l1wid.mb.dep add command -label "Plot/Write Individual Flightlines..." \
    -underline 0 \
    -command ::l1pro::deprecated::plot_write_individual_flightlines

  .l1wid.mb.dep add command -label "Test and Clean" \
    -command {exp_send "$::pro_var = test_and_clean($::pro_var);\r"}

  .l1wid.mb.dep add command -label "Append2Tile" \
    -command ::l1pro::deprecated::append2tile
  .l1wid.mb.dep add command -label "Save Tile" \
    -command ::l1pro::deprecated::savetile

  .l1wid.mb.dep add command -label "Old RCF GUI" \
    -command ::l1pro::deprecated::rcf_region

  .l1wid.mb.dep add separator

  ### Deprecated 2009-02-02
  .l1wid.mb.dep add command -label "Flight Tracks & Coastlines..." \
    -command ::l1pro::deprecated::rbgga_menu

  proc open_fit_gaussian_gui {} {
    source [file join $::src_path fit_gauss.ytk]
    fit_gauss::create_gui
  }

  proc processing_mode {} {
    global plot_settings l1pro_data
    return [lsearch -exact $l1pro_data(processing_mode) \
      $plot_settings(processing_mode)]
  }

  proc processing_mode_changed {a b c} {
    global curs pro_var_next
    if {$b eq "processing_mode"} {
      set curs [processing_mode]
    }
    if {$pro_var_next in [list fs_all depth_all veg_all cveg_all]} {
      set pro_var_next [lindex {fs_all depth_all veg_all cveg_all {}} \
        [processing_mode]]
    }
  }

  trace remove \
    variable plot_settings(processing_mode) write processing_mode_changed
  trace add \
    variable plot_settings(processing_mode) write processing_mode_changed

  proc processing_mode_by_index {index} {
    global plot_settings l1pro_data
    set plot_settings(processing_mode) \
      [lindex $l1pro_data(processing_mode) $index]
  }

  proc init_var_settings {var args} {
    dict set ::var_settings($var) var $var
    set settings [array get ::plot_settings]
    foreach {key val} [array get ::plot_settings] {
      if {![dict exists $::var_settings($var) $key]} {
        dict set ::var_settings($var) $key $val
      }
    }
  }

  proc pro_var_changed {a b c} {
    global var_settings plot_settings pro_var cbv win_no constant_win_no
    init_var_settings $plot_settings(var)

    # Currently saved version -- to be replaced
    set stored $var_settings($plot_settings(var))

    # Update processing_mode and display_type
    dict set stored processing_mode $plot_settings(processing_mode)
    dict set stored display_type $plot_settings(display_type)

    # Update cbar if appropriate
    if {$cbv == 0} {
      foreach key {cmin cmax msize mtype} {
        dict set stored $key $plot_settings($key)
      }
    }

    # Update win_no if appropriate
    if {$constant_win_no == 0} {
      dict set stored win_no $win_no
    }

    # Replace saved version with new values
    set var_settings($plot_settings(var)) $stored

    # Load stored settings to be used
    if {[info exists var_settings($pro_var)]} {
      set stored $var_settings($pro_var)
    } else {
      set stored [array get plot_settings]
    }

    # Update processing_mode and display_type
    set plot_settings(var) $pro_var
    set plot_settings(processing_mode) [dict get $stored processing_mode]
    set plot_settings(display_type) [dict get $stored display_type]

    # Update cbar if appropriate
    if {$cbv == 0} {
      foreach key {cmin cmax msize mtype} {
        set plot_settings($key) [dict get $stored $key]
      }
    }

    # Update win_no if appropriate
    if {$constant_win_no == 0} {
      set plot_settings(win_no) [dict get $stored win_no]
      set win_no $plot_settings(win_no)
    }
  }

  trace remove variable pro_var write pro_var_changed
  trace add variable pro_var write pro_var_changed

  proc display_type {} {
    global plot_settings
    switch -- $plot_settings(display_type) {
      "First Return Topography" {
        return 0
      }
      "Submerged Topography" {
        return 1
      }
      "Water Depth" {
        return 2
      }
      "Bare Earth Topography" {
        return 3
      }
      "Surface Amplitude" {
        return 4
      }
      "Bottom Amplitude" {
        return 5
      }
      "Canopy Height" {
        return 6
      }
      default {
        return -1
      }
    }
  }

  proc display_type_mode {} {
    return [lindex {fs ba de be fint lint ch} [display_type]]
  }

  proc display_type_by_index {index} {
    global plot_settings l1pro_data
    set plot_settings(display_type) \
      [lindex $l1pro_data(display_types) $index]
  }

  ::mixin::combobox .l1wid.filter.1 -text "Copy points using..." -width 16 \
    -state readonly \
    -values [list "Rubberband Box" "Points in Polygon" "Single Pixel" \
      "Select Cell/Quad/Tile"] \
    -modifycmd {
      global varlist pro_var

      set selr [.l1wid.filter.1 getvalue]
      if {$selr == 0} {
        set selection [tk_messageBox -icon info \
          -message "Drag a Rectangular Box in Window $win_no to define region." \
          -type okcancel -title "Message"]
        if {$selection == "ok"} {
          exp_send "workdata = sel_data_rgn($::pro_var, mode=2, win=$win_no)\r"
          expect ">"
        }
      }
      if {$selr == 1} {
        set selection  [tk_messageBox -icon info \
          -message "Draw a Polygon in Window $win_no to define a region using a\
            series of left mouse clicks.  To complete the polygon, middle mouse\
            click OR <Ctrl> and left mouse click." \
          -type okcancel -title "Message" ]
        if {$selection == "ok"} {
          exp_send "workdata = sel_data_rgn($::pro_var, mode=3, win=$win_no)\r"
          expect ">"
        }
      }
      if {$selr == 2} {
        exp_send "workdata = select_points($::pro_var, win=$win_no);\r"
        expect ">"
      }
      if {$selr == 3} {
        set selection [tk_messageBox -icon info \
          -message "Select a cell (250m by 250m) region by dragging a region in\
            window $win_no within the required cell."\
          -type okcancel -title "Message" ]
        if {$selection == "ok"} {
          exp_send "workdata = select_region_tile($::pro_var, win=$win_no, plot=1);\r"
          expect ">"
        }
      }
      if {$selr == -1} {
        error "Please Define Region."
      }
      append_varlist workdata
    }
  ::tooltip::tooltip .l1wid.filter.1 \
    "Copy points to 'workdata' using any of the following methods:\
     \n  Rubberband Box\
     \n  Points in Polygon\
     \n  Single Pixel"

  ::mixin::combobox .l1wid.filter.7 -text "Filter tools..." -width 16 \
    -values [list Keep Remove Replace] \
    -state readonly \
    -modifycmd {
      global varlist
      switch -- [.l1wid.filter.7 getvalue] {
        0 keep_proc
        1 removing_proc
        2 replace_proc
        default {error "Please Define Region."}
      }
    }
  ::tooltip::tooltip .l1wid.filter.7 "Choose any of the following tools:"

  proc removing_proc {} {
    global varlist rmv_var plot_settings pro_var
    destroy .rem
    toplevel .rem
    frame .rem.05
    frame .rem.07 -relief raised -bd 1
    frame .rem.08 -relief raised -bd 1
    frame .rem.09
    wm title .rem "Remove Points Using..."
    Label .rem.05.varname -text "Input Variable:"

    ::mixin::combobox .rem.05.varlist \
      -textvariable ::rmv_var -state readonly \
      -listvariable ::varlist
    set rmv_var $pro_var

    frame .rem.06
    Label .rem.06.typetext -text "Data type:"
    # IMPORTANT NOTE: Do not change the order of GEO and VEG__ for the values of
    # the combobox below. A function parameter for the pipthresh function for
    # this gui is dependent on the index number of the selection.
    ::mixin::combobox .rem.06.type -textvariable remove_type -width 12 \
      -values [list "GEO or VEG__" "FS"]
    if {[display_type] == 0} {
      .rem.06.type setvalue @1
    } else {
      .rem.06.type setvalue @0
    }

    ::mixin::combobox .rem.1 -width 18 -state readonly \
      -text "Remove points using..." \
      -values [list "Rubberband Box" "Points in Polygon" "Single Pixel" \
        "Pip-Thresh"] \
      -modifycmd {
        set removemode [.rem.1 getvalue]
        if {$removemode == 3} {
          pack forget .rem.2 .rem.3 .rem.4
          pack .rem.08 .rem.07
          pack .rem.07.a .rem.07.min .rem.07.minthresh -side left
          pack .rem.08.a .rem.08.max .rem.08.maxthresh -side left
          pack .rem.09 .rem.09.a
          pack .rem.2 .rem.3 -side left -padx 5 -pady 5
          set min_thresh $plot_settings(cmin)
          set max_thresh $plot_settings(cmax)
        } else {
          pack forget .rem.2 .rem.3 .rem.4
          pack forget .rem.07 .rem.08 .rem.09
          pack .rem.2 .rem.3 .rem.4 -side left -padx 5 -pady 5
        }
      }
    ::tooltip::tooltip .rem.1 \
      "Remove points from 'workdata' using any of the following methods:\
      \n  Rubberband Box\
      \n  Points in Polygon\
      \n  Single Pixel"
    Label .rem.07.a -text "Min. Threshold:"
    Label .rem.08.a -text "Max. Threshold:"
    Label .rem.09.a -text "WARNING: Cannot undo action." -justify center
    checkbutton .rem.07.min -variable min \
      -command {
        set state [lindex {disabled normal} $min]
        .rem.07.minthresh configure -state $state
      }
    checkbutton .rem.08.max -variable max \
      -command {
        set state [lindex {disabled normal} $max]
        .rem.08.maxthresh configure -state $state
      }
    spinbox .rem.07.minthresh -textvariable min_thresh -width 10 \
      -from -100 -to 5000 -increment 0.1 -format %.2f
    spinbox .rem.08.maxthresh -textvariable max_thresh -width 10 \
      -from -100 -to 5000 -increment 0.1 -format %.2f
    set min 1
    set max 1
    .rem.07.min select
    .rem.08.max select
    set min_thresh $plot_settings(cmin)
    set max_thresh $plot_settings(cmax)

    Button .rem.2 -width 8 -text "Go" \
      -command {
        global varlist outvar selr rmv_var pro_var

        set selr [.rem.1 getvalue]
        if {$selr == 0} {
          set var_type $pro_var
          set selection [tk_messageBox -icon info \
            -message "Drag a Rectangular Box in Window $win_no to define a\
              region." \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            exp_send "croppeddata=\[\];\
              $rmv_var = sel_data_rgn($rmv_var, mode=2, win=$win_no, exclude=1)\r"
            expect ">"
          }
        }
        if {$selr == 1} {
          set selection  [tk_messageBox  -icon info \
            -message "Draw a Polygon in Window $win_no to define a region using\
              a series of left mouse clicks. To complete the polygon, middle\
              mouse click OR <Ctrl> and left mouse click." \
            -type okcancel -title "Message" ]
          if {$selection == "ok"} {
            exp_send "croppeddata=\[\];\
              $rmv_var = sel_data_rgn($rmv_var, mode=3, win=$win_no, exclude=1)\r"
            expect ">"
          }
        }
        if {$selr == 2} {
          set selection [tk_messageBox  -icon info \
            -message "Select points to remove from window $win_no" \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            exp_send "croppeddata=\[\];\
              $rmv_var = select_points($rmv_var, win=$win_no, exclude=1);\r"
            expect ">"
          }
        }
        if {$selr == 3} {
          if {[.rem.06.type getvalue] == 1} {
            set val [.rem.06.type getvalue]
          } else {
            set val ""
          }
          if { $min == 0 && $max == 0 } {
            tk_messageBox -icon warning \
              -message "You have not set any threshold limits!" \
              -type ok -title "ERROR!"
          } else {
            # If we don't want to use a threshhold, we set it to void
            set min_arg [expr {$min ? $min_thresh : ""}]
            set max_arg [expr {$max ? $max_thresh : ""}]
            exp_send "croppeddata=\[\];\
              $rmv_var = pipthresh($rmv_var, mode=$val,\
                minthresh=$min_arg, maxthresh=$max_arg);\r"
          }
        }
        if {$selr == -1} {
          error "Please Define Region."
        } else {
          append_varlist $rmv_var
        }
      }
    Button .rem.3 -width 8 -text "Dismiss" -command {
      destroy .rem
    }
    Button .rem.4 -width 8 -text "Undo Last\nRemove" -command {
      exp_send "if(is_array(croppeddata))\
        $rmv_var = grow($rmv_var,croppeddata);\r"
      expect ">"
    }

    pack .rem.05.varname .rem.05.varlist -side left -padx 5
    pack .rem.06.typetext .rem.06.type -side left
    pack .rem.05 .rem.06 .rem.1 -pady 8
    pack .rem.08 .rem.07 .rem.09
    pack .rem.2 .rem.3 .rem.4 -side left -padx 5 -pady 5
  }

  proc keep_proc {} {
    global varlist keep_in_var keep_out_var pro_var
    destroy .sel
    toplevel .sel
    wm title .sel "Keep Points Using..."
    frame .sel.05

    Label .sel.05.varname -text "Input Variable:"
    ::mixin::combobox .sel.05.varlist \
      -textvariable ::keep_in_var -state readonly \
      -listvariable ::varlist
    set keep_in_var $pro_var

    ::mixin::combobox .sel.1 -state readonly -width 16 \
      -text "Keep points using..." \
      -values [list "Rubberband Box" "Points in Polygon" "Single Pixel"] \
      -modifycmd {
        global sels keep_in_var keep_out_var grow_keep
        set sels [.sel.1 getvalue]
        if {$sels == 2} {
          set grow_keep 1
          set keep_out_var "finaldata"
        } else {
          set keep_out_var $keep_in_var
        }
      }
    ::tooltip::tooltip .sel.1 \
      "Keep points from 'workdata' using any of the following methods:\
      \n  Rubberband Box\
      \n  Points in Polygon\
      \n  Single Pixel"

    checkbutton .sel.grow -text "Grow output variable" -variable grow_keep
    LabelEntry .sel.15 -relief sunken -label "Output Variable:" \
      -helptext "Define output variable" \
      -textvariable keep_out_var -text "workdata"

    Button .sel.2 -width 8 -text "Go" \
      -command {
        global varlist outvar sels keep_in_var keep_out_var pro_var

        set sels [.sel.1 getvalue]
        if {$sels == 0} {
          set var_type $pro_var
          set selection [tk_messageBox  -icon info \
            -message "Drag a Rectangular Box in Window $win_no to define\
              region." \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            if {$grow_keep == 0} {
              exp_send "$keep_out_var =\
                sel_data_rgn($keep_in_var, mode=2, win=$win_no)\r"
              expect ">"
            } else {
              exp_send "grow, $keep_out_var,\
                sel_data_rgn($keep_in_var, mode=2, win=$win_no);\r"
              expect ">"
            }
          }
        }
        if {$sels == 1} {
          set selection  [tk_messageBox  -icon info \
            -message "Draw a Polygon in Window $win_no to define a region using\
              a series of left mouse clicks.To complete the polygon, middle\
              mouse click OR <Ctrl> and left mouse click." \
            -type okcancel -title "Message" ]
          if {$selection == "ok"} {
            if {$grow_keep == 0} {
              exp_send "$keep_out_var =\
                sel_data_rgn($keep_in_var, mode=3, win=$win_no)\r"
              expect ">"
            } else {
              exp_send "grow, $keep_out_var,\
                sel_data_rgn($keep_in_var, mode=3, win=$win_no);\r"
              expect ">"
            }
          }
        }
        if {$sels == 2} {
          set selection [tk_messageBox  -icon info \
            -message "Select points to keep from window $win_no" \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            if {$grow_keep == 0} {
              exp_send "$keep_out_var =\
                select_points($keep_in_var, win=$win_no);\r"
              expect ">"
            } else {
              exp_send "grow, $keep_out_var,\
                select_points($keep_in_var, win=$win_no));\r"
              expect ">"
            }
          }
        }
        if {$sels == -1} {
          error "Please Define Region."
        } else {
          append_varlist $keep_out_var
        }
      }
    Button .sel.3 -width 8 -text "Dismiss" -command {
      destroy .sel
    }

    pack .sel.05.varname .sel.05.varlist -side left -padx 5
    pack .sel.05 .sel.1 .sel.grow .sel.15 -side top -pady 10
    pack .sel.2 .sel.3 -side left -padx 5 -pady 5
  }

  proc replace_proc {} {
    global varlist croppeddata have_replaced have_undone rcf_buf_rgn \
      pro_var replace_in_var replace_orig_var replace_out_var
    set have_undone 0
    set have_replaced 0
    destroy .rep
    toplevel .rep
    wm title .rep "Replace Points Using..."
    frame .rep.05
    frame .rep.005
    frame .rep.15

    set sameinput 0
    Label .rep.05.varname -text "Input Variable:"

    ::mixin::combobox .rep.05.varlist \
      -textvariable replace_in_var -state readonly \
      -listvariable ::varlist
    set replace_in_var $pro_var

    Label .rep.005.varname -text "Original Data Variable:"

    ::mixin::combobox .rep.005.varlist \
      -textvariable replace_orig_var -state readonly \
      -listvariable ::varlist
    set replace_orig_var $pro_var

    # Note: In code below, the yorick variables "croppeddata" and "workdata" are
    # created through sel_data_rgn
    #   croppeddata = (selected filtered points);
    #   workdata = (selected original data points);
    ::mixin::combobox .rep.1 -state readonly -width 28 \
      -text "Select points to replace using..." \
      -values [list "Rubberband Box" "Points in Polygon" "Window Limits"] \
      -modifycmd {
        set defr [.rep.1 getvalue]
        set sel_points buf_points
        set buffered_var bufferdata
        global rcf_buf_rgn
        if {$rcf_buf_rgn > 0} {
          if {$defr == 0} {
            set result [tk_messageBox  -icon info \
              -message "Drag a Rectangular Box in Window $win_no to define\
                region." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = $replace_in_var;\r"
              exp_send "$sel_points = mouse(1,1,\
                \"Hold the left mouse button down, select a region:\");"
              expect ">"
              exp_send "temp_rgn = add_buffer_rgn($sel_points,\
                $rcf_buf_rgn, mode=1);\r"
              expect ">"
              exp_send "workdata = sel_data_rgn($replace_orig_var, mode=4,\
                win=$win_no, rgn=temp_rgn);\r"
              expect ">"
            }
          } elseif {$defr == 1} {
            set result [tk_messageBox -icon info \
              -message "Draw a Polygon in Window $win_no to define a region\
                using a series of left mouse clicks. To complete the polygon,\
                middle mouse click OR <Ctrl> and left mouse click." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = $replace_in_var;\r"
              # For eval purposes, success stores if getPoly_add_buffer command
              # was successful. The yorick variables buf_points, temp_rgn, and
              # workdata are made.
              exp_send "success = getPoly_add_buffer($rcf_buf_rgn,\
                origdata=$replace_origvar, windw=$win_no);\r"
              expect ">"
            }
          } elseif {$defr == 2} {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = $replace_in_var;\r"
            exp_send "window, $win_no;\
              $sel_points=limits()(1:4);\
              temp_rgn = add_buffer_rgn($sel_points, $rcf_buf_rgn, mode=3);\r"
            expect ">"
            exp_send "workdata = sel_data_rgn($replace_orig_var, mode=4,\
              win=$win_no, rgn=temp_rgn);\r"
            expect ">"
          }
          set have_replaced 0
          set have_undone 0
        } else {
          if {$defr == 0} {
            set result [tk_messageBox  -icon info \
              -message "Drag a Rectangular Box in Window $win_no to define\
                region." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = sel_data_rgn($replace_in_var,\
                mode=2, win=$win_no, exclude=1, make_workdata=1,\
                origdata=$replace_orig_var);\r"
              expect ">"
              set have_replaced 0
              set have_undone 0
            }
          }
          if {$defr == 1} {
            set result [tk_messageBox  -icon info \
              -message "Draw a Polygon in Window $win_no to define a region\
                using a series of left mouse clicks. To complete the polygon,\
                middle mouse click OR <Ctrl> and left mouse click." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = sel_data_rgn($replace_in_var,\
                mode=3, win=$win_no, exclude=1, make_workdata=1,\
                origdata=$replace_orig_var);\r"
              expect ">"
              set have_replaced 0
              set have_undone 0
            }
          }
          if {$defr == 2} {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = sel_data_rgn($replace_in_var,\
              mode=1, win=$win_no, exclude=1, make_workdata=1,\
              origdata=$replace_orig_var);\r"
            set have_replaced 0
            set have_undone 0
          }
        #end if/else rcf_buf_rgn
        }
      }
    ::tooltip::tooltip .rep.1 \
      "Select points to replace using any of the following methods:\
      \n Rubberband Box\
      \n Points in Polygon\
      \n Window Limits.\
      \nSelected points from the original data array will be written\
      \nto variable \"workdata\"."

    Button .rep.type -text "Filter selected points" -width 15 -bd 5 \
      -command {
        global curvar have_replaced have_undone croppeddata outvar rcf_buf_rgn \
          sel_points
        set outvar workdata_grcf
        if {$have_undone == 1} {
          if {$rcf_buf_rgn > 0} {
            exp_send "workdata = tempdata;\r"
          } else {
            append_varlist $replace_out_var
            exp_send "$replace_out_var =\
              $replace_out_var (1: - numberof(croppeddata));\r"
          }
        } elseif {$have_replaced == 1} {
          if {$rcf_buf_rgn > 0} {
            exp_send "workdata = tempdata;\r"
          } else {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = $replace_out_var (1: - numberof($outvar));\r"
          }
        }
        ::l1pro::tools::rcf::gui -var workdata
        set have_replaced 0
        set have_undone 0
      }

    LabelEntry .rep.15.1 -relief sunken -label "Output Variable:" \
      -helptext "Define output variable" \
      -textvariable replace_out_var -text "finaldata"
    checkbutton .rep.15.2 -text "Same as input variable" -variable sameinput \
      -command {
        if {$sameinput == 1} {
          set replace_out_var $replace_in_var
          .rep.15.1 configure -state disabled
        } else {
          .rep.15.1 configure -state normal
        }
      }
    LabelEntry .rep.15.3 -relief sunken -label "Buffer Region (m):" -width 5 \
      -helptext "Define the amount of buffer used in filtering for the selected\
        points" \
      -textvariable rcf_buf_rgn -text "0"

    Button .rep.15.4 -text "Click \[HERE\] for info" -bd 0 \
      -command {
        tk_messageBox -icon info \
          -message "Points in the buffer region will be used for filtering, but\
            will not be replaced into the output array." \
          -type ok -title "Use a buffer region help"
      }

  # Significant change made by Jeremy Bracone 4/4/05
  # Do No Replace as been fixed and now acts as an undo while Replace acts as a
  # redo. Replace will put filtered data into output array, "Do Not Replace" will
  # put original data into output array. If a replace or "Do Not Replace" has
  # already been done, hitting replace or Do not will have no effect. If replace
  # or "Do Not Replace" has already been done, hitting one will undo the action
  # of the other and perform the expected operation; i.e. Replace was done, now
  # hit Do Not Replace and it will take out the data inserted in the Replace and
  # put in the original data. Same is true for opposite situation.
    Button .rep.2 -width 8 -text "Replace..." -bd 5 \
      -command {
        global varlist outvar reps keep_var curvar origvar have_replaced \
          have_undone croppeddata
        set $outvar workdata_grcf
        set selection [tk_messageBox -icon question \
          -message "Append array $outvar to $replace_out_var?" \
          -type yesno -title "Warning" ]
        if {$selection == "yes" && $have_replaced == 0 && $have_undone == 0} {
          if {$rcf_buf_rgn > 0} {
            # have to save workdata since sel_data_rgn with exclude set to 1 will
            # over-write it
            exp_send "tempdata = workdata;\r"
            exp_send "$replace_out_var = sel_data_rgn($replace_out_var,\
              mode=4, rgn=$sel_points, win=$win_no, exclude=1, make_workdata=1,\
              origdata=$replace_orig_var);\r"
            expect ">"
            # This is kind of confusing, but $outvar = workdata_grcf (love this
            # confuciated variable hiding)
            exp_send "workdata = tempdata;\
              $outvar = sel_data_rgn($outvar, mode=4, win=$win_no,\
                rgn=$sel_points);\r"
          }
          append_varlist $replace_out_var
          exp_send "$replace_out_var = grow($replace_out_var, $outvar);\r"
        }
        if {$selection == "yes" && $have_replaced == 0 && $have_undone == 1} {
          append_varlist $replace_out_var
          exp_send "$replace_out_var = $replace_out_var\
            (1: - numberof(croppeddata));\r"
          exp_send "$replace_out_var = grow($replace_out_var, $outvar);\r"
          set have_undone 0
        }
        expect ">"
        set have_replaced 1
      }
    Button .rep.4 -width 10 -text "Do Not Replace..." -bd 5 \
      -command {
        global varlist outvar reps replace_out_var curvar origvar
        set selection [tk_messageBox -icon question \
          -message "Append ORIGINAL cropped array croppeddata to\
            $replace_out_var?" \
          -type yesno -title "Warning" ]
        if {$selection == "yes"} {
          if {$have_replaced == 0 && $have_undone == 0} {
            if {$rcf_buf_rgn > 0} {
              # have to save workdata since sel_data_rgn with exclude set to 1
              # will over-write it
              set $outvar workdata_grcf
              exp_send "tempdata = workdata;\r"
              exp_send "$replace_out_var = sel_data_rgn($replace_out_var,\
                mode=4, rgn=$sel_points, win=$win_no, exclude=1,\
                make_workdata=1, origdata=$replace_orig_var);\r"
              expect ">"
              exp_send "workdata = tempdata;\
                $outvar = sel_data_rgn($outvar, mode=4, win=$win_no,\
                  rgn=$sel_points);\r"
            }
            append_varlist $replace_out_var
            exp_send "$replace_out_var = grow($replace_out_var, croppeddata);\r"
          }
          if {$have_replaced == 1 && $have_undone == 0} {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = $replace_out_var\
              (1: - numberof($outvar));\r"
            exp_send "$replace_out_var = grow($replace_out_var, croppeddata);\r"
          }
          expect ">"
          set have_undone 1
          set have_replaced 0
        }
      }
    Button .rep.3 -width 8 -text "Close" -command [list destroy .rep]

    Button .rep.5 -width 3 -text "Help" -command {
      tk_messageBox -icon info \
        -message "Hitting replace adds new filtered array to the output array\
          which Do Not Replace adds the original data back in." \
        -type ok -title "Info 1 of 3"
      tk_messageBox -icon info \
        -message "Once a replace or Do Not Replace has been done, the effects of\
          one can be replaced by the other." \
        -type ok -title "Info 2 of 3"
      tk_messageBox -icon info \
        -message "Example: Hit replace and insert filtered data, then hit DO NOT\
          REPLACE, and inserted data is taken out and original put in." \
        -type ok -title "Info 3 of 3"
    }

    pack .rep.05.varname .rep.05.varlist -side left -padx 5
    pack .rep.005.varname .rep.005.varlist -side left -padx 5
    pack .rep.15.1 .rep.15.2 -side top -pady 3
    pack .rep.15.4 .rep.15.3 -side right
    pack .rep.05 .rep.005 .rep.15 .rep.1 .rep.type  -side top -pady 10
    pack .rep.2 .rep.4 .rep.3 -side left -padx 5 -pady 5
    pack .rep.5 -side left -pady 5
  }

  proc sst {w var lbl rg} {
  # This procedure builds a widget composed of a Label, a spinbox, and a scale so
  # one can enter values by direct entry, the spin clicks, or the scale.
    frame $w
    lassign $rg rmin rmax rinc
    spinbox $w.sb -textvariable $var -format %.2f \
      -from $rmin -to $rmax -increment $rinc -width 6
    scale $w.sc -showvalue 0 -orient horizontal  \
      -variable $var \
      -from $rmin \
      -to   $rmax \
      -resolution $rinc
    label $w.lb -text $lbl
    pack $w.lb $w.sb $w.sc -side left -fill x -expand 1
    return $w
  }

  proc ud { a b c } {
    switch -- $::cbar_locked {
      cmin {
        set ::plot_settings(cmin) \
          [format %.2f [expr {$::plot_settings(cmax) - $::cdelta}]]
      }
      cmax {
        set ::plot_settings(cmax) \
          [format %.2f [expr {$::plot_settings(cmin) + $::cdelta}]]
      }
      cdelta {
        set ::cdelta \
          [format %.2f [expr {$::plot_settings(cmax) - $::plot_settings(cmin)}]]
      }
    }
    if { [ winfo exists .rem ] } {
      set ::min_thresh $::plot_settings(cmin)
      set ::max_thresh $::plot_settings(cmax)
    }
  }

  trace remove variable plot_settings(cmin) write ud
  trace remove variable plot_settings(cmax) write ud
  trace remove variable cdelta write ud

  trace add variable plot_settings(cmin) write ud
  trace add variable plot_settings(cmax) write ud
  trace add variable cdelta write ud

  pack \
    .l1wid.filter.1 \
    .l1wid.filter.7 \
    -side left

  ::l1pro::main::panel_processing .l1wid.pro
  ::l1pro::main::panel_cbar .l1wid.cbar
  ::l1pro::main::panel_plot .l1wid.plot
  ::l1pro::main::panel_tools .l1wid.tools

  grid .l1wid.pro - -sticky ew
  grid .l1wid.cbar .l1wid.plot -sticky ews
  grid .l1wid.tools - -sticky ew
  grid .l1wid.filter - -sticky ew
  grid columnconfigure .l1wid 1 -weight 1

  proc send_latlon_to_l1pro {minlon maxlon minlat maxlat utmarg} {
    global mnlon mxlon mnlat mxlat utm
    set mnlon $minlon
    set mxlon $maxlon
    set mnlat $minlat
    set mxlat $maxlat
    set utm $armarg
  }

  proc send_rnarr_to_l1pro {bstart bstop brnindx} {
    global start stop list lrnindx
    set start $bstart
    set stop $bstop
    set rnindx $brnindx
    set list1 [concat $start $stop]
    if {[llength $list] == 0} {
      set list $list1
      set lrnindx $rnindx
    } else {
      set list [concat $list $list1 ]
      set lrnindx [concat $lrnindx $rnindx]
    }
  }

  proc display_data args {
    array set opts [list -var $::pro_var -win $::win_no -fma $::l1pro_fma]
    array set opts $args

    set cmd "display_data, $opts(-var)"
    append cmd ", mode=\"[display_type_mode]\""
    if {$::skip > 1} {
      append cmd ", skip=$::skip"
    }
    append cmd ", msize=$::plot_settings(msize)"
    append cmd ", marker=$::plot_settings(mtype)"
    append cmd ", win=$opts(-win)"
    if {! $::l1pro_square_limits} {
      append cmd ", square=0"
    }
    if {$::l1pro_cbar} {
      append cmd ", showcbar=1"
    }
    if {$opts(-fma)} {
      append cmd ", dofma=1"
    }
    append cmd ", cmin=$::plot_settings(cmin)"
    append cmd ", cmax=$::plot_settings(cmax)"

    exp_send "$cmd;\r"
  }

  proc limits_tool {} {
    # Added by Jeremy Bracone 4/15/05
    # Opens a limits tool that makes a few functions a little quicker to perform.
    # The main function it provides is to set the limits from one window equal to
    # another.
    destroy .limitstool
    toplevel .limitstool
    wm title .limitstool "Limits Tool"
    frame .limitstool.1 -relief groove -bd 4
    label .limitstool.1.t1 -text "Apply limits from window "
    ::mixin::combobox .limitstool.1.c1 -text 0 -width 3 -state readonly \
      -values [::struct::list iota 64] \
      -takefocus 0
    label .limitstool.1.t2 -text " to window "
    ::mixin::combobox .limitstool.1.c2 -text 0 -width 3 -state readonly \
      -values [::struct::list iota 64] \
      -takefocus 0

    Button .limitstool.1.limits -text "Set Limits" \
      -helptext "Set Limits in window from box 2 equal to limits in window from\
        box 1.\
        \ni.e. Make the second window look like the first." \
      -command {
        set window1 [.limitstool.1.c1 getvalue]
        set window2 [.limitstool.1.c2 getvalue]
        if {$window1 >= 0 && $window2 >= 0} {
          #This function provided by l1pro.i
          exp_send "winlimits($window1,$window2); \r"
        }
      }

    frame .limitstool.2
    Button .limitstool.2.l -text "Limits()" \
      -helptext "Set current window limits to view entire plot" \
      -command {
        exp_send "limits\r"
        expect ">"
      }
    Button .limitstool.2.dismiss -text "Dismiss" -command {
      destroy .limitstool
    }
    pack .limitstool.1 -side top
    pack .limitstool.1.t1 .limitstool.1.c1 .limitstool.1.t2 .limitstool.1.c2 \
      .limitstool.1.limits -side left
    pack .limitstool.2 -side right
    pack .limitstool.2.dismiss .limitstool.2.l -padx 4 -side right
  }
}

source "$src_path/plot.ytk"
source "$src_path/bathctl.ytk"
source "$src_path/data_segments.ytk"
source "$src_path/pixelwf.ytk"
