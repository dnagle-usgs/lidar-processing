# vim: set ts=2 sts=2 sw=2 ai sr et:
#
# Orginal Amar Nayegandhi aka "anayegan"
#
# For info on using the Bwidget NoteBoook see:  http://mini.net/tcl/2298
#

# plot_settings
# var_settings

package require BWidget
package require Tktable
package require struct::list
package require struct::set
package require misc
package require mixin
package require tooltip
package require l1pro::ascii
package require l1pro::deprecated
package require l1pro::dirload
package require l1pro::drast
package require l1pro::file
package require l1pro::groundtruth
package require l1pro::main
package require l1pro::main::menu
package require l1pro::processing
package require l1pro::settings
package require l1pro::tools
package require l1pro::vars

if {![winfo exists .l1wid]} {
  set l1pro_data(processing_mode) [lrange {
    "First Return Topo"
    "Submerged Topo"
    "Topo Under Veg"
    "Multi Peak Veg"
    "Direct. Wave Spectra"
  } 0 end]

  set l1pro_data(mode_mapping) [lrange {
    "First Return Topography"  fs
    "Submerged Topography"     ba
    "Water Depth"              de
    "Bare Earth Topography"    be
    "Surface Amplitude"        fint
    "Bottom Amplitude"         lint
    "Canopy Height"            ch
  } 0 end]

  set outvar ""
  set win_no 5
  set win_load 6;    # used by EAARL Data Loader
  set usecentroid 1

  set cbar_locked cdelta

  set list {}
  set lrnindx {}
  set avg_surf 1
  set rcf_buf_rgn 0; #Used in proc replace_proc
  set autoclean_after_process 1
  set l1pro_fma 0

  set gridtype grid

  set data_file_path ""

  set varlist {fs_all depth_all veg_all cveg_all workdata}

  set cdelta 80
  set var_common [list \
    win_no 5 \
    cmin -40 \
    cmax 40 \
    msize 1.0 \
    mtype 1]

  set var_settings(fs_all) [linsert $var_common end \
    var fs_all \
    processing_mode "First Return Topo" \
    display_mode fs]

  set var_settings(depth_all) [linsert $var_common end \
    var depth_all \
    processing_mode "Submerged Topo" \
    display_mode ba]

  set var_settings(veg_all) [linsert $var_common end \
    var veg_all \
    processing_mode "Topo Under Veg" \
    display_mode be]

  set var_settings(cveg_all) [linsert $var_common end \
    var cveg_all \
    processing_mode "Multi Peak Veg" \
    display_mode fs]

  set var_settings(workdata) [linsert $var_common end \
    var workdata \
    processing_mode "Submerged Topo" \
    display_mode ba]

  set pro_var fs_all
  set pro_var_next fs_all
  array set plot_settings $var_settings($pro_var)

  array set cbvc {cmin cmin cmax cmax msize msize mtype mtype}

  set cbv 0
  set cbvc(cmin) $plot_settings(cmin)
  set cbvc(cmax) $plot_settings(cmax)
  set cbvc(msize) $plot_settings(msize)
  set cbvc(mtype) $plot_settings(mtype)

  set constant_win_no 0
  set l1pro_square_limits 1

  #load all yorick support functions
  ybkg require \"l1pro.i\"

  toplevel .l1wid
  wm withdraw .l1wid
  wm protocol .l1wid WM_DELETE_WINDOW {
    wm withdraw .l1wid
  }
  wm resizable .l1wid 1 0

  wm title .l1wid "Process EAARL Data"
  LabelFrame .l1wid.filter -relief groove -borderwidth 7 -text "FILTER:"

  .l1wid configure -menu .l1wid.mb
  ::l1pro::main::menu::build .l1wid.mb

  proc load_ground_pnav {} {
    exp_send "gt_pnav = load_pnav();\r"
  }
  proc load_ground_pnav2fs {} {
    exp_send "gt_fs = load_pnav2FS(); grow, gt_fsall, gt_fs;\r"
    append_varlist gs_fs
    append_varlist gs_fsall
  }

  proc append_varlist {newvar} {
    global varlist
    if {[lsearch -exact $varlist $newvar] == -1} {
      lappend varlist $newvar
      init_var_settings $newvar
    }
  }

  proc make_selected_arrays {} {
    global lrnindx list
    set curlist [.l1plot.1.lb curselection]
    set ptype [processing_mode]
    if {$ptype == 0} {
      exp_send "fs_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {($lidx != "")} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, fs_some, fs_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, fs_some, fs_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
    if {$ptype == 1} {
      exp_send "depth_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {$lidx != ""} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, depth_some, depth_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, depth_some, depth_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
    if {$ptype == 2} {
      exp_send "veg_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {$lidx != ""} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, veg_some, veg_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, veg_some, veg_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
    if {$ptype == 3} {
      exp_send "cveg_some = \[\];\r"
      expect ">"
      foreach f $curlist {
        set fidx [lindex $lrnindx $f]
        set lidx [lindex $lrnindx [expr ($f+1)]]
        if {[expr ($lidx-$fidx)] != 0} {
          if {$lidx != ""} {
            set lidx [expr ($lidx - 1)]
            exp_send "grow, cveg_some, cveg_all($fidx:$lidx);\r"
            expect ">"
          } else {
            exp_send "grow, cveg_some, cveg_all($fidx:);\r"
            expect ">"
          }
        }
      }
    }
  }

  proc ypalette p {
    exp_send "palette, \"${p}.gp\";\r"
    expect "> "
  }

  set ystyle_dpi 75

  proc ystyle s {
    set cmd "change_window_style, \"$s\""
    if {$::ystyle_dpi != 75} {
      append cmd ", dpi=$::ystyle_dpi"
    }
    exp_send "${cmd};\r"
  }

  proc ygridxy {x y} {
    exp_send "gridxy, $x, $y;\r"
  }

  proc determine_roll_bias {} {
      global win_no varlist bias pro_var

      destroy .l1bias
      toplevel .l1bias
      wm title .l1bias "Determine Roll Bias"

      foreach x {1 2 3 4 5 6} {
        frame .l1bias.$x
        pack .l1bias.$x -side top
      }

      if { [info exists bias ] == 0 } {
        exp_send "updatebias\r"
        expect ">"
        exp_send "updatebias\r"
        expect ">"
      }
      set slope 0
      set inout 1
      set width 5
      set flwin 4
      set var $pro_var

      LabelEntry .l1bias.1.var -relief sunken -borderwidth 3 -width 10 \
        -label "Variable:" -helptext "EAARL source data" \
        -textvariable var -text $var

      Label .l1bias.1.winl -text "in window:"
      spinbox .l1bias.1.win -justify center -width 2 \
        -textvariable win_no -from 0 -to 63 -increment 1

      Label .l1bias.1.transl -text "Then click"
      Button .l1bias.1.transbutton -text "Get Transect" \
        -helptext "Click to get transect" \
        -command {
          exp_send "transdata = get_transect($var, win=$win_no, update=1,\
            width=$width)\r"
          expect ">"
          .l1bias.3.plot configure -state normal
          .l1bias.3.winl configure -state normal
          .l1bias.3.win configure -state normal
          .l1bias.3.pick configure -state normal
          .l1bias.3.inout configure -state normal
          .l1bias.3.auto configure -state normal
        }

      Button .l1bias.1.help -text "Help!" -helptext "Click for directions" \
        -command {
          tk_messageBox -icon warning \
            -message "1) Start with data array plotted in a window and raw EAARL\
              data loaded. Set the variable and window and click Get Transect.\
              \r2) Drag a line perpendicular to the flightlines you wish to\
              examine. In the window that appears, zoom into the top, type\
              something, and hit enter. Now drag a box over the section of the\
              transect you wish to keep.\
              \r3) Click the plot button to display the loaded transect. In\
              order to determine the bias automatically all flightlines must be\
              traveling the same direction, so you'll need to remove whichever\
              direction is the minority.\
              \r4) Click 'select flightlines' and simply type 'y' or 'n' to keep\
              or remove each flightline. Now you have a set of flightlines going\
              the same direction.\
              \r5) Finally, determine whether the flightlines are going into or\
              out of the screen. If they are going INTO the screen, check the\
              box." \
            -type ok
        }

      LabelEntry .l1bias.2.width -relief sunken -width 3 \
        -label "Width:" -helptext "Transect width" \
        -textvariable width -text $width

      LabelEntry .l1bias.2.bias -relief sunken -width 10 \
        -label "Current Roll Bias:" -helptext "Current Roll Bias" \
        -textvariable bias -text $bias

      LabelEntry .l1bias.2.slope -relief sunken -width 10 \
        -label "Current Slope:" -helptext "Current slope" \
        -textvariable slope -text $slope

      Button .l1bias.3.plot -text "Plot" \
        -helptext "Click to plot flightline transect" \
        -command {exp_send "plot_flightline_transect(transdata, $flwin)\r"}

      Label .l1bias.3.winl -text "in win:"
      spinbox .l1bias.3.win -justify center \
        -width 2 -textvariable flwin -from 0 -to 63 -increment 1

      Button .l1bias.3.pick -text "Select Flightlines" \
        -helptext "Click to select which flightlines to keep" \
        -command {exp_send "transdata=selgoodflightlines(transdata, win=$flwin)\r"}

      checkbutton .l1bias.3.inout -text "in/out:" \
        -variable inout -onvalue -1 -offvalue 1

      Button .l1bias.3.auto -text "Determine bias" \
        -helptext "Click to automatically determine roll bias" \
        -command {exp_send "goodroll=find_roll_bias(transdata,0,$inout,update=1)\r"}

      pack .l1bias.1.var .l1bias.1.winl .l1bias.1.win .l1bias.1.transl \
        .l1bias.1.transbutton .l1bias.1.help -side left
      pack .l1bias.2.width .l1bias.2.bias .l1bias.2.slope -side left
      pack .l1bias.3.plot .l1bias.3.winl .l1bias.3.win .l1bias.3.pick \
        .l1bias.3.inout .l1bias.3.auto -side left

      foreach w {plot winl win pick inout auto} {
        .l1bias.3.$w configure -state disabled
      }
    }

  proc open_fit_gaussian_gui {} {
    source [file join $::src_path attic 2010-10-fit_gauss.ytk]
    fit_gauss::create_gui
  }

  proc processing_mode {} {
    global plot_settings l1pro_data
    return [lsearch -exact $l1pro_data(processing_mode) \
      $plot_settings(processing_mode)]
  }

  proc processing_mode_changed {a b c} {
    global curs pro_var_next
    if {$b eq "processing_mode"} {
      set curs [processing_mode]
    }
    if {$pro_var_next in [list fs_all depth_all veg_all cveg_all]} {
      set pro_var_next [lindex {fs_all depth_all veg_all cveg_all {}} \
        [processing_mode]]
    }
  }

  trace remove \
    variable plot_settings(processing_mode) write processing_mode_changed
  trace add \
    variable plot_settings(processing_mode) write processing_mode_changed

  proc processing_mode_by_index {index} {
    global plot_settings l1pro_data
    set plot_settings(processing_mode) \
      [lindex $l1pro_data(processing_mode) $index]
  }

  proc init_var_settings {var args} {
    dict set ::var_settings($var) var $var
    set settings [array get ::plot_settings]
    foreach {key val} [array get ::plot_settings] {
      if {![dict exists $::var_settings($var) $key]} {
        dict set ::var_settings($var) $key $val
      }
    }
  }

  proc pro_var_changed {a b c} {
    global var_settings plot_settings pro_var cbv win_no constant_win_no
    init_var_settings $plot_settings(var)

    # Currently saved version -- to be replaced
    set stored $var_settings($plot_settings(var))

    # Update processing_mode and display_mode
    dict set stored processing_mode $plot_settings(processing_mode)
    dict set stored display_mode $plot_settings(display_mode)

    # Update cbar if appropriate
    if {$cbv == 0} {
      foreach key {cmin cmax msize mtype} {
        dict set stored $key $plot_settings($key)
      }
    }

    # Update win_no if appropriate
    if {$constant_win_no == 0} {
      dict set stored win_no $win_no
    }

    # Replace saved version with new values
    set var_settings($plot_settings(var)) $stored

    # Load stored settings to be used
    if {[info exists var_settings($pro_var)]} {
      set stored $var_settings($pro_var)
    } else {
      set stored [array get plot_settings]
    }

    # Update processing_mode and display_mode
    set plot_settings(var) $pro_var
    set plot_settings(processing_mode) [dict get $stored processing_mode]
    set plot_settings(display_mode) [dict get $stored display_mode]

    # Update cbar if appropriate
    if {$cbv == 0} {
      foreach key {cmin cmax msize mtype} {
        set plot_settings($key) [dict get $stored $key]
      }
    }

    # Update win_no if appropriate
    if {$constant_win_no == 0} {
      set plot_settings(win_no) [dict get $stored win_no]
      set win_no $plot_settings(win_no)
    }
  }

  trace remove variable pro_var write pro_var_changed
  trace add variable pro_var write pro_var_changed

  proc display_type {} {
    lsearch -exact [dict values $::l1pro_data(mode_mapping)] \
      $::plot_settings(display_mode)
  }

  proc display_type_mode {} {
    return $::plot_settings(display_mode)
  }

  proc display_type_by_index {index} {
    set ::plot_settings(display_mode) \
      [lindex [dict values $::l1pro_data(mode_mapping)] $index]
  }

  proc copy_points_using_box {} {
    set selection [tk_messageBox -icon info \
      -message "Drag a Rectangular Box in Window $::win_no to define region." \
      -type okcancel -title "Message"]
    if {$selection == "ok"} {
      exp_send "workdata = sel_data_rgn($::pro_var, mode=2, win=$::win_no)\r"
      expect ">"
    }
  }

  proc copy_points_using_pip {} {
    set selection  [tk_messageBox -icon info \
      -message "Draw a Polygon in Window $::win_no to define a region using a\
        series of left mouse clicks.  To complete the polygon, middle mouse\
        click OR <Ctrl> and left mouse click." \
      -type okcancel -title "Message" ]
    if {$selection == "ok"} {
      exp_send "workdata = sel_data_rgn($::pro_var, mode=3, win=$::win_no)\r"
      expect ">"
    }
  }

  proc copy_points_using_pix {} {
    exp_send "workdata = select_points($::pro_var, win=$::win_no);\r"
    expect ">"
  }

  proc copy_points_using_tile {} {
    set selection [tk_messageBox -icon info \
      -message "Select a cell (250m by 250m) region by dragging a region in\
        window $::win_no within the required cell."\
      -type okcancel -title "Message" ]
    if {$selection == "ok"} {
      exp_send "workdata = select_region_tile($::pro_var, win=$::win_no, plot=1);\r"
      expect ">"
    }
  }

  ::mixin::combobox .l1wid.filter.1 -text "Copy points using..." -width 16 \
    -state readonly \
    -values [list "Rubberband Box" "Points in Polygon" "Single Pixel" \
      "Select Cell/Quad/Tile"] \
    -modifycmd {
      switch -- [.l1wid.filter.1 getvalue] {
        0 copy_points_using_box
        1 copy_points_using_pip
        2 copy_points_using_pix
        3 copy_points_using_tile
        default {error "Please Define Region."}
      }
    }
  ::tooltip::tooltip .l1wid.filter.1 \
    "Copy points to 'workdata' using any of the following methods:\
     \n  Rubberband Box\
     \n  Points in Polygon\
     \n  Single Pixel"

  ::mixin::combobox .l1wid.filter.7 -text "Filter tools..." -width 16 \
    -values [list Keep Remove Replace] \
    -state readonly \
    -modifycmd {
      global varlist
      switch -- [.l1wid.filter.7 getvalue] {
        0 keep_proc
        1 removing_proc
        2 replace_proc
        default {error "Please Define Region."}
      }
    }
  ::tooltip::tooltip .l1wid.filter.7 "Choose any of the following tools:"

  proc removing_proc {} {
    global varlist rmv_var plot_settings pro_var
    destroy .rem
    toplevel .rem
    frame .rem.05
    frame .rem.07 -relief raised -bd 1
    frame .rem.08 -relief raised -bd 1
    frame .rem.09
    wm title .rem "Remove Points Using..."
    Label .rem.05.varname -text "Input Variable:"

    ::mixin::combobox .rem.05.varlist \
      -textvariable ::rmv_var -state readonly \
      -listvariable ::varlist
    set rmv_var $pro_var

    frame .rem.06
    Label .rem.06.typetext -text "Data type:"
    # IMPORTANT NOTE: Do not change the order of GEO and VEG__ for the values of
    # the combobox below. A function parameter for the pipthresh function for
    # this gui is dependent on the index number of the selection.
    ::mixin::combobox .rem.06.type -textvariable remove_type -width 12 \
      -values [list "GEO or VEG__" "FS"] -state readonly
    if {[display_type] == 0} {
      .rem.06.type setvalue @1
    } else {
      .rem.06.type setvalue @0
    }

    ::mixin::combobox .rem.1 -width 18 -state readonly \
      -text "Remove points using..." \
      -values [list "Rubberband Box" "Points in Polygon" "Single Pixel" \
        "Pip-Thresh"] \
      -modifycmd {
        set removemode [.rem.1 getvalue]
        if {$removemode == 3} {
          pack forget .rem.2 .rem.3 .rem.4
          pack .rem.08 .rem.07
          pack .rem.07.a .rem.07.min .rem.07.minthresh -side left
          pack .rem.08.a .rem.08.max .rem.08.maxthresh -side left
          pack .rem.09 .rem.09.a
          pack .rem.2 .rem.3 -side left -padx 5 -pady 5
          set min_thresh $plot_settings(cmin)
          set max_thresh $plot_settings(cmax)
        } else {
          pack forget .rem.2 .rem.3 .rem.4
          pack forget .rem.07 .rem.08 .rem.09
          pack .rem.2 .rem.3 .rem.4 -side left -padx 5 -pady 5
        }
      }
    ::tooltip::tooltip .rem.1 \
      "Remove points from 'workdata' using any of the following methods:\
      \n  Rubberband Box\
      \n  Points in Polygon\
      \n  Single Pixel"
    Label .rem.07.a -text "Min. Threshold:"
    Label .rem.08.a -text "Max. Threshold:"
    Label .rem.09.a -text "WARNING: Cannot undo action." -justify center
    checkbutton .rem.07.min -variable min \
      -command {
        set state [lindex {disabled normal} $min]
        .rem.07.minthresh configure -state $state
      }
    checkbutton .rem.08.max -variable max \
      -command {
        set state [lindex {disabled normal} $max]
        .rem.08.maxthresh configure -state $state
      }
    spinbox .rem.07.minthresh -textvariable min_thresh -width 10 \
      -from -100 -to 5000 -increment 0.1 -format %.2f
    spinbox .rem.08.maxthresh -textvariable max_thresh -width 10 \
      -from -100 -to 5000 -increment 0.1 -format %.2f
    set min 1
    set max 1
    .rem.07.min select
    .rem.08.max select
    set min_thresh $plot_settings(cmin)
    set max_thresh $plot_settings(cmax)

    Button .rem.2 -width 8 -text "Go" \
      -command {
        global varlist outvar selr rmv_var pro_var

        set selr [.rem.1 getvalue]
        if {$selr == 0} {
          set var_type $pro_var
          set selection [tk_messageBox -icon info \
            -message "Drag a Rectangular Box in Window $win_no to define a\
              region." \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            exp_send "croppeddata=\[\];\
              $rmv_var = sel_data_rgn($rmv_var, mode=2, win=$win_no, exclude=1)\r"
            expect ">"
          }
        }
        if {$selr == 1} {
          set selection  [tk_messageBox  -icon info \
            -message "Draw a Polygon in Window $win_no to define a region using\
              a series of left mouse clicks. To complete the polygon, middle\
              mouse click OR <Ctrl> and left mouse click." \
            -type okcancel -title "Message" ]
          if {$selection == "ok"} {
            exp_send "croppeddata=\[\];\
              $rmv_var = sel_data_rgn($rmv_var, mode=3, win=$win_no, exclude=1)\r"
            expect ">"
          }
        }
        if {$selr == 2} {
          set selection [tk_messageBox  -icon info \
            -message "Select points to remove from window $win_no" \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            exp_send "croppeddata=\[\];\
              $rmv_var = select_points($rmv_var, win=$win_no, exclude=1);\r"
            expect ">"
          }
        }
        if {$selr == 3} {
          if {[.rem.06.type getvalue] == 1} {
            set val [.rem.06.type getvalue]
          } else {
            set val ""
          }
          if { $min == 0 && $max == 0 } {
            tk_messageBox -icon warning \
              -message "You have not set any threshold limits!" \
              -type ok -title "ERROR!"
          } else {
            # If we don't want to use a threshhold, we set it to void
            set min_arg [expr {$min ? $min_thresh : ""}]
            set max_arg [expr {$max ? $max_thresh : ""}]
            exp_send "croppeddata=\[\];\
              $rmv_var = pipthresh($rmv_var, mode=$val,\
                minthresh=$min_arg, maxthresh=$max_arg);\r"
          }
        }
        if {$selr == -1} {
          error "Please Define Region."
        } else {
          append_varlist $rmv_var
        }
      }
    Button .rem.3 -width 8 -text "Dismiss" -command {
      destroy .rem
    }
    Button .rem.4 -width 8 -text "Undo Last\nRemove" -command {
      exp_send "if(is_array(croppeddata))\
        $rmv_var = grow($rmv_var,croppeddata);\r"
      expect ">"
    }

    pack .rem.05.varname .rem.05.varlist -side left -padx 5
    pack .rem.06.typetext .rem.06.type -side left
    pack .rem.05 .rem.06 .rem.1 -pady 8
    pack .rem.08 .rem.07 .rem.09
    pack .rem.2 .rem.3 .rem.4 -side left -padx 5 -pady 5
  }

  proc keep_proc {} {
    global varlist keep_in_var keep_out_var pro_var
    destroy .sel
    toplevel .sel
    wm title .sel "Keep Points Using..."
    frame .sel.05

    Label .sel.05.varname -text "Input Variable:"
    ::mixin::combobox .sel.05.varlist \
      -textvariable ::keep_in_var -state readonly \
      -listvariable ::varlist
    set keep_in_var $pro_var

    ::mixin::combobox .sel.1 -state readonly -width 16 \
      -text "Keep points using..." \
      -values [list "Rubberband Box" "Points in Polygon" "Single Pixel"] \
      -modifycmd {
        global sels keep_in_var keep_out_var grow_keep
        set sels [.sel.1 getvalue]
        if {$sels == 2} {
          set grow_keep 1
          set keep_out_var "finaldata"
        } else {
          set keep_out_var $keep_in_var
        }
      }
    ::tooltip::tooltip .sel.1 \
      "Keep points from 'workdata' using any of the following methods:\
      \n  Rubberband Box\
      \n  Points in Polygon\
      \n  Single Pixel"

    checkbutton .sel.grow -text "Grow output variable" -variable grow_keep
    LabelEntry .sel.15 -relief sunken -label "Output Variable:" \
      -helptext "Define output variable" \
      -textvariable keep_out_var -text "workdata"

    Button .sel.2 -width 8 -text "Go" \
      -command {
        global varlist outvar sels keep_in_var keep_out_var pro_var

        set sels [.sel.1 getvalue]
        if {$sels == 0} {
          set var_type $pro_var
          set selection [tk_messageBox  -icon info \
            -message "Drag a Rectangular Box in Window $win_no to define\
              region." \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            if {$grow_keep == 0} {
              exp_send "$keep_out_var =\
                sel_data_rgn($keep_in_var, mode=2, win=$win_no)\r"
              expect ">"
            } else {
              exp_send "grow, $keep_out_var,\
                sel_data_rgn($keep_in_var, mode=2, win=$win_no);\r"
              expect ">"
            }
          }
        }
        if {$sels == 1} {
          set selection  [tk_messageBox  -icon info \
            -message "Draw a Polygon in Window $win_no to define a region using\
              a series of left mouse clicks.To complete the polygon, middle\
              mouse click OR <Ctrl> and left mouse click." \
            -type okcancel -title "Message" ]
          if {$selection == "ok"} {
            if {$grow_keep == 0} {
              exp_send "$keep_out_var =\
                sel_data_rgn($keep_in_var, mode=3, win=$win_no)\r"
              expect ">"
            } else {
              exp_send "grow, $keep_out_var,\
                sel_data_rgn($keep_in_var, mode=3, win=$win_no);\r"
              expect ">"
            }
          }
        }
        if {$sels == 2} {
          set selection [tk_messageBox  -icon info \
            -message "Select points to keep from window $win_no" \
            -type okcancel -title "Message"]
          if {$selection == "ok"} {
            if {$grow_keep == 0} {
              exp_send "$keep_out_var =\
                select_points($keep_in_var, win=$win_no);\r"
              expect ">"
            } else {
              exp_send "grow, $keep_out_var,\
                select_points($keep_in_var, win=$win_no));\r"
              expect ">"
            }
          }
        }
        if {$sels == -1} {
          error "Please Define Region."
        } else {
          append_varlist $keep_out_var
        }
      }
    Button .sel.3 -width 8 -text "Dismiss" -command {
      destroy .sel
    }

    pack .sel.05.varname .sel.05.varlist -side left -padx 5
    pack .sel.05 .sel.1 .sel.grow .sel.15 -side top -pady 10
    pack .sel.2 .sel.3 -side left -padx 5 -pady 5
  }

  proc replace_proc {} {
    global varlist croppeddata have_replaced have_undone rcf_buf_rgn \
      pro_var replace_in_var replace_orig_var replace_out_var
    set have_undone 0
    set have_replaced 0
    destroy .rep
    toplevel .rep
    wm title .rep "Replace Points Using..."
    frame .rep.05
    frame .rep.005
    frame .rep.15

    set sameinput 0
    Label .rep.05.varname -text "Input Variable:"

    ::mixin::combobox .rep.05.varlist \
      -textvariable replace_in_var -state readonly \
      -listvariable ::varlist
    set replace_in_var $pro_var

    Label .rep.005.varname -text "Original Data Variable:"

    ::mixin::combobox .rep.005.varlist \
      -textvariable replace_orig_var -state readonly \
      -listvariable ::varlist
    set replace_orig_var $pro_var

    # Note: In code below, the yorick variables "croppeddata" and "workdata" are
    # created through sel_data_rgn
    #   croppeddata = (selected filtered points);
    #   workdata = (selected original data points);
    ::mixin::combobox .rep.1 -state readonly -width 28 \
      -text "Select points to replace using..." \
      -values [list "Rubberband Box" "Points in Polygon" "Window Limits"] \
      -modifycmd {
        set defr [.rep.1 getvalue]
        set sel_points buf_points
        set buffered_var bufferdata
        global rcf_buf_rgn
        if {$rcf_buf_rgn > 0} {
          if {$defr == 0} {
            set result [tk_messageBox  -icon info \
              -message "Drag a Rectangular Box in Window $win_no to define\
                region." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = $replace_in_var;\r"
              exp_send "$sel_points = mouse(1,1,\
                \"Hold the left mouse button down, select a region:\");"
              expect ">"
              exp_send "temp_rgn = add_buffer_rgn($sel_points,\
                $rcf_buf_rgn, mode=1);\r"
              expect ">"
              exp_send "workdata = sel_data_rgn($replace_orig_var, mode=4,\
                win=$win_no, rgn=temp_rgn);\r"
              expect ">"
            }
          } elseif {$defr == 1} {
            set result [tk_messageBox -icon info \
              -message "Draw a Polygon in Window $win_no to define a region\
                using a series of left mouse clicks. To complete the polygon,\
                middle mouse click OR <Ctrl> and left mouse click." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = $replace_in_var;\r"
              # For eval purposes, success stores if getPoly_add_buffer command
              # was successful. The yorick variables buf_points, temp_rgn, and
              # workdata are made.
              exp_send "success = getPoly_add_buffer($rcf_buf_rgn,\
                origdata=$replace_origvar, windw=$win_no);\r"
              expect ">"
            }
          } elseif {$defr == 2} {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = $replace_in_var;\r"
            exp_send "window, $win_no;\
              $sel_points=limits()(1:4);\
              temp_rgn = add_buffer_rgn($sel_points, $rcf_buf_rgn, mode=3);\r"
            expect ">"
            exp_send "workdata = sel_data_rgn($replace_orig_var, mode=4,\
              win=$win_no, rgn=temp_rgn);\r"
            expect ">"
          }
          set have_replaced 0
          set have_undone 0
        } else {
          if {$defr == 0} {
            set result [tk_messageBox  -icon info \
              -message "Drag a Rectangular Box in Window $win_no to define\
                region." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = sel_data_rgn($replace_in_var,\
                mode=2, win=$win_no, exclude=1, make_workdata=1,\
                origdata=$replace_orig_var);\r"
              expect ">"
              set have_replaced 0
              set have_undone 0
            }
          }
          if {$defr == 1} {
            set result [tk_messageBox  -icon info \
              -message "Draw a Polygon in Window $win_no to define a region\
                using a series of left mouse clicks. To complete the polygon,\
                middle mouse click OR <Ctrl> and left mouse click." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              append_varlist $replace_out_var
              exp_send "$replace_out_var = sel_data_rgn($replace_in_var,\
                mode=3, win=$win_no, exclude=1, make_workdata=1,\
                origdata=$replace_orig_var);\r"
              expect ">"
              set have_replaced 0
              set have_undone 0
            }
          }
          if {$defr == 2} {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = sel_data_rgn($replace_in_var,\
              mode=1, win=$win_no, exclude=1, make_workdata=1,\
              origdata=$replace_orig_var);\r"
            set have_replaced 0
            set have_undone 0
          }
        #end if/else rcf_buf_rgn
        }
      }
    ::tooltip::tooltip .rep.1 \
      "Select points to replace using any of the following methods:\
      \n Rubberband Box\
      \n Points in Polygon\
      \n Window Limits.\
      \nSelected points from the original data array will be written\
      \nto variable \"workdata\"."

    Button .rep.type -text "Filter selected points" -width 15 -bd 5 \
      -command {
        global have_replaced have_undone croppeddata outvar rcf_buf_rgn \
          sel_points
        set outvar workdata_grcf
        if {$have_undone == 1} {
          if {$rcf_buf_rgn > 0} {
            exp_send "workdata = tempdata;\r"
          } else {
            append_varlist $replace_out_var
            exp_send "$replace_out_var =\
              $replace_out_var (1: - numberof(croppeddata));\r"
          }
        } elseif {$have_replaced == 1} {
          if {$rcf_buf_rgn > 0} {
            exp_send "workdata = tempdata;\r"
          } else {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = $replace_out_var (1: - numberof($outvar));\r"
          }
        }
        ::l1pro::tools::rcf::gui -var workdata
        set have_replaced 0
        set have_undone 0
      }

    LabelEntry .rep.15.1 -relief sunken -label "Output Variable:" \
      -helptext "Define output variable" \
      -textvariable replace_out_var -text "finaldata"
    checkbutton .rep.15.2 -text "Same as input variable" -variable sameinput \
      -command {
        if {$sameinput == 1} {
          set replace_out_var $replace_in_var
          .rep.15.1 configure -state disabled
        } else {
          .rep.15.1 configure -state normal
        }
      }
    LabelEntry .rep.15.3 -relief sunken -label "Buffer Region (m):" -width 5 \
      -helptext "Define the amount of buffer used in filtering for the selected\
        points" \
      -textvariable rcf_buf_rgn -text "0"

    Button .rep.15.4 -text "Click \[HERE\] for info" -bd 0 \
      -command {
        tk_messageBox -icon info \
          -message "Points in the buffer region will be used for filtering, but\
            will not be replaced into the output array." \
          -type ok -title "Use a buffer region help"
      }

  # Significant change made by Jeremy Bracone 4/4/05
  # Do No Replace as been fixed and now acts as an undo while Replace acts as a
  # redo. Replace will put filtered data into output array, "Do Not Replace" will
  # put original data into output array. If a replace or "Do Not Replace" has
  # already been done, hitting replace or Do not will have no effect. If replace
  # or "Do Not Replace" has already been done, hitting one will undo the action
  # of the other and perform the expected operation; i.e. Replace was done, now
  # hit Do Not Replace and it will take out the data inserted in the Replace and
  # put in the original data. Same is true for opposite situation.
    Button .rep.2 -width 8 -text "Replace..." -bd 5 \
      -command {
        global varlist outvar reps keep_var origvar have_replaced \
          have_undone croppeddata
        set $outvar workdata_grcf
        set selection [tk_messageBox -icon question \
          -message "Append array $outvar to $replace_out_var?" \
          -type yesno -title "Warning" ]
        if {$selection == "yes" && $have_replaced == 0 && $have_undone == 0} {
          if {$rcf_buf_rgn > 0} {
            # have to save workdata since sel_data_rgn with exclude set to 1 will
            # over-write it
            exp_send "tempdata = workdata;\r"
            exp_send "$replace_out_var = sel_data_rgn($replace_out_var,\
              mode=4, rgn=$sel_points, win=$win_no, exclude=1, make_workdata=1,\
              origdata=$replace_orig_var);\r"
            expect ">"
            # This is kind of confusing, but $outvar = workdata_grcf (love this
            # confuciated variable hiding)
            exp_send "workdata = tempdata;\
              $outvar = sel_data_rgn($outvar, mode=4, win=$win_no,\
                rgn=$sel_points);\r"
          }
          append_varlist $replace_out_var
          exp_send "$replace_out_var = grow($replace_out_var, $outvar);\r"
        }
        if {$selection == "yes" && $have_replaced == 0 && $have_undone == 1} {
          append_varlist $replace_out_var
          exp_send "$replace_out_var = $replace_out_var\
            (1: - numberof(croppeddata));\r"
          exp_send "$replace_out_var = grow($replace_out_var, $outvar);\r"
          set have_undone 0
        }
        expect ">"
        set have_replaced 1
      }
    Button .rep.4 -width 10 -text "Do Not Replace..." -bd 5 \
      -command {
        global varlist outvar reps replace_out_var origvar
        set selection [tk_messageBox -icon question \
          -message "Append ORIGINAL cropped array croppeddata to\
            $replace_out_var?" \
          -type yesno -title "Warning" ]
        if {$selection == "yes"} {
          if {$have_replaced == 0 && $have_undone == 0} {
            if {$rcf_buf_rgn > 0} {
              # have to save workdata since sel_data_rgn with exclude set to 1
              # will over-write it
              set $outvar workdata_grcf
              exp_send "tempdata = workdata;\r"
              exp_send "$replace_out_var = sel_data_rgn($replace_out_var,\
                mode=4, rgn=$sel_points, win=$win_no, exclude=1,\
                make_workdata=1, origdata=$replace_orig_var);\r"
              expect ">"
              exp_send "workdata = tempdata;\
                $outvar = sel_data_rgn($outvar, mode=4, win=$win_no,\
                  rgn=$sel_points);\r"
            }
            append_varlist $replace_out_var
            exp_send "$replace_out_var = grow($replace_out_var, croppeddata);\r"
          }
          if {$have_replaced == 1 && $have_undone == 0} {
            append_varlist $replace_out_var
            exp_send "$replace_out_var = $replace_out_var\
              (1: - numberof($outvar));\r"
            exp_send "$replace_out_var = grow($replace_out_var, croppeddata);\r"
          }
          expect ">"
          set have_undone 1
          set have_replaced 0
        }
      }
    Button .rep.3 -width 8 -text "Close" -command [list destroy .rep]

    Button .rep.5 -width 3 -text "Help" -command {
      tk_messageBox -icon info \
        -message "Hitting replace adds new filtered array to the output array\
          which Do Not Replace adds the original data back in." \
        -type ok -title "Info 1 of 3"
      tk_messageBox -icon info \
        -message "Once a replace or Do Not Replace has been done, the effects of\
          one can be replaced by the other." \
        -type ok -title "Info 2 of 3"
      tk_messageBox -icon info \
        -message "Example: Hit replace and insert filtered data, then hit DO NOT\
          REPLACE, and inserted data is taken out and original put in." \
        -type ok -title "Info 3 of 3"
    }

    pack .rep.05.varname .rep.05.varlist -side left -padx 5
    pack .rep.005.varname .rep.005.varlist -side left -padx 5
    pack .rep.15.1 .rep.15.2 -side top -pady 3
    pack .rep.15.4 .rep.15.3 -side right
    pack .rep.05 .rep.005 .rep.15 .rep.1 .rep.type  -side top -pady 10
    pack .rep.2 .rep.4 .rep.3 -side left -padx 5 -pady 5
    pack .rep.5 -side left -pady 5
  }

  proc ud { a b c } {
    switch -- $::cbar_locked {
      cmin {
        set ::plot_settings(cmin) \
          [format %.2f [expr {$::plot_settings(cmax) - $::cdelta}]]
      }
      cmax {
        set ::plot_settings(cmax) \
          [format %.2f [expr {$::plot_settings(cmin) + $::cdelta}]]
      }
      cdelta {
        set ::cdelta \
          [format %.2f [expr {$::plot_settings(cmax) - $::plot_settings(cmin)}]]
      }
    }
    if { [ winfo exists .rem ] } {
      set ::min_thresh $::plot_settings(cmin)
      set ::max_thresh $::plot_settings(cmax)
    }
  }

  trace remove variable plot_settings(cmin) write ud
  trace remove variable plot_settings(cmax) write ud
  trace remove variable cdelta write ud

  trace add variable plot_settings(cmin) write ud
  trace add variable plot_settings(cmax) write ud
  trace add variable cdelta write ud

  pack \
    .l1wid.filter.1 \
    .l1wid.filter.7 \
    -side left

  ::l1pro::main::panel_processing .l1wid.pro
  ::l1pro::main::panel_cbar .l1wid.cbar
  ::l1pro::main::panel_plot .l1wid.plot
  ::l1pro::main::panel_tools .l1wid.tools

  grid .l1wid.pro - -sticky ew
  grid .l1wid.cbar .l1wid.plot -sticky ews
  grid .l1wid.tools - -sticky ew
  grid .l1wid.filter - -sticky ew
  grid columnconfigure .l1wid 1 -weight 1

  proc send_latlon_to_l1pro {minlon maxlon minlat maxlat utmarg} {
    global mnlon mxlon mnlat mxlat utm
    set mnlon $minlon
    set mxlon $maxlon
    set mnlat $minlat
    set mxlat $maxlat
    set utm $armarg
  }

  proc send_rnarr_to_l1pro {bstart bstop brnindx} {
    global start stop list lrnindx
    set start $bstart
    set stop $bstop
    set rnindx $brnindx
    set list1 [concat $start $stop]
    if {[llength $list] == 0} {
      set list $list1
      set lrnindx $rnindx
    } else {
      set list [concat $list $list1 ]
      set lrnindx [concat $lrnindx $rnindx]
    }
  }

  proc display_data args {
    array set opts [list -var $::pro_var -win $::win_no -fma $::l1pro_fma]
    array set opts $args

    set cmd "display_data, $opts(-var)"
    append cmd ", mode=\"$::plot_settings(display_mode)\""
    if {$::skip > 1} {
      append cmd ", skip=$::skip"
    }
    append cmd ", msize=$::plot_settings(msize)"
    append cmd ", marker=$::plot_settings(mtype)"
    append cmd ", win=$opts(-win)"
    if {! $::l1pro_square_limits} {
      append cmd ", square=0"
    }
    if {$::l1pro_cbar} {
      append cmd ", showcbar=1"
    }
    if {$opts(-fma)} {
      append cmd ", dofma=1"
    }
    append cmd ", cmin=$::plot_settings(cmin)"
    append cmd ", cmax=$::plot_settings(cmax)"

    exp_send "$cmd;\r"
  }
}

source "$src_path/plot.ytk"
source "$src_path/bathctl.ytk"
source "$src_path/data_segments.ytk"
source "$src_path/pixelwf.ytk"
source "$src_path/ts_check.ytk"
