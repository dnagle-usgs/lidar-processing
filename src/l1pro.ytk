# vim: set tabstop=2 softtabstop=2 shiftwidth=2 autoindent shiftround expandtab:
# $Id$
#
# Orginal Amar Nayegandhi aka "anayegan"
#
# For info on using the Bwidget NoteBoook see:  http://mini.net/tcl/2298
#

# plot_settings
# var_settings

set l1pro_data(processing_mode) [list \
  "First Return Topo" \
  "Submerged Topo" \
  "Topo Under Veg" \
  "Multi Peak Veg" \
  "Direct. Wave Spectra" \
]

set l1pro_data(display_types) [list \
  "First Return Topography" \
  "Submerged Topography" \
  "Water Depth" \
  "Bare Earth Topography" \
  "Surface Amplitude" \
  "Bottom Amplitude" \
  "Canopy Height" \
]

set ofname ""
set curvar ""
set outvar ""
set win_no 5
set usecentroid 1
set hist_log 1

set cmax_max 5000
set cmin_min -100
set cmax_inc 0.1

set list {}
set lrnindx {}
set write_some 0
set ssvar "*.pbd"
set changed_dpi 0
set avg_surf 1
set rcf_buf_rgn 0; #Used in proc replace_proc

set show_pro_gui 1

set varlist {fs_all depth_all veg_all cveg_all workdata}

set cdelta 80
set var_common [list \
  cmin -40 \
  cmax 40 \
  msize 1.0 \
  mtype 1]

set var_settings(fs_all) [linsert $var_common end \
  var fs_all \
  processing_mode "First Return Topo" \
  display_type "First Return Topography"]

set var_settings(depth_all) [linsert $var_common end \
  var depth_all \
  processing_mode "Submerged Topo" \
  display_type "Submerged Topography"]

set var_settings(veg_all) [linsert $var_common end \
  var veg_all \
  processing_mode "Topo Under Veg" \
  display_type "Bare Earth Topography"]

set var_settings(cveg_all) [linsert $var_common end \
  var cveg_all \
  processing_mode "Multi Peak Veg" \
  display_type "First Return Topography"]

set var_settings(workdata) [linsert $var_common end \
  var workdata \
  processing_mode "Submerged Topo" \
  display_type "Submerged Topography"]

set pro_var fs_all
array set plot_settings $var_settings($pro_var)

set plot_dpi 75
array set cbvc {cmin cmin cmax cmax msize msize mtype mtype}

set cbvc(cmin) $plot_settings(cmin)
set cbvc(cmax) $plot_settings(cmax)
set cbvc(msize) $plot_settings(msize)
set cbvc(mtype) $plot_settings(mtype)

#load all yorick support functions
exp_send "#include \"$src_path/l1pro.i\"\r"
expect ">"

package require BWidget
package require Tktable
destroy .l1wid

toplevel .l1wid
wm title .l1wid "Process EAARL Data"
frame .l1wid.bf1
frame .l1wid.bf2
frame .l1wid.bf2.utm
frame .l1wid.bf3
frame .l1wid.bf4
frame .l1wid.bf4.1
frame .l1wid.bf4.2
frame .l1wid.bf45 -relief groove -borderwidth 3
frame .l1wid.bf45.sc -relief groove -borderwidth 3
frame .l1wid.bf45.p -relief groove -borderwidth 3
frame .l1wid.bf45.q -relief groove -borderwidth 3
LabelFrame .l1wid.bf45.r -relief groove -borderwidth 7 -text "FILTER:"
frame .l1wid.bf5  -relief groove -borderwidth 3

.l1wid configure -menu .l1wid.mb
menu .l1wid.mb
menu .l1wid.mb.file
menu .l1wid.mb.load
menu .l1wid.mb.options
menu .l1wid.mb.graph
menu .l1wid.mb.post
menu .l1wid.mb.cmd
menu .l1wid.mb.diag
.l1wid.mb   add cascade -label File -underline 0 -menu .l1wid.mb.file

.l1wid.mb.file add command -label "Read Binary Data file..." -underline 0 \
  -command {
    global cbv cdelta cbvc plot_settings pro_var
    if {$cbv == 1} {
      set cbvc(cmin) $plot_settings(cmin)
      set cbvc(cmax) $plot_settings(cmax)
      set cbvc(msize) $plot_settings(msize)
      set cbvc(mtype) $plot_settings(mtype)
    }

    set _ytk_fn [ tk_getOpenFile -parent .l1wid \
      -filetypes {
        {{Yorick PBD file} {.pbd}  }
        {{IDL Binary file} {.bin}  }
        {{IDL Binary file} {.edf}  }
        {{All Files}       {*}   }
      }]
    if { $_ytk_fn != "" } {
      switch [ file extension $_ytk_fn ] {
        ".pbd" {
          exp_send "_ytk_pbd_f = openb(\"$_ytk_fn\"); restore, _ytk_pbd_f;\r"
          exp_send "show, _ytk_pbd_f\r"
          toplevel .stby
          exp_send "\r"
          label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
          pack .stby.lbl
          expect ">"
          update
          exp_send "set_read_tk \r"
          expect "Tk updated"
          expect ">"
          update
          set var_type $pro_var
          update
          if { $cbv == 0 } {
            exp_send "set_read_yorick, $var_type \r"
            expect ">"
          }
          destroy .stby
          if {$cbv == 1} {
            set plot_settings(cmin) $cbvc(min)
            set cdelta [expr {$cbvc(cmax)-$cbvc(cmin)} ]
            set plot_settings(cmax) $cbvc(cmax)
            set plot_settings(msize) $cbvc(msize)
            set plot_settings(mtype) $cbvc(mtype)
          }
          update
        }
        ".edf" -
        ".bin" {
          set ytk_bin_dir [ file dirname $_ytk_fn ]/
          set ytk_bin_file [ file tail $_ytk_fn ]
          exp_send "data_ptr = read_yfile(\"$ytk_bin_dir\",\
            fname_arr=\"$ytk_bin_file\"); \r"
          expect ">"
          exp_send "read_pointer_yfile, data_ptr, mode=1; \r"
          expect ">"
          set ptype [processing_mode]
        }
      }
    }
  }

.l1wid.mb.file add command -label "Write Binary Data File..." -underline 0 \
  -command {
    global write_some data_file_path pro_var
    if { [info exists data_file_path ] == 0 } {
      set data_file_path "~/"
    }
    destroy .l1write
    toplevel .l1write
    frame .l1write.1
    frame .l1write.2
    frame .l1write.3
    set ftypes {
      {{For pbd}       {.pbd}        }
      {{IDL bin}       {.bin}        }
      {{IDL edf}       {.edf}        }
      {{All Files}            *      }
    }
    set ptype [processing_mode]
    set var_type $pro_var
    LabelEntry .l1write.1.path  -width 30 -relief sunken -bd 3 \
      -label "Output Path:  " -helptext "Enter Output Data Path Here" \
      -textvariable ofname -text $data_file_path
    Button .l1write.1.browse -text "Browse..." -width 10 \
      -command {
        set ofname [tk_getSaveFile -filetypes $ftypes \
          -defaultextension ".pbd"]
        write_binary_file $ofname
      }
    LabelEntry .l1write.2.varname -width 10 -relief sunken -bd 3 \
      -label "Variable Name: " \
      -helptext "Enter Name of Variable to Write to file"  \
      -textvariable var_type -text $var_type
    LabelEntry .l1write.2.plyname -width 10 -relief sunken -bd 3 \
      -label "PLY Name: " \
      -helptext "Enter ply name to Write to file; Leave it empty if you\
        don't want to write out ply data" \
      -textvariable ply_type -text ""
    LabelEntry .l1write.2.qname -width 10 -relief sunken -bd 3 \
      -label "GGA(q) Name: " \
      -helptext "Enter q name to Write to file; Leave it empty if you\
        don't want to write out gga data" \
      -textvariable q_type -text ""
    Button .l1write.3.ok -text "Write File" -width 5 \
      -command {
        global ofname
        write_binary_file $ofname
      }
    Button .l1write.3.cancel -text "Cancel" -width 5 \
      -command {
        destroy .l1write
      }
    pack .l1write.1.path .l1write.1.browse -side left -padx 5
    pack .l1write.2.varname .l1write.2.plyname .l1write.2.qname \
      -side left -padx 5
    pack .l1write.3.ok .l1write.3.cancel -side left -padx 5
    pack .l1write.1 .l1write.2 .l1write.3
  }

.l1wid.mb.file add command -label "Read SubSampled Data File..." -underline 0 \
  -command {
    global data_file_path
    set ofn [ tk_getOpenFile -filetypes \
      {
        {{Yorick PBD file} {.pbd}  }
        {{All Files}       {*}   }
      } ]
    destroy .l1ss
    toplevel .l1ss
    wm title .l1ss "Read SubSampled Data File"
    LabelFrame .l1ss.1 -relief groove -borderwidth 3 -text "Points to skip:"
    frame .l1ss.2
    SpinBox .l1ss.1.sk \
      -range {1 1000 1} \
      -textvariable skipl \
      -helptext "Enter points to skip (Subsample)" \
      -width 5
    LabelEntry .l1ss.1.mvar -label "Variable Name: " -width 10 -bd 3 \
      -helptext "Enter Variable Name of Data array after merging" \
      -textvariable mvar
    Button .l1ss.2.ok -text "OK" -width 5 \
      -command {
        exp_send "$mvar = subsample_pbd_data(fname=\"$ofn\", skip = $skipl);\r"
        destroy .l1ss
      }
    Button .l1ss.2.cancel -text "Cancel" -width 5 \
      -command {
        destroy .l1ss
      }
    pack .l1ss.1.sk .l1ss.1.mvar -side left -padx 5
    pack .l1ss.2.ok .l1ss.2.cancel -side left -padx 5
    pack .l1ss.1 .l1ss.2 -pady 5
  }

.l1wid.mb.file add command -label "Read Data Directory..." \
  -underline 10 -command ::l1dir::gui

catch { namespace delete l1dir }
namespace eval l1dir {
  # Global scope variables used:
  # ::data_file_path
  namespace eval v {
    variable window .l1dir
    variable merged ""
    variable type_pbd pbd
    variable type_yfile {edf or bin}
    variable datatype $type_pbd
    variable skip 1
    variable unique 0
    variable search ""
    variable fixedzone 0
    variable zone 18
    variable tile_dt {2km Data Tiles}
    variable tile_qq {Quarter Quads}
    variable tiletype $tile_dt
  }

  proc gui {} {
    set win $v::window
    destroy $win
    toplevel $win
    wm resizable $win 1 0
    wm minsize $win 400 1
    wm title $win "Read Data Directory"

    label $win.lblPath -text "Data Path:"
    entry $win.entPath -width 40 -textvariable ::data_file_path
    button $win.butPath -text "Browse..." \
      -command [namespace code butPath_cmd]

    label $win.lblType -text "Data Type:"
    iwidgets::combobox $win.cboType -editable false \
      -textvariable [namespace which -variable v::datatype]
    $win.cboType insert list 0 $v::type_pbd $v::type_yfile

    label $win.lblSearch -text "Search String:"
    entry $win.entSearch -width 8 \
      -textvariable [namespace which -variable v::search]

    set fra $win.fraPBD
    labelframe $fra -text "PBD Options"

    label $fra.lblMerged -text "Merged Variable:"
    entry $fra.entMerged -width 8 \
      -textvariable [namespace which -variable v::merged]

    label $fra.lblUnique -text "Unique:"
    checkbutton $fra.chkUnique \
      -variable [namespace which -variable v::unique]

    label $fra.lblSubsample -text "Subsample:"
    spinbox $fra.spnSubsample -from 1 -to 1000 -increment 1 -width 5 \
      -textvariable [namespace which -variable v::skip]

    label $fra.lblFixed -text "Fixed Zone:"
    checkbutton $fra.chkFixed \
      -variable [namespace which -variable v::fixedzone]

    label $fra.lblZone -text "Zone:"
    spinbox $fra.spnZone -from 1 -to 60 -increment 1 -width 5 \
      -textvariable [namespace which -variable v::zone]

    label $fra.lblTiles -text "Tile Type:"
    iwidgets::combobox $fra.cboTiles -editable false \
      -textvariable [namespace which -variable v::tiletype]
    $fra.lblTiles insert list 0 [list $v::tile_dt $v::tile_qq]

    grid $fra.lblMerged - $fra.entMerged -
    grid $fra.lblUnique $fra.chkUnique $fra.lblSubsample $fra.spnSubsample
    grid $fra.lblFixed $fra.chkFixed $fra.lblZone $fra.spnZone
    grid $fra.lblTiles - $fra.cboTiles -

    makesticky e [list $fra.lblMerged $fra.lblTiles \
    $fra.lblUnique $fra.lblFixed $fra.lblSubsample $fra.lblZone]
    makesticky w [list $fra.chkUnique $fra.chkFixed]
    makesticky ew [list $fra.spnSubsample $fra.spnZone $fra.entMerged \
      $fra.cboTiles]

    set fra $win.fraEmpty
    frame $fra

    set fra $win.fraButtons
    frame $fra
    button $fra.butLoad -text "Load Data" \
      -command [namespace code butLoad_cmd]
    button $fra.butCancel -text "Cancel" \
      -command [namespace code butCancel_cmd]
    grid $fra.butLoad $fra.butCancel

    grid $win.lblPath   $win.entPath   - $win.butPath
    grid $win.lblType   $win.cboType   $win.fraPBD -
    grid $win.lblSearch $win.entSearch ^ ^
    grid $win.fraEmpty   - ^ ^
    grid $win.fraButtons - ^ ^
    makesticky e [list \
      $win.lblPath $win.lblType $win.lblSearch]
    makesticky ew [list \
      $win.entPath $win.cboType $win.entSearch]
    makesticky news [list $win.fraEmpty]
    grid $win.fraPBD -padx {5 0}
    grid columnconfigure $win 1 -weight 1
    grid rowconfigure    $win 3 -weight 1

    datatype_changes
  }

  proc makesticky {sticky widgets} {
    foreach widget $widgets {
      grid $widget -sticky $sticky
    }
  }

  trace add variable [namespace which -variable v::datatype] write \
    [namespace code datatype_changes]

  proc datatype_changes {{n1 {}} {n2 {}} {op {}}} {
    set state [lindex {disabled normal} \
      [string equal $v::datatype $v::type_pbd]]
    foreach widget [winfo children $v::window.fraPBD] {
      $widget configure -state $state
    }
    tiletype_changes
  }

  trace add variable [namespace which -variable v::fixedzone] write \
    [namespace code tiletype_changes]

  proc tiletype_changes {{n1 {}} {n2 {}} {op {}}} {
    set fra $v::window.fraPBD
    if {[$fra.lblFixed cget -state] == "normal"} {
      set state [lindex {disabled normal} $v::fixedzone]
      foreach widget [list $fra.lblZone $fra.spnZone \
          $fra.lblTiles $fra.cboTiles] {
        $widget configure -state $state
      }
    }
  }

  proc butPath_cmd {} {
    set temp_path [ tk_chooseDirectory -initialdir $::data_file_path \
      -mustexist 1 -title "Read data directory" ]
    if {$temp_path != ""} {
      set ::data_file_path $temp_path
    }
  }

  proc butLoad_cmd {} {
    if { ! [file isdirectory $::data_file_path] } {
      error "The data path provided is not a real directory: $::data_file_path"
    }
    switch -- $v::datatype \
      $v::type_pbd {
        if { ! [string length $v::merged] } {
          error "You must provide a merged variable name!"
        }
        set search $v::search
        if {! [string length $search]} {
          set search {*.pbd}
        }
        if {$v::fixedzone} {
          switch -- $v::tiletype \
            $v::tile_dt {
              set cmd zoneload_dt_dir
            } \
            $v::tile_qq {
              set cmd zoneload_qq_dir
            } \
            default {
              error "Invalid tile type provided: $v::tiletype"
            }
          exp_send "require, \"zone.i\";\
            require, \"qq24k.i\";\
            $v::merged = ${cmd}(\"$::data_file_path\",\
              $v::zone, skip=$v::skip, unique=$v::unique,\
              glob=\"$search\");\r"
        } else {
          wm withdraw $v::window
          exp_send "$v::merged = merge_data_pbds(\"$::data_file_path\",\
            skip=$v::skip, uniq=$v::unique,\
            searchstring=\"$search\");\r"
        }
        expect ">"
        exp_send "vname=\"$v::merged\";\
          set_read_tk;\
          set_read_yorick, $v::merged\r"
        expect ">"
        exp_send "\r"
      } \
      $v::type_yfile {
        set search $v::search
        if {! [string length $search]} {
          set search "\[\]"
        }
        wm withdraw $v::window
        exp_send "data_ptr = read_yfile(\"$::data_file_path\",\
          searchstring=\"$search\");\r"
        expect ">"
        exp_send "read_pointer_yfile, data_ptr, mode=1;\r"
        expect ">"
      } \
      default {
        error "Invalid data type provided: $v::datatype"
      }

    destroy $v::window
  }

  proc butCancel_cmd {} {
    destroy $v::window
  }
}

.l1wid.mb.file add command -label "Read Data Directory... (deprecated)" \
  -command {
    global data_file_path
    if { [info exists data_file_path ] == 0 } {
      set data_file_path "/data/"
    }
    destroy .l1dir
    toplevel .l1dir
    frame .l1dir.1
    frame .l1dir.2
    wm title .l1dir "Read Data Directory"
    LabelFrame .l1dir.3 -relief groove -borderwidth 3 -text "Options:"
    LabelEntry .l1dir.2.op  -width 50 -relief sunken -bd 3 \
      -label "Path:  " -helptext "Enter Data Path Here" \
      -textvariable path -text $data_file_path
    Button .l1dir.2.fbutton -text "Browse..." -command {
      global data_file_path
      set path [ tk_chooseDirectory -initialdir $data_file_path \
        -mustexist 1 -title "Read Data Directory" ]/
      set data_file_path $path
    }

    ComboBox .l1dir.3.dtype -text "Data Type..." -width 10 \
      -helptext "Select Data File type" \
      -editable 0 -takefocus 0 \
      -values { pbd edf bin } \
      -modifycmd {
        set dtype [.l1dir.3.dtype getvalue]
        if {$dtype == 0} {
          .l1dir.3.skip configure -state normal
          .l1dir.3.mvar configure -state normal
        } else {
          .l1dir.3.skip configure -state disabled
          .l1dir.3.mvar configure -state disabled
        }
      }

    LabelEntry .l1dir.3.mvar -label "Merged Variable Name: " \
      -width 8 -bd 3 -textvariable mvar \
      -helptext "Enter Variable Name of Data array after merging"

    Label .l1dir.3.skL -text "Subsample: "

    SpinBox .l1dir.3.skip -range {1 1000 1} -width 3 -textvariable skipl \
      -helptext "Enter plot points to skip"

    LabelEntry .l1dir.3.ssvar -label "Search String: " -width 8 -bd 3 \
      -helptext "Enter search string" \
      -textvariable ssvar

    checkbutton .l1dir.3.uniq -text "Unique" -variable uniq
    Button .l1dir.1.ok -text "OK" -width 5 -command {
      if {$path != ""} {
        .l1dir.2.op configure -state disabled
        .l1dir.1.ok configure -state disabled
        set dtype [.l1dir.3.dtype getvalue]
        if {$dtype == 0}  {
          exp_send "$mvar = merge_data_pbds(\"$path\", skip = $skipl,\
            uniq = $uniq, searchstring=\"$ssvar\"); \r"
          destroy .l1dir
        }
        if {$dtype == 1 || $dtype == 2} {
          exp_send "data_ptr = read_yfile(\"$path\"); \r"
          expect ">"
          exp_send "read_pointer_yfile, data_ptr, mode=1; \r"
          expect ">"
          set ptype [processing_mode]
          destroy .l1dir
        }
      }
    }
    .l1dir.3.skip configure -state disabled

    Button .l1dir.1.cancel -text "Cancel" -width 5 -command {
      destroy .l1dir
    }
    pack .l1dir.1.ok .l1dir.1.cancel -side left -padx 5
    pack .l1dir.2.op .l1dir.2.fbutton -side left -padx 5
    pack .l1dir.3.dtype .l1dir.3.mvar .l1dir.3.skL .l1dir.3.skip \
      .l1dir.3.uniq .l1dir.3.ssvar -side left -padx 3
    pack .l1dir.2 .l1dir.3 .l1dir.1 -side top -pady 5
  }

.l1wid.mb.file add command -label "Ascii output ..." -underline 0 \
  -command {
    global opath ofile data_path plot_settings pro_var write_asc_some
    if {[info exists data_path] == 0} {
      set data_path "~/"
    }
    set delimit "space"
    set indx 0
    set intensity 0
    set rnidx 0
    set soeindx 0
    set hline 0
    set split 0
    set zclip 0
    set opath $data_path
    set zmin $plot_settings(cmin)
    set zmax $plot_settings(cmax)
    set ftypes {
      {{For QTViewer}  {.xyz} }
      {{Generic ASCII} {.asc} }
      {{Simple txt}    {.txt} TEXT}
      {{All Files}       *    }
    }

    destroy .l1asc
    toplevel .l1asc
    set w .l1asc
    $w configure -menu $w.mb
    menu $w.mb
    menu $w.mb.file
    $w.mb add cascade -label File -underline 0 -menu $w.mb.file
    $w.mb.file add command -label "File..." \
      -command {
        set ofname [tk_getSaveFile \
          -filetypes $ftypes \
          -initialdir $data_path \
          -defaultextension .xyz \
        ]
        if { $ofname != "" } {
          set opath "[file dirname $ofname]/"
          set ofname [file tail $ofname]
          set data_path $opath

          set ptype [processing_mode]
          set dtype [display_type]
          set var_type $pro_var

          if {$zclip} {
            set zclips "\[$zmin, $zmax\]"
          } else {
            set zclips "\[\]"
          }
          switch -- $utmll {
            UTM     {set latlon 0}
            LATLON  {set latlon 1}
            default {set latlon 0}
          }
          switch -- $delimit {
            space     {set de "\" \""}
            comma     {set de "\",\""}
            semicolon {set de "\";\""}
            default   {set de "\"\""}
          }
          switch -- $ptype {
            0 {
              set wtype 1
              set pstruc FS
            }
            1 {
              set wtype [expr {$dtype ? 2 : 1}]
              set pstruc GEO
            }
            2 {
              set wtype [expr {$dtype ? 3 : 1}]
              set pstruc VEG__
            }
            3 {
              set wtype 1
              set pstruc CVEG_ALL
            }
            default {
              set wtype ""
              set pstruc ""
            }
          }
          if { $wtype ne "" && $pstruc ne "" } {
            exp_send "write_ascii_xyz, $var_type, \"$opath\", \"$ofname\",\
              type=$wtype, indx=$indx, split=$split, intensity=$intensity,\
              delimit=$de, zclip=$zclips, pstruc=$pstruc, rn=$rnidx,\
              soe=$soeindx, header=$hline, latlon=$latlon;\r"
            expect ">"
          }
          set write_some 0
        }

      }

    wm title .l1asc "Write Ascii Data"
    LabelFrame .l1asc.ops -justify center -relief groove -borderwidth 3 \
      -text "Options:"
    set utmll "UTM"
    tk_optionMenu .l1asc.ops.0 utmll UTM LATLON
    LabelFrame .l1asc.ops.1 -justify center -relief groove -borderwidth 3 \
      -text "Include:"
    frame .l1asc.ops.2 -relief groove -borderwidth 3
    frame .l1asc.fn -relief groove -borderwidth 3
    frame .l1asc.cmd -relief groove -borderwidth 3
    set ptype [processing_mode]
    set var_type $pro_var

    Separator .l1asc.ops.1.s0 -orient vertical -bg black -relief groove
    Separator .l1asc.ops.1.s1 -orient vertical -bg black -relief groove

    checkbutton .l1asc.ops.1.indx -text "Index Number" -variable indx
    Separator .l1asc.ops.1.s2 -orient vertical -bg black -relief groove

    checkbutton .l1asc.ops.1.rn -text "Raster/Pulse Number" -variable rnidx
    Separator .l1asc.ops.1.s3 -orient vertical -bg black -relief groove

    checkbutton .l1asc.ops.1.int -text "Intensity Data" -variable intensity

    checkbutton .l1asc.ops.1.soe -text "SOE" -variable soeindx
    Separator .l1asc.ops.1.s4 -orient vertical -bg black -relief groove

    checkbutton .l1asc.ops.1.header -text "Header" -variable hline
    Separator .l1asc.ops.1.s5 -orient vertical -bg black -relief groove

    Separator .l1asc.ops.2.s1 -orient vertical -bg black -relief groove

    label .l1asc.ops.2.dl -text "Delimiter: "
    tk_optionMenu .l1asc.ops.2.d delimit comma semicolon space

    LabelEntry .l1asc.ops.2.split -width 7 -bd 3 \
      -label "Max number of lines/file" \
      -helptext "Enter maximum number of lines in each file; enter 0 to write\
        all data in 1 file" \
      -textvariable split

    Separator .l1asc.ops.2.s2 -orient vertical -bg black -relief groove

    checkbutton .l1asc.ops.2.zclip -text "Z Clipper:" -variable zclip \
      -command {
        set state [lindex {disabled normal} $zclip]
        .l1asc.ops.2.zmin configure -state $state
        .l1asc.ops.2.zmax configure -state $state
      }
    LabelEntry .l1asc.ops.2.zmin -width 5 -bd 3 -label "Zmin" \
      -textvariable zmin -state disabled
    LabelEntry .l1asc.ops.2.zmax -width 5 -bd 3 -label "Zmax" \
      -textvariable zmax -state disabled

    pack .l1asc.ops.1.s0 .l1asc.ops.1.indx .l1asc.ops.1.s1 .l1asc.ops.1.rn \
      .l1asc.ops.1.s2 .l1asc.ops.1.int .l1asc.ops.1.s3 .l1asc.ops.1.soe \
      .l1asc.ops.1.s4 .l1asc.ops.1.header .l1asc.ops.1.s5 \
      -side left -fill both -padx 3
    pack .l1asc.ops.2.dl .l1asc.ops.2.d .l1asc.ops.2.s1 .l1asc.ops.2.split \
      .l1asc.ops.2.s2 .l1asc.ops.2.zclip .l1asc.ops.2.zmin .l1asc.ops.2.zmax \
      -side left -padx 3 -fill both
    pack .l1asc.ops.0 .l1asc.ops.1 .l1asc.ops.2 -side top

    Button .l1asc.cmd.cancel -text "Cancel" -width 5 -command {
      set write_some 0
      destroy .l1asc
    }
    Button .l1asc.cmd.dismiss -text "Dismiss" -width 5 -command {
      destroy .l1asc
    }
    pack .l1asc.cmd.cancel .l1asc.cmd.dismiss -side left -padx 5
    pack .l1asc.ops .l1asc.fn .l1asc.cmd -side top
  }

.l1wid.mb.file add command -label "Load EAARL data from map limits" \
  -underline 21 \
  -command {
    global data_file_path path
    set skipb 0
    set search .pbd

    if { [info exists data_file_path] == 0} {
      set data_file_path "~/"
    }

    destroy .l1map
    toplevel .l1map
    wm title .l1map "EAARL Data Loader"

    foreach x {1 2 3 4 5 6} {
      frame .l1map.$x
      pack .l1map.$x -side top
    }

    LabelEntry .l1map.1.path -relief sunken -borderwidth 3 \
      -label "Path:  " -width 70 -helptext "Enter path to processed data" \
      -textvariable data_file_path -text $data_file_path

    Button .l1map.1.pathbutton -text "Browse..." \
      -helptext "Open dialog to select path" \
      -command {
        global data_file_path
        set data_file_path [ tk_chooseDirectory -initialdir $data_file_path \
          -mustexist 1 -title "Processed Data Directory" ]/
      }

    ComboBox .l1map.2.mode -text "Data Type..." -width 10 \
      -helptext "Select Data Type" \
      -editable 0 \
      -values {FirstSurface Bathy BareEarth} \
      -takefocus 0 \
      -modifycmd {
        set mode [.l1map.2.mode getvalue]
        set modes [expr $mode + 1]
      }

    Label .l1map.2.winl -text "Win:"
    SpinBox .l1map.2.win -justify center -range {0 7 1} \
      -width 2 -textvariable win_no

    checkbutton .l1map.2.skipb -text "Use This Skip:" -variable skipb \
      -command {
        set state [lindex {disabled normal} $skipb]
        .l1map.2.skip configure -state $state
      }

    LabelEntry .l1map.2.skip -width 5 -bd 3 -label "Skip" \
      -textvariable skipl -state disabled

    LabelEntry .l1map.2.search -width 15 -bd 3 -label "Search String:" \
      -textvariable search

    Button .l1map.2.go -text "Load" -helptext "Click button to load data" \
      -command {
        append_varlist "exploredata"
        set mvar "exploredata"
        set curvar "exploredata"
        set ycmd "explorestart, \"$data_file_path\", $modes, win=$win_no,\
            search_str=\"$search\""
        if {$skipb} {
          set ycmd "$ycmd, forceskip=$skipl"
        }
        exp_send "$ycmd\r"
        expect ">"
      }
    pack .l1map.1.path .l1map.1.pathbutton -side left -padx 5
    pack .l1map.2.mode .l1map.2.winl .l1map.2.win .l1map.2.skipb \
      .l1map.2.skip .l1map.2.search .l1map.2.go -side left -padx 5
  }


.l1wid.mb add cascade -label "Load" -underline 0 -menu .l1wid.mb.load
.l1wid.mb.file add command -label "Dismiss" -underline 0 \
  -command {destroy .l1wid}
.l1wid.mb.load add command -label "Load TANS Data .. " -underline 5 \
  -command {
    exp_send "tans = rbtans();\r"
    expect ">"
  }
.l1wid.mb.load  add command -label "Load DMARS PBD Data .. " -underline 5 \
  -command load_dmars

.l1wid.mb.load add command -label "Load PNAV Data .. " -underline 5 \
  -command {exp_send "pnav = rbpnav(); \r"}

 .l1wid.mb.load add command -label "Load Ops_conf Settings..." -underline 5 \
  -command load_ops_conf

.l1wid.mb.load add command -label "Load Bathymetry Settings .." -underline 21 \
  -command bathctl


.l1wid.mb add cascade -label Options -underline 0 -menu .l1wid.mb.options


.l1wid.mb.options add command -label "Configure elevation scale limits..." \
  -underline 0 \
  -command {
    destroy  .l1wid-opts
    toplevel .l1wid-opts
    wm title .l1wid-opts "Set Elevation Scale limits"
    frame .l1wid-opts.f1
    frame .l1wid-opts.f2
    frame .l1wid-opts.f3
    frame .l1wid-opts.f4
    set cmax_inc 0.1
    Label .l1wid-opts.f1.label -text "Set Max Cmax scale to:"
    Label .l1wid-opts.f2.label -text "Set Min Cmin scale to:"
    Label .l1wid-opts.f3.label -text "Set Increment to:"
    SpinBox  .l1wid-opts.f1.max -range {-10000. 50000. 10.} -width 10 \
      -textvariable cmax_max
    SpinBox  .l1wid-opts.f2.min -range {-10000. 50000. 10.} -width 10 \
      -textvariable cmax_min
    SpinBox  .l1wid-opts.f3.inc -width 10 \
      -values [list 0.1 0.2 .25 .5 .75 1.0 1.5 2.0 2.5 3 4 5 6 7 8 9 10 15 \
        20 25] \
      -textvariable cmax_inc

    Button .l1wid-opts.f4.go -text "Go" -width 10 -command {
      set rg [list $cmax_min $cmax_max $cmax_inc]
      .l1wid.bf45.sc.1.cmin.sc configure -from $cmax_min -to $cmax_max \
        -resolution $cmax_inc
      .l1wid.bf45.sc.1.cmin.sb configure -range $rg
      .l1wid.bf45.sc.1.cmax.sc configure -from $cmax_min -to $cmax_max \
        -resolution $cmax_inc
      .l1wid.bf45.sc.1.cmax.sb configure -range $rg
      set cmax_delta [expr $cmax_max - $cmax_min]
      set cdel_rg [list 0 $cmax_delta $cmax_inc]
      .l1wid.bf45.sc.1.cdelta.sc configure -from 0 -to $cmax_delta \
        -resolution $cmax_inc
      .l1wid.bf45.sc.1.cdelta.sb configure -range $cdel_rg
    }

    Button .l1wid-opts.f4.dis -text "Dismiss" -width 10 -command {
      destroy .l1wid-opts
    }

    pack .l1wid-opts.f1.label .l1wid-opts.f1.max -side left -fill x
    pack .l1wid-opts.f2.label .l1wid-opts.f2.min -side left -fill x
    pack .l1wid-opts.f3.label .l1wid-opts.f3.inc -side left -fill x
    pack .l1wid-opts.f4.go .l1wid-opts.f4.dis -side left -fill x
    pack .l1wid-opts.f1 .l1wid-opts.f2 .l1wid-opts.f3 .l1wid-opts.f4 \
      -side top -anchor e -pady 5
  }
.l1wid.mb.options add checkbutton -label "Log Histograms" -underline 0 \
  -variable hist_log \
  -command hist_linlog

.l1wid.mb.options add command -label "Plot/Write Individual Flightlines..." \
  -underline 0 \
  -command {
    global list lrnindx
    destroy .l1plot
    toplevel .l1plot
    wm title .l1plot "Plot / Write Selected Flightlines"
    frame .l1plot.1
    listbox .l1plot.1.lb -selectmode extended -width 50 \
      -xscrollcommand ".l1plot.xscroll set" \
      -yscrollcommand ".l1plot.1.yscroll set"
    scrollbar .l1plot.xscroll -orient horizontal \
      -command [list .l1plot.1.lb xview]
    scrollbar .l1plot.1.yscroll -command [list .l1plot.1.lb yview]
    for {set i 0} { $i < [llength $lrnindx] } {incr i} {
      set e [lindex $lrnindx $i]
      set rnf [lindex $list [expr ($i*2)]]
      set rnl [lindex $list [expr ($i*2+1)]]
      .l1plot.1.lb insert end \
        "Flightline $i. Rasters $rnf to $rnl. Start Index = $e"
    }

    Button .l1plot.sall -text "Select All" -width 10 -command {
      .l1plot.1.lb selection set 0 [llength $lrnindx]
    }

    Button .l1plot.clear -text "Clear All" -width 10 -command {
      .l1plot.1.lb delete 0 end
      set list {}
      set lrnindx {}
    }

    Button .l1plot.plot -text "Plot" -width 6 -command {
      make_selected_arrays
      plot_fltlines 1
    }

    Button .l1plot.write -text "Write Datafile" -command {
    }

    pack .l1plot.1.lb .l1plot.1.yscroll -side left -fill y
    pack .l1plot.1 .l1plot.xscroll -side top -fill x
    pack .l1plot.sall .l1plot.clear .l1plot.plot .l1plot.write \
      -side left -fill x
  }

.l1wid.mb.options add command \
  -label "Show Flightlines with No Raster Data..." -underline 25 \
  -command {
    exp_send "plot_no_raster_fltlines(gga, edb);\r"
  }

.l1wid.mb.options add command -label "Show Flightlines with No TANS Data..." \
  -underline 25 \
  -command {
    exp_send "plot_no_tans_fltlines(tans, gga);\r"
  }

.l1wid.mb.options add command -label "List Plot Variables..." -underline 10 \
  -command varlist_plot

proc varlist_plot {} {
  global varlist
  destroy .varplot
  toplevel .varplot
  wm title .varplot "List"
  frame .varplot.1
  frame .varplot.2
  listbox .varplot.1.lb -selectmode single -width 12 \
    -xscrollcommand ".varplot.1.xscroll set" \
    -yscrollcommand ".varplot.1.yscroll set" \
    -listvariable varlist
  scrollbar .varplot.1.xscroll -orient horizontal \
    -command [list .varplot.1.lb xview]
  scrollbar .varplot.1.yscroll -command [list .varplot.1.lb yview]
  Button .varplot.2.select -text "Select" -command {
    set pro_var [lindex $varlist [.varplot.1.lb curselection]]
  }
  LabelEntry .varplot.2.add -width 8 -relief sunken -label "Add:" \
    -helptext "Add variable name to list" \
    -textvariable addvar
  .varplot.2.add bind <Return> {
    global varlist addvar
    append_varlist $addvar
    set addvar {}
  }
  Button .varplot.2.delete -width 8 -text "Delete" \
    -command {
      set del_no [.varplot.1.lb curselection]
      if {$del_no <= 3} {
        # don't delete fixed variables
        tk_messageBox  -icon warning \
          -message "Cannot delete this variable" \
          -type ok
      } else {
        set del_var [lindex $varlist $del_no]
        set choice [tk_messageBox  -icon question \
          -message "Deleting variable $del_var.  Are you sure??" \
          -type yesno -title "Warning" ]
        if {$choice == "yes"} {
          set new_varlist1 [lrange $varlist 0 [expr ($del_no-1)]]
          set new_varlist2 [lrange $varlist [expr ($del_no+1)] end]
          set varlist [concat $new_varlist1 $new_varlist2]
          exp_send "$del_var = \[\];\r"
        }
      }
    }
  Button .varplot.2.dismiss -text "Dismiss" -width 8 -command {
    destroy .varplot
  }
  pack .varplot.2.select .varplot.2.add .varplot.2.delete .varplot.2.dismiss \
    -side top -fill x
  grid .varplot.1.lb      -in .varplot.1 -column 0 -row 0 -sticky "nswe"
  grid .varplot.1.yscroll -in .varplot.1 -column 1 -row 0 -sticky "ns"
  grid .varplot.1.xscroll -in .varplot.1 -column 0 -row 1 -sticky "ew"
  grid columnconfigure .varplot.1 0 -weight 1
  grid rowconfigure    .varplot.1 0 -weight 1
  pack .varplot.1 -in .varplot -side top -fill both -expand 1
  pack .varplot.2 -in .varplot -side top -fill x
}

proc append_varlist {newvar} {
  global varlist
  if {[lsearch -exact $varlist $newvar] == -1} {
    lappend varlist $newvar
  }
}

.l1wid.mb.options add checkbutton -label "Constant Colorbar for Variables" \
  -variable cbv \
  -command {
    if {$cbv == 1} {
      global cbvc plot_settings
      set cbvc(cmin) $plot_settings(cmin)
      set cbvc(cmax) $plot_settings(cmax)
      set cbvc(msize) $plot_settings(msize)
      set cbvc(mtype) $plot_settings(mtype)
    }
  }

.l1wid.mb.options add checkbutton -label "Set Plot Limits" -variable setll \
  -command {
    if {$setll == 1} {
      exp_send "_ytk_ll = limits();\n"
    }
  }

.l1wid.mb.options add checkbutton \
  -label "Show raw and processed waveforms when using Pixel Waveform" \
  -variable bconst

.l1wid.mb.options add checkbutton \
  -label "Show Processing section of GUI" \
  -variable show_pro_gui \
  -command {
    if {$show_pro_gui} {
      grid .l1wid.bf4
    } else {
      grid remove .l1wid.bf4
    }
  }

proc make_selected_arrays {} {
  global lrnindx list
  set curlist [.l1plot.1.lb curselection]
  set ptype [processing_mode]
  if {$ptype == 0} {
    exp_send "fs_some = \[\];\r"
    expect ">"
    foreach f $curlist {
      set fidx [lindex $lrnindx $f]
      set lidx [lindex $lrnindx [expr ($f+1)]]
      if {[expr ($lidx-$fidx)] != 0} {
        if {($lidx != "")} {
          set lidx [expr ($lidx - 1)]
          exp_send "grow, fs_some, fs_all($fidx:$lidx);\r"
          expect ">"
        } else {
          exp_send "grow, fs_some, fs_all($fidx:);\r"
          expect ">"
        }
      }
    }
  }
  if {$ptype == 1} {
    exp_send "depth_some = \[\];\r"
    expect ">"
    foreach f $curlist {
      set fidx [lindex $lrnindx $f]
      set lidx [lindex $lrnindx [expr ($f+1)]]
      if {[expr ($lidx-$fidx)] != 0} {
        if {$lidx != ""} {
          set lidx [expr ($lidx - 1)]
          exp_send "grow, depth_some, depth_all($fidx:$lidx);\r"
          expect ">"
        } else {
          exp_send "grow, depth_some, depth_all($fidx:);\r"
          expect ">"
        }
      }
    }
  }
  if {$ptype == 2} {
    exp_send "veg_some = \[\];\r"
    expect ">"
    foreach f $curlist {
      set fidx [lindex $lrnindx $f]
      set lidx [lindex $lrnindx [expr ($f+1)]]
      if {[expr ($lidx-$fidx)] != 0} {
        if {$lidx != ""} {
          set lidx [expr ($lidx - 1)]
          exp_send "grow, veg_some, veg_all($fidx:$lidx);\r"
          expect ">"
        } else {
          exp_send "grow, veg_some, veg_all($fidx:);\r"
          expect ">"
        }
      }
    }
  }
  if {$ptype == 3} {
    exp_send "cveg_some = \[\];\r"
    expect ">"
    foreach f $curlist {
      set fidx [lindex $lrnindx $f]
      set lidx [lindex $lrnindx [expr ($f+1)]]
      if {[expr ($lidx-$fidx)] != 0} {
        if {$lidx != ""} {
          set lidx [expr ($lidx - 1)]
          exp_send "grow, cveg_some, cveg_all($fidx:$lidx);\r"
          expect ">"
        } else {
          exp_send "grow, cveg_some, cveg_all($fidx:);\r"
          expect ">"
        }
      }
    }
  }
}

proc hist_linlog {} {
  global hist_log
  exp_send "_win=window();window,0;\
    logxy,0,$hist_log; range,$hist_log;window,_win \r"
}


.l1wid.mb   add cascade -label Graph -underline 0 -menu .l1wid.mb.graph
.l1wid.mb.graph add radiobutton \
  -label "75 Dpi (450x450)" -value "75" -variable plot_dpi -underline 1 \
  -command {
    set changed_dpi 1
  }
.l1wid.mb.graph add radiobutton \
  -label "100 Dpi (600x600)" -value "100" -variable plot_dpi -underline 1 \
  -command {
    set changed_dpi 1
  }
.l1wid.mb.graph add radiobutton \
  -label "100 Dpi (1100x850)" -value "1100" -variable plot_dpi -underline 1 \
  -command {
    set changed_dpi 1
  }
.l1wid.mb.graph add command -label "Open the Limits Tool" -underline 0 \
  -command limits_tool

.l1wid.mb add cascade -label PostProcessing -underline 0 -menu .l1wid.mb.post

.l1wid.mb.post add command -label "Datum Convert" -underline 0 \
  -command datum_proc

.l1wid.mb.post add command -label "RCF Region Filter" -underline 0 \
  -command rcf_region

.l1wid.mb add cascade -label CmdLine -underline 1 -menu .l1wid.mb.cmd

.l1wid.mb.cmd add command -label "mtransect" -command {
  exp_send "require,\"transect.i\"; help,mtransect\r"
}
.l1wid.mb.cmd add command -label "batch_process" -command {
  exp_send "require, \"batch_process.i\"; help,batch_process\r"
}
.l1wid.mb.cmd add command -label "batch_rcf(Filter)" -command {
  exp_send "require, \"batch_process.i\"; help,batch_rcf\r"
}
.l1wid.mb.cmd add command -label "batch_datum_convert" -command {
  exp_send "require, \"batch_datum_convert.i\"; help,batch_datum_convert\r"
}
.l1wid.mb.cmd add command -label "batch_veg_lfpw" -command {
  exp_send "require, \"batch_veg_energy.i\"; help,batch_veg_lfpw\r"
}
.l1wid.mb.cmd add command -label "batch_pbd2las" -command {
  exp_send "require, \"pbd2las.i\"; help,batch_pbd2las\r"
}
.l1wid.mb.cmd add command -label "batch_write_xyz" -command {
  exp_send "require, \"batch_process.i\"; help,batch_write_xyz\r"
}

.l1wid.mb add cascade -label Diagnostics -underline 0 -menu .l1wid.mb.diag

.l1wid.mb.diag add command -label "Transect Tool" -command {
  source "$src_path/transrch.ytk"
}

.l1wid.mb.diag add command -label "Flightline Segments" \
  -command [list eval segment_by_flightlines \$::pro_var]

proc rcf_region {} {
  global varlist l1pro_data pro_var rcf_var
  destroy .rcf
  destroy .ircf
  toplevel .rcf
  wm title .rcf "Random Consensus Filter"
  frame .rcf.0 -relief groove -borderwidth 3
  frame .rcf.1
  frame .rcf.2
  frame .rcf.3
  frame .rcf.4
  frame .rcf.5
  frame .rcf.6

  ComboBox .rcf.0.mode -text "Select RCF type" -width 18 \
    -values {
      RCF
      Iterative\ RCF} \
    -helptext "Select the type of RCF filter" -editable 0 \
    -modifycmd {
      set rcfmode [.rcf.0.mode getvalue]
      if {$rcfmode == -1} {
        set rcfmode 0
      }
      if {$rcfmode == 1} {
        pack forget .rcf.3
        pack .rcf.0 .rcf.1 .rcf.2 .rcf.5 .rcf.6 .rcf.3 -side top -pady 10
      } else {
        pack forget .rcf.5 .rcf.6
      }
    }

  Button .rcf.0.help -text "Help" -width 8 -bd 5 \
    -command {
      set rcfmode [.rcf.0.mode getvalue]
      if {$rcfmode == -1} {
        tk_messageBox  -icon info \
          -message "Select one of the filtering methods in the drop down\
            menu. Click Help on each selection to learn more about the\
            filtering method" \
          -type ok -title "Select RCF Type -- Help"
      }
      if {$rcfmode == 0} {
        exp_send "help, rcfilter_eaarl_pts\r"
      }
      if {$rcfmode == 1} {
        exp_send "help, rcf_triag_filter\r"
      }
    }


  LabelEntry .rcf.1.buf -width 4 -relief sunken -label "Input Window (cm):" \
    -helptext "The input window size that will slide through the data set (in\
      centimeters)" \
    -textvariable buf -text 500
  LabelEntry .rcf.1.w -width 4 -relief sunken -label "Elevation width (cm):" \
    -helptext "The vertical extent or range of the filter (in centimeters)" \
    -textvariable w -text 20
  LabelEntry .rcf.1.no -width 4 -relief sunken -label "Minimum winners:" \
    -helptext "The minimum number of winners" \
    -textvariable no_rcf -text 3

  Label .rcf.2.varname -text "Input Variable:"

  iwidgets::combobox .rcf.2.varlist \
    -textvariable rcf_var \
    -editable false -width 10 \
    -selectioncommand {
      set outvar "rcf_$rcf_var"
    }
  .rcf.2.varlist component list configure \
    -listvariable varlist

  set rcf_var $pro_var

  Label .rcf.2.dispname -text "Mode:"
  ComboBox .rcf.2.disp -width 20 \
    -values $l1pro_data(processing_mode) \
    -helptext "Select any one of the following" \
    -editable 0

  set curproc [processing_mode]
  .rcf.2.disp setvalue @$curproc

  LabelEntry .rcf.2.outvar -relief sunken \
    -label "Output Variable:" -helptext "Define output variable" \
    -textvariable outvar -text "rcf_$rcf_var" -width 10

  LabelEntry .rcf.5.premin -relief sunken \
    -label "Pre-filter Elevations (m): Min" \
    -helptext "Use this minimum elevation (in m) before applying RCF. Leave\
      blank for no value" \
    -textvariable prefilter_min -text "" -width 4

  LabelEntry .rcf.5.premax -relief sunken -label "Max" \
    -helptext "Use this maximum elevation (in m) before applying RCF. Leave\
      blank for no value" \
    -textvariable prefilter_max -text "" -width 4

  LabelEntry .rcf.5.tai -relief sunken -label "No. of iterations" \
    -helptext "Number of RCF iterations to perform (default = 3)" \
    -textvariable tai -text 3 -width 2

  LabelEntry .rcf.5.tw -relief sunken -label "TIN elev width (cm)" \
    -helptext "Vertical range (in cm) used in each iteration to densify the\
      point cloud after triangulating" \
    -textvariable tw -text 20 -width 4

  checkbutton .rcf.6.inter -text "Interactive?" -variable interactive \
    -command {
      if {($interactive == 1) && ($plottriagwin == "")} {
        set plottriagwin 4
      }
    }
  set interactive 0

  LabelEntry .rcf.6.triagwin -relief sunken -label "Plot TIN in win:" \
    -helptext "Plot TIN during each iteration in this window number. Leave\
      blank to not plot the TINs. If interactive is set, default window is 4." \
    -textvariable plottriagwin -width 4

  LabelEntry .rcf.6.distthresh -relief sunken -label "Distance Threshold (m):" \
    -textvariable distthresh -text 100  -width 4 \
    -helptext "Enter distance threshold (in meters) that sets the maximum\
      allowable length of any side of a triangle in the TIN model.  Set to 0\
      if you don't want to use it.  Defaults to 100m."

  Button .rcf.3.go -width 8 -text "Go" \
    -command {
      global varlist outvar
      switch [.rcf.2.disp getvalue] {
        "0" {set mode 1}
        "1" {set mode 2}
        "2" {set mode 3}
      }
      append_varlist $outvar
      set rcfmode [.rcf.0.mode getvalue]
      if { $rcfmode == 1 } {
        if {$plottriagwin != ""} {
          set plottriag 1
        } else {
          set plottriag ""
        }
        set datawin [.l1wid.bf45.p.3 getvalue]
        exp_send "$outvar = rcf_triag_filter($rcf_var, buf=$buf, w=$w,\
          no_rcf=$no_rcf, mode=$mode, tw=$tw, interactive=$interactive,\
          tai=$tai, plottriag=$plottriag, plottriagwin=$plottriagwin,\
          prefilter_min=$prefilter_min, prefilter_max=$prefilter_max,\
          distthresh=$distthresh, datawin=$datawin );\r\n"
      } else {
        exp_send "$outvar = rcfilter_eaarl_pts($rcf_var, buf=$buf, w=$w,\
          no_rcf=$no_rcf, mode=$mode);\r\n"
      }
      destroy .rcf
    }
  Button .rcf.3.cancel -text "Cancel" -width 8 -command {
    destroy .rcf
  }
  pack .rcf.1.buf .rcf.1.w .rcf.1.no -side left -padx 3
  pack .rcf.2.varname \
    .rcf.2.varlist \
    .rcf.2.dispname \
    .rcf.2.disp \
    .rcf.2.outvar \
    -side left -padx 3
  pack .rcf.3.go .rcf.3.cancel -side left -padx 5
  pack .rcf.0.mode .rcf.0.help -side left -padx 5
  pack .rcf.5.premin .rcf.5.premax .rcf.5.tai .rcf.5.tw -side left -padx 5
  pack .rcf.6.inter .rcf.6.triagwin .rcf.6.distthresh -side left -padx 5
  pack .rcf.0 .rcf.1 .rcf.2 .rcf.5 .rcf.6 .rcf.3 -side top -pady 10
  pack forget .rcf.5 .rcf.6
}

.l1wid.mb.post add command -label "Determine Roll Bias" -underline 0 \
  -command {
    global win_no varlist bias pro_var

    destroy .l1bias
    toplevel .l1bias
    wm title .l1bias "Determine Roll Bias"

    foreach x {1 2 3 4 5 6} {
      frame .l1bias.$x
      pack .l1bias.$x -side top
    }

    if { [info exists bias ] == 0 } {
      exp_send "updatebias\r"
      expect ">"
      exp_send "updatebias\r"
      expect ">"
    }
    set slope 0
    set iob 0
    set inout 1
    set width 5
    set flwin 4
    set var $pro_var

    LabelEntry .l1bias.1.var -relief sunken -borderwidth 3 -width 10 \
      -label "Variable:" -helptext "EAARL source data" \
      -textvariable var -text $var

    Label .l1bias.1.winl -text "in window:"
    SpinBox .l1bias.1.win -justify center -range {0 7 1} -width 2 \
      -textvariable win_no

    Label .l1bias.1.transl -text "Then click"
    Button .l1bias.1.transbutton -text "Get Transect" \
      -helptext "Click to get transect" \
      -command {
        exp_send "transdata = get_transect($var, win=$win_no, update=1,\
          width=$width)\r"
        expect ">"
        .l1bias.3.plot configure -state normal
        .l1bias.3.winl configure -state normal
        .l1bias.3.win configure -state normal
        .l1bias.3.pick configure -state normal
        .l1bias.3.inout configure -state normal
        .l1bias.3.auto configure -state normal
      }

    Button .l1bias.1.help -text "Help!" -helptext "Click for directions" \
      -command {
        tk_messageBox -icon warning \
          -message "1) Start with data array plotted in a window and raw EAARL\
            data loaded. Set the variable and window and click Get Transect.\
            \r2) Drag a line perpendicular to the flightlines you wish to\
            examine. In the window that appears, zoom into the top, type\
            something, and hit enter. Now drag a box over the section of the\
            transect you wish to keep.\
            \r3) Click the plot button to display the loaded transect. In\
            order to determine the bias automatically all flightlines must be\
            traveling the same direction, so you'll need to remove whichever\
            direction is the minority.\
            \r4) Click 'select flightlines' and simply type 'y' or 'n' to keep\
            or remove each flightline. Now you have a set of flightlines going\
            the same direction.\
            \r5) Finally, determine whether the flightlines are going into or\
            out of the screen. If they are going INTO the screen, check the\
            box." \
          -type ok
      }

    LabelEntry .l1bias.2.width -relief sunken -width 3 \
      -label "Width:" -helptext "Transect width" \
      -textvariable width -text $width

    LabelEntry .l1bias.2.bias -relief sunken -width 10 \
      -label "Current Roll Bias:" -helptext "Current Roll Bias" \
      -textvariable bias -text $bias

    LabelEntry .l1bias.2.slope -relief sunken -width 10 \
      -label "Current Slope:" -helptext "Current slope" \
      -textvariable slope -text $slope

    Button .l1bias.3.plot -text "Plot" \
      -helptext "Click to plot flightline transect" \
      -command {
        exp_send "plot_flightline_transect(transdata, $flwin)\r"
        expect ">"
      }

    Label .l1bias.3.winl -text "in win:"
    SpinBox .l1bias.3.win -justify center -range {0 7 1} \
      -width 2 -textvariable flwin

    Button .l1bias.3.pick -text "Select Flightlines" \
      -helptext "Click to select which flightlines to keep" \
      -command {
        exp_send "transdata=selgoodflightlines(transdata, win=$flwin)\r"
        expect ">"
      }

    checkbutton .l1bias.3.inout -text "in/out:" -variable iob \
      -command {
        set inout [lindex {1 -1} $iob]
      }

    Button .l1bias.3.auto -text "Determine bias" \
      -helptext "Click to automatically determine roll bias" \
      -command {
        exp_send "goodroll=find_roll_bias(transdata,0,$inout,update=1)\r"
        expect ">"
      }

    pack .l1bias.1.var .l1bias.1.winl .l1bias.1.win .l1bias.1.transl \
      .l1bias.1.transbutton .l1bias.1.help -side left
    pack .l1bias.2.width .l1bias.2.bias .l1bias.2.slope -side left
    pack .l1bias.3.plot .l1bias.3.winl .l1bias.3.win .l1bias.3.pick \
      .l1bias.3.inout .l1bias.3.auto -side left

    foreach w {plot winl win pick inout auto} {
      .l1bias.3.$w configure -state disabled
    }
  }

ComboBox .l1wid.bf4.1.d -text "Define Region..." -width 15 -values \
  {
    Rubberband\ Box\
    Points\ in\ Polygon\
    Rectangular\ Coords\
  }\
  -helptext "Select region to process using any of the following methods" \
  -editable 0 \
  -modifycmd {
    set defr [.l1wid.bf4.1.d getvalue]
    puts $defr
    if {$defr == 0} {
      if { $_ytk(annoying_help) == "Yes" } {
        set result [tk_messageBox  -icon info \
          -message "Drag a Rectangular Box in Window $_map(window) to define\
            the region." \
          -type okcancel -title "Message"]
      } else {
        set result "ok"
      }
      if {$result == "ok"} {
        exp_send "q = gga_win_sel(2, win=$_map(window));\r"
        expect ">"
      }
    }
    if {$defr == 1} {
      if { $_ytk(annoying_help) == "Yes" } {
        set result [tk_messageBox  -icon info \
          -message "Draw a Polygon in Window $_map(window) to define a region\
            using a series of left mouse clicks. To complete the polygon,\
            middle mouse click OR <Ctrl> and left mouse click." \
          -type okcancel -title "Message"]
      } else {
        set result "ok"
      }
      if {$result == "ok"} {
        exp_send "q = gga_pip_sel(1, win=$_map(window));\r"
        expect ">"
      }
    }
    if {$defr == 2} {
      destroy .l1widc
      toplevel .l1widc
      frame .l1widc.lon
      frame .l1widc.1
      frame .l1widc.utm
      ComboBox .l1widc.utm.1 -text "Coordinate System" -width 18 \
        -values "LatLon UTM" -editable 0 \
        -helptext "Select the Coordinate System."
      LabelEntry .l1widc.utm.2 -width 6 -relief sunken -label "UTM Zone: " \
        -helptext "Enter UTM Zone Here" \
        -textvariable zone

      LabelEntry .l1widc.lat1 -width 12 -relief sunken \
        -label "NorthLat/Max.Northing " \
        -helptext "Enter Maximum Latitude in degrees or Maximum UTM Northing\
          in meters Here"\
        -textvariable mxlat
      LabelEntry .l1widc.lat2 -width 12 -relief sunken \
        -label "SouthLat/Min.Northing " \
        -helptext "Enter Minimum Latitude in degrees or Minimum UTM Northing\
          in meters Here"\
        -textvariable mnlat

      LabelEntry .l1widc.lon.mn -width 12 -relief sunken \
        -label "WestLon/Min.Easting " \
        -helptext "Enter Westernmost Longitude in degrees or Minimum UTM\
          Easting in meters Here"\
        -textvariable mnlon
      LabelEntry .l1widc.lon.mx -width 12 -relief sunken \
        -label "EastLon/Max.Easting " \
        -helptext "Enter Easternmost Longitude in degrees or Maximum UTM\
          Easting in meters Here"\
        -textvariable mxlon
      Button .l1widc.1.ok -text "OK" -width 5 -command {
        set utm [.l1widc.utm.1 getvalue]
        exp_send "utm = $utm;\
          q = gga_win_sel(2, win=$_map(window),\
            llarr=\[$mnlon, $mxlon, $mnlat, $mxlat\]);\r"
        destroy .l1widc
      }
      Button .l1widc.1.box -text "Plot Region" -width 7 -command {
        exp_send "a_x=\[$mnlon, $mxlon, $mxlon, $mnlon, $mnlon\];\r"
        exp_send "a_y=\[$mnlat, $mnlat, $mxlat, $mxlat, $mnlat\];\r"
        exp_send "window, $_map(window); plg, a_y, a_x;\r"
      }

      Button .l1widc.1.cancel -text "Cancel" -width 5 -command {
        destroy .l1widc
      }
      pack .l1widc.utm.1 .l1widc.utm.2 -side left
      pack .l1widc.lon.mn .l1widc.lon.mx -side left -padx 4
      pack .l1widc.utm .l1widc.lat1 .l1widc.lon .l1widc.lat2 -side top -pady 5
      pack .l1widc.1.ok .l1widc.1.box .l1widc.1.cancel -side left
      pack .l1widc.1 -side top

    }
    if {$defr == -1} {
      error "Please Define Region."
    }
  }

proc processing_mode {} {
  global plot_settings
  switch -- $plot_settings(processing_mode) {
    "First Return Topo" {
      return 0
    }
    "Submerged Topo" {
      return 1
    }
    "Topo Under Veg" {
      return 2
    }
    "Multi Peak Veg" {
      return 3
    }
    "Direct. Wave Spectra" {
      return 4
    }
    default {
      return -1
    }
  }
}

proc processing_mode_changed {a b c} {
  global curs
  if {$b eq "processing_mode"} {
    set curs [processing_mode]
    if {$curs == 1} {
      .l1wid.bf4.2.surf configure -state active
    } else {
      .l1wid.bf4.2.surf configure -state disabled
    }
  }
}

trace remove \
  variable plot_settings(processing_mode) write processing_mode_changed
trace add \
  variable plot_settings(processing_mode) write processing_mode_changed

iwidgets::combobox .l1wid.bf4.1.p \
  -textvariable plot_settings(processing_mode) \
  -editable false
eval .l1wid.bf4.1.p insert list end $l1pro_data(processing_mode)

proc processing_mode_by_index {index} {
  global plot_settings l1pro_data
  set plot_settings(processing_mode) \
    [lindex $l1pro_data(processing_mode) $index]
}

ComboBox .l1wid.bf4.1.m -text "Method"  \
  -width 7 \
  -helptext "Batch or single processing" \
  -editable 0 \
  -values "Batch Single"

Label .l1wid.bf4.1.lw -text "in Win:"
SpinBox .l1wid.bf4.1.sw -justify center -range {0 7 1} \
  -width 2 -textvariable _map(window)

checkbutton .l1wid.bf4.2.cen -variable usecentroid \
  -text "Correct Range\nWalk with Centroid"

checkbutton .l1wid.bf4.2.surf -variable avg_surf \
  -text "Use Fresnel reflections\nto determine water surface"

.l1wid.bf4.2.surf configure -state disabled

checkbutton .l1wid.bf45.p.fma -text "Auto\nFma" -variable l1pro_fma

Button .l1wid.bf45.p.1 -text "Plot" -command {
  plot_fltlines 0
}

Button .l1wid.bf45.p.14 -text "Variable:" -command {
  varlist_plot
}

proc pro_var_changed {a b c} {
  global var_settings plot_settings pro_var cbv
  if {$cbv == 0} {
    set var_settings($plot_settings(var)) [array get plot_settings]
    if {[info exists var_settings($pro_var)]} {
      array set plot_settings $var_settings($pro_var)
    } else {
      set plot_settings(var) $pro_var
    }
  }
}

trace remove variable pro_var write pro_var_changed
trace add variable pro_var write pro_var_changed

iwidgets::combobox .l1wid.bf45.p.15 \
  -textvariable pro_var \
  -editable false
.l1wid.bf45.p.15 component list configure \
  -listvariable varlist

proc cbar_tool { } {
  global cbvc
  set w .cbartool
  destroy $w
  toplevel $w
  wm title $w "Color Bar Tool"
  frame $w.1
  Button $w.both -text "Both" \
    -helptext "Interactively set Cmin, Cmax by \
      clicking in the histogram window" \
    -command {
      exp_send "set_cbar, \"both\" \r"
      expect ">"
    }
  Button $w.cmax -text "Cmax" \
    -helptext "Interactively set Cmax by \
      clicking in the histogram window" \
    -command {
      exp_send "set_cbar, \"cmax\" \r"
    }
  Button $w.cmin -text "Cmin" \
    -helptext "Interactively set Cmin by \
      clicking in the histogram window" \
    -command {
      exp_send "set_cbar, \"cmin\" \r"
    }
  Button $w.dismiss -text "Dismiss" -command {
    destroy .cbartool
  }
  pack \
    $w.both \
    $w.cmax \
    $w.cmin \
    $w.dismiss \
    -side top \
    -fill both
}


Label .l1wid.bf45.p.2 -text "in Win:"
SpinBox .l1wid.bf45.p.3 -justify center -range {0 7 1} \
  -width 2 -textvariable win_no

proc display_type {} {
  global plot_settings
  switch -- $plot_settings(display_type) {
    "First Return Topography" {
      return 0
    }
    "Submerged Topography" {
      return 1
    }
    "Water Depth" {
      return 2
    }
    "Bare Earth Topography" {
      return 3
    }
    "Surface Amplitude" {
      return 4
    }
    "Bottom Amplitude" {
      return 5
    }
    "Canopy Height" {
      return 6
    }
    default {
      return -1
    }
  }
}

Label .l1wid.bf45.p.25 -text "Mode:"
iwidgets::combobox .l1wid.bf45.p.5 \
  -textvariable plot_settings(display_type) \
  -editable false
eval .l1wid.bf45.p.5 insert list end $l1pro_data(display_types)

proc display_type_by_index {index} {
  global plot_settings l1pro_data
  set plot_settings(display_type) \
    [lindex $l1pro_data(display_types) $index]
}

Button .l1wid.bf45.q.2 -text "Histogram\nElevations" \
  -helptext "Generate and display a histogram of all the first return\
    elevations" \
  -command {
    global cbvc plot_settings
    set ptype [processing_mode]
    set disp_type [display_type]
    set var_type $pro_var
    if {$disp_type == -1} {
      tk_messageBox  -icon warning \
        -message "You need to specify the type of data before using this\
          function!" \
        -type ok
    }
    if {$ptype == 0} {
      exp_send "hst = hist_fs($var_type, win=7, dofma=1); \r"
    }
    if {$ptype == 1} {
      if {$disp_type == 0} {
        exp_send "hst = hist_fs($var_type, win=7, dofma=1);\r"
      } else {
        exp_send "hst = hist_depth($var_type, win=7, dofma=1); \r"
      }
    }
    if {$ptype == 2} {
      if {$disp_type == 0} {
        exp_send "hst = hist_fs($var_type, win=7, dofma=1);\r"
      } else {
        exp_send "hst = hist_veg($var_type, win=7, dofma=1); \r"
      }
    }
    cbar_tool
    set cbvc(cmin) $plot_settings(cmin)
    set cbvc(cmax) $plot_settings(cmax)
  }

Button .l1wid.bf45.q.1 -text "Pixel\nWaveform" \
  -helptext "Click to jump to raster, pulse, and image for xyz point" \
  -command {
    global bconst plot_settings pro_var
    if {$bconst == 1} {
      set bconst 2
    }
    set ptype [processing_mode]
    set disp_type [display_type]
    set var_type $pro_var
    if {$disp_type == -1} {
      tk_messageBox  -icon warning \
        -message "You need to specify the type of data before using this\
          function!" \
        -type ok
    }

    # Only ptypes 1 and 3 use bconst, so by default it is void
    set bconstarg ""
    if {$ptype == 1 || $ptype == 3} {
      set bconstarg $bconst
    }

    if {[lindex {0 1 2 3} $ptype] >= 0} {
      exp_send "mindata = raspulsearch($var_type, win=$win_no,\
        cmin=$plot_settings(cmin), cmax=$plot_settings(cmax),\
        msize=$plot_settings(msize), disp_type=$disp_type, ptype=$ptype,\
        lmark=lmark, bconst=$bconstarg);\r"
    }
  }

Button .l1wid.bf45.q.3 -text "Color\nBar" \
  -command {
    global win_no plot_settings
    exp_send "window, $win_no;\
      colorbar, $plot_settings(cmin), $plot_settings(cmax), drag=1\r"
  }
Button .l1wid.bf45.q.4 -text "Elevation\nClipper" \
  -command {
    global varlist plot_settings
    destroy .l1clip
    toplevel .l1clip
    wm title .l1clip "Elevation Clipper"
    frame .l1clip.05
    frame .l1clip.1
    frame .l1clip.2
    frame .l1clip.3
    frame .l1clip.4
    set ptype [processing_mode]
    Label .l1clip.05.varname -text "Input Variable:"

    iwidgets::combobox .l1clip.05.varlist \
      -textvariable pro_var -editable false \
      -selectioncommand {
        global pro_var outvar curvar
        set curvar $pro_var
        set outvar $pro_var
      }
    .l1clip.05.varlist component list configure \
      -listvariable ::varlist

    checkbutton .l1clip.1.ymin -variable ymin \
      -command {
        if {$ymin == 1} {
          set yrange 0
          .l1clip.1.min.sb configure -state normal
          .l1clip.1.min.lb configure -state normal
          .l1clip.1.min.sc configure -state normal
          .l1clip.3.range.sb configure -state disabled
          .l1clip.3.range.lb configure -state disabled
          .l1clip.3.range.sc configure -state disabled
        }
        if {$ymin == 0} {
          .l1clip.1.min.sb configure -state disabled
          .l1clip.1.min.lb configure -state disabled
          .l1clip.1.min.sc configure -state disabled
        }
      }
    set ymin 1
    checkbutton .l1clip.2.ymax -variable ymax \
      -command {
        if {$ymax == 1} {
          set yrange 0
          .l1clip.2.max.sb configure -state normal
          .l1clip.2.max.lb configure -state normal
          .l1clip.2.max.sc configure -state normal
          .l1clip.3.range.sb configure -state disabled
          .l1clip.3.range.lb configure -state disabled
          .l1clip.3.range.sc configure -state disabled
        }
        if {$ymax == 0} {
          .l1clip.2.max.sb configure -state disabled
          .l1clip.2.max.lb configure -state disabled
          .l1clip.2.max.sc configure -state disabled
        }
      }
    set ymax 1
    checkbutton .l1clip.3.yrange -variable yrange -state disabled \
      -command {
        set yrange_elv 0
      }

    sst .l1clip.2.max max_elv "Maximum Elevation:" {-100 5000.0 0.1}
    sst .l1clip.1.min min_elv "Minimum Elevation:" {-100 5000.0 0.1}
    sst .l1clip.3.range range_elv "Vertical Range:" {0 300.0 0.1}

    set max_elv $plot_settings(cmax)
    set min_elv $plot_settings(cmin)
    set range_elv $cdelta

    set curvar  [lindex $varlist [.l1clip.05.varlist getvalue]]
    LabelEntry .l1clip.35 -relief sunken -label "Output Variable:" \
      -helptext "Define output variable" \
      -textvariable outvar -text "$curvar"

    Button .l1clip.4.ok -text "Clip Data" -width 5 -command {
      global outvar curvar

      set ptype [processing_mode]
      set dtype [display_type]
      if {$ptype == 0} {
        ##for surface topography
        if {$ymin == 1 && $ymax == 1} {
          exp_send "$outvar = $curvar\(where(\
            ($curvar.elevation >= $min_elv*100) &\
            ($curvar.elevation <= $max_elv*100)));\r"
          expect ">"
        } else {
          if {$ymin == 1} {
            exp_send "$outvar = $curvar\(where(\
              $curvar.elevation >= $min_elv*100));\r"
            expect ">"
          }
          if {$ymax == 1} {
            exp_send "$outvar = $curvar\(where(\
              $curvar.elevation <= $max_elv*100));\r"
            expect ">"
          }
        }
        if {$yrange == 1} {
          exp_send "sel_ptr = rcf($curvar.elevation,$range_elv*100,mode=2);\
            $outvar = $curvar(*sel_ptr(1));\r"
          expect ">"
        }
      }
      if {$ptype == 1} {
        ##for bathymetry
        if {$dtype == 1} {
          if {$ymin == 1 && $ymax == 1} {
            exp_send "$outvar = $curvar\(where(\
              ($curvar.elevation+$curvar.depth >= $min_elv*100) &\
              ($curvar.elevation+$curvar.depth <= $max_elv*100) ));\r"
            expect ">"
          } else {
            if {$ymin == 1} {
              exp_send "$outvar = $curvar\(where((\
                $curvar.elevation+$curvar.depth) >= $min_elv\*100));\r"
              expect ">"
            }
            if {$ymax == 1} {
              exp_send "$outvar = $curvar\(where((\
                $curvar.elevation+$curvar.depth) <= $max_elv*100));\r"
              expect ">"
            }
          }
          if {$yrange == 1} {
            exp_send "sel_ptr = rcf(($curvar.elevation+$curvar.depth),\
                $range_elv*100, mode=2);\
              $outvar = $curvar\(*sel_ptr(1));\r"
            expect ">"
          }
        }
        if {$dtype == 0} {
          if {$ymin == 1 && $ymax == 1} {
            exp_send "$outvar = $curvar\(where(\
              ($curvar.elevation >= $min_elv*100) &\
              ($curvar.elevation <= $max_elv*100) ));\r"
            expect ">"
          } else {
            if {$ymin == 1} {
              exp_send "$outvar = $curvar\(where(\
                $curvar.elevation >= $min_elv*100));\r"
              expect ">"
            }
            if {$ymax == 1} {
              exp_send "$outvar = $curvar\(where(\
                $curvar.elevation <= $max_elv*100));\r"
              expect ">"
            }
          }
          if {$yrange == 1} {
            exp_send "sel_ptr = rcf($curvar.elevation,$range_elv*100,mode=2);\
              $outvar = $curvar\(*sel_ptr(1));\r"
            expect ">"
          }
        }
        if {$dtype == 2} {
          if {$ymin == 1 && $ymax == 1} {
            exp_send "$outvar = $curvar\(where(\
              ($curvar.depth >= $min_elv*100) &\
              ($curvar.depth <= $max_elv*100) ));\r"
            expect ">"
          } else {
            if {$ymin == 1} {
              exp_send "$outvar = $curvar\(where(\
                $curvar.depth >= $min_elv*100));\r"
            }
            if {$ymax == 1} {
              exp_send "$outvar = $curvar\(where(\
                $curvar.depth <= $max_elv*100));\r"
            }
          }
          if {$yrange == 1} {
            exp_send "sel_ptr = rcf($curvar.depth,$range_elv*100,mode=2);\
              $outvar = $curvar\(*sel_ptr(1));\r"
          }
        }
      }
      if {$ptype == 2} {
        ##for vegetation
        if {$dtype == 0} {
          if {$ymin == 1 && $ymax == 1} {
            exp_send "$outvar = $curvar\(where(\
              ($curvar.elevation >= $min_elv*100) &\
              ($curvar.elevation <= $max_elv*100)));\r"
            expect ">"
          } else {
            if {$ymin == 1} {
              exp_send "$outvar = $curvar(where\(\
                $curvar.elevation >= $min_elv*100));\r"
            }
            if {$ymax == 1} {
              exp_send "$outvar = $curvar(where\(\
                $curvar.elevation <= $max_elv*100));\r"
            }
          }
          if {$yrange == 1} {
            exp_send "sel_ptr = rcf($curvar.elevation,$range_elv*100,mode=2);\
              $outvar = $curvar\(*sel_ptr(1));\r"
          }
        }
        if {$dtype == 3} {
          if {$ymin == 1 && $ymax == 1} {
            exp_send "$outvar = $curvar\(where(\
              ($curvar.lelv >= $min_elv*100) &\
              ($curvar.lelv <= $max_elv*100) ));\r"
            expect ">"
          } else {
            if {$ymin == 1} {
              exp_send "$outvar = $curvar\(where(\
                $curvar.lelv >= $min_elv*100));\r"
            }
            if {$ymax == 1} {
              exp_send "$outvar = $curvar\(where(\
                $curvar.lelv <= $max_elv*100));\r"
            }
          }
          if {$yrange == 1} {
            exp_send "sel_ptr = rcf($curvar.lelv,$range_elv*100,mode=2);\
              $outvar = $curvar\(*sel_ptr(1));\r"
          }
        }
      }
      destroy .l1clip
    }

    Button .l1clip.4.dismiss -text "Close" -width 5 -command {
      destroy .l1clip
    }

    pack .l1clip.05.varname .l1clip.05.varlist -side left -padx 5
    pack .l1clip.1.ymin .l1clip.1.min -side left -padx 5
    pack .l1clip.2.ymax .l1clip.2.max -side left -padx 5
    pack .l1clip.3.yrange .l1clip.3.range -side left -fill x

    pack .l1clip.4.ok .l1clip.4.dismiss -side left -padx 5
    pack .l1clip.05 .l1clip.1 .l1clip.2 .l1clip.3 .l1clip.35 .l1clip.4 -side top -pady 5

    .l1clip.3.range.sb configure -state disabled
    .l1clip.3.range.lb configure -state disabled
    .l1clip.3.range.sc configure -state disabled
    set range_elv 0
  }

Button .l1wid.bf45.q.44 -text "Test and\nClean" -command {
  global varlist pro_var
  set curvar $pro_var
  exp_send "$curvar = test_and_clean($curvar)\r"
}

frame .l1wid.bf45.q.f45
Button .l1wid.bf45.q.f45.1 -text "2K Grid" -font {Helvetica -8} -command {
  exp_send "draw_grid, $win_no\r"
}

Button .l1wid.bf45.q.f45.2 -text "2K Name" -font {Helvetica -8} -command {
  exp_send "show_grid_location, $win_no\r"
}

frame .l1wid.bf45.q.f46
Button .l1wid.bf45.q.f46.1 -text "QQ Grid" -font {Helvetica -8} -command {
  exp_send "draw_qq_grid, $win_no\r"
}

Button .l1wid.bf45.q.f46.2 -text "QQ Name" -font {Helvetica -8} -command {
  exp_send "show_qq_grid_location, $win_no\r"
}


checkbutton .l1wid.bf45.q.5 -text "Set Plot Limits" -variable usecentroid

frame  .l1wid.bf45.sc.1

ComboBox .l1wid.bf45.r.1 -text "Copy points using..." -width 16\
  -values { \
    Rubberband\ Box \
    Points\ in\ Polygon \
    Single\ Pixel\
    Select\ Cell\/Quad\/Tile \
  } \
  -helptext "Copy points to \'workdata\' using any of the following methods:\
    \n Rubberband Box\
    \n Points in Polygon\
    \n Single Pixel" \
  -editable 0 \
  -modifycmd {
    global varlist pro_var

    set selr [.l1wid.bf45.r.1 getvalue]
    if {$selr == 0} {
      set var_type $pro_var
      set selection [tk_messageBox -icon info \
        -message "Drag a Rectangular Box in Window $win_no to define region." \
        -type okcancel -title "Message"]
      if {$selection == "ok"} {
        exp_send "workdata = sel_data_rgn($var_type, mode=2, win=$win_no)\r"
        expect ">"
      }
    }
    if {$selr == 1} {
      set selection  [tk_messageBox -icon info \
        -message "Draw a Polygon in Window $win_no to define a region using a\
          series of left mouse clicks.  To complete the polygon, middle mouse\
          click OR <Ctrl> and left mouse click." \
        -type okcancel -title "Message" ]
      if {$selection == "ok"} {
        exp_send "workdata = sel_data_rgn($var_type, mode=3, win=$win_no)\r"
        expect ">"
      }
    }
    if {$selr == 2} {
      exp_send "workdata = select_points($var_type, win=$win_no);\r"
      expect ">"
    }
    if {$selr == 3} {
      set selection [tk_messageBox -icon info \
        -message "Select a cell (250m by 250m) region by dragging a region in\
          window $win_no within the required cell."\
        -type okcancel -title "Message" ]
      if {$selection == "ok"} {
        exp_send "workdata = select_region($var_type, win=$win_no, plot=1);\r"
        expect ">"
      }
    }
    if {$selr == -1} {
      error "Please Define Region."
    }
    append_varlist workdata
  }

ComboBox .l1wid.bf45.r.7 -text "Filter tools..." -width 16 \
  -values { \
    Keep \
    Remove \
    Replace \
    RCF \
    Re-Process \
    Datum-Convert \
  } \
  -helptext "Choose any of the following tools:" -editable 0 \
  -modifycmd {
    global varlist

    set self [.l1wid.bf45.r.7 getvalue]
    if {$self == 0} {
      keep_proc
    }
    if {$self == 1} {
      removing_proc
    }
    if {$self == 2} {
      replace_proc
    }
    if {$self == 3} {
      rcf_region
    }
    if {$self == 4} {
    }
    if {$self == 5} {
      datum_proc
    }
    if {$self == -1} {
      error "Please Define Region."
    }
  }
proc removing_proc {} {
  global varlist curvar plot_settings pro_var
  destroy .rem
  toplevel .rem
  frame .rem.05
  frame .rem.07 -relief raised -bd 1
  frame .rem.08 -relief raised -bd 1
  frame .rem.09
  wm title .rem "Remove Points Using..."
  Label .rem.05.varname -text "Input Variable:"

  iwidgets::combobox .rem.05.varlist \
    -textvariable ::pro_var -editable false \
    -selectioncommand {
      global curvar pro_var
      set curvar $pro_var
    }
  .rem.05.varlist component list configure \
    -listvariable ::varlist

  frame .rem.06
  Label .rem.06.typetext -text "Data type:"
  # IMPORTANT NOTE: Do not change the order of GEO and VEG__ for the values of
  # the ComboBox below. A function parameter for the pipthresh function for
  # this gui is dependent on the index number of the selection.
  ComboBox .rem.06.type -textvariable remove_type -editable 1 -width 12\
    -values {\
      GEO\ or\ VEG__\
      FS\
    }
  if {[display_type] == 0} {
    .rem.06.type setvalue @1
  } else {
    .rem.06.type setvalue @0
  }

  ComboBox .rem.1 -text "Remove points using..." -width 16\
    -values { \
      Rubberband\ Box \
      Points\ in\ Polygon \
      Single\ Pixel\
      PIP-Thresh\
    } \
    -helptext "Remove points from \'workdata\' using any of the following \
      methods:\
      \n Rubberband Box\
      \n Points in Polygon\
      \n Single Pixel" \
    -editable 0 \
    -modifycmd {
      set removemode [.rem.1 getvalue]
      if {$removemode == 3} {
        pack forget .rem.2 .rem.3 .rem.4
        pack .rem.08 .rem.07
        pack .rem.07.a .rem.07.min .rem.07.minthresh -side left
        pack .rem.08.a .rem.08.max .rem.08.maxthresh -side left
        pack .rem.09 .rem.09.a
        pack .rem.2 .rem.3 -side left -padx 5 -pady 5
        set min_thresh $plot_settings(cmin)
        set max_thresh $plot_settings(cmax)
      } else {
        pack forget .rem.2 .rem.3 .rem.4
        pack forget .rem.07 .rem.08 .rem.09
        pack .rem.2 .rem.3 .rem.4 -side left -padx 5 -pady 5
      }
    }
  Label .rem.07.a -text "Min. Threshold:"
  Label .rem.08.a -text "Max. Threshold:"
  Label .rem.09.a -text "WARNING: Cannot undo action." -justify center
  checkbutton .rem.07.min -variable min \
    -command {
      set state [lindex {disabled normal} $min]
      .rem.07.minthresh configure -state $state
    }
  checkbutton .rem.08.max -variable max \
    -command {
      set state [lindex {disabled normal} $max]
      .rem.08.maxthresh configure -state $state
    }
  SpinBox .rem.07.minthresh -range {-100.0 5000.0 0.1} -textvariable min_thresh
  SpinBox .rem.08.maxthresh -range {-100.0 5000.0 0.1} -textvariable max_thresh
  set min 1
  set max 1
  .rem.07.min select
  .rem.08.max select
  set min_thresh $plot_settings(cmin)
  set max_thresh $plot_settings(cmax)

  Button .rem.2 -width 8 -text "Go" \
    -command {
      global varlist outvar selr curvar pro_var

      set selr [.rem.1 getvalue]
      if {$selr == 0} {
        set var_type $pro_var
        set selection [tk_messageBox -icon info \
          -message "Drag a Rectangular Box in Window $win_no to define a\
            region." \
          -type okcancel -title "Message"]
        if {$selection == "ok"} {
          exp_send "croppeddata=\[\];\
            $curvar = sel_data_rgn($curvar, mode=2, win=$win_no, exclude=1)\r"
          expect ">"
        }
      }
      if {$selr == 1} {
        set selection  [tk_messageBox  -icon info \
          -message "Draw a Polygon in Window $win_no to define a region using\
            a series of left mouse clicks. To complete the polygon, middle\
            mouse click OR <Ctrl> and left mouse click." \
          -type okcancel -title "Message" ]
        if {$selection == "ok"} {
          exp_send "croppeddata=\[\];\
            $curvar = sel_data_rgn($curvar, mode=3, win=$win_no, exclude=1)\r"
          expect ">"
        }
      }
      if {$selr == 2} {
        set selection [tk_messageBox  -icon info \
          -message "Select points to remove from window $win_no" \
          -type okcancel -title "Message"]
        if {$selection == "ok"} {
          exp_send "croppeddata=\[\];\
            $curvar = select_points($curvar, win=$win_no, exclude=1);\r"
          expect ">"
        }
      }
      if {$selr == 3} {
        if {[.rem.06.type getvalue] == 1} {
          set val [.rem.06.type getvalue]
        } else {
          set val ""
        }
        if { $min == 0 && $max == 0 } {
          tk_messageBox -icon warning \
            -message "You have not set any threshold limits!" \
            -type ok -title "ERROR!"
        } else {
          # If we don't want to use a threshhold, we set it to void
          set min_arg [expr {$min ? $min_thresh ? ""}]
          set max_arg [expr {$max ? $max_thresh ? ""}]
          exp_send "croppeddata=\[\];\
            $curvar = pipthresh($curvar, mode=$val,\
              minthresh=$min_arg, maxthresh=$max_arg);\r"
        }
      }
      if {$selr == -1} {
        error "Please Define Region."
      } else {
        append_varlist $curvar
      }
    }
  Button .rem.3 -width 8 -text "Dismiss" -command {
    destroy .rem
  }
  Button .rem.4 -width 8 -text "Undo Last\nRemove" -command {
    exp_send "if(is_array(croppeddata)) $curvar = grow($curvar,croppeddata);\r"
    expect ">"
  }

  pack .rem.05.varname .rem.05.varlist -side left -padx 5
  pack .rem.06.typetext .rem.06.type -side left
  pack .rem.05 .rem.06 .rem.1 -pady 8
  pack .rem.08 .rem.07 .rem.09
  pack .rem.2 .rem.3 .rem.4 -side left -padx 5 -pady 5
}


proc datum_proc {} {
  global varlist curvar pro_var
  destroy .con
  toplevel .con

  wm title .con "Convert data from w84 to n88..."

  frame .con.05

  Label .con.05.varname -text "Input Variable:"
  iwidgets::combobox .con.05.varlist \
    -textvariable ::pro_var -editable false \
    -selectioncommand {
      global curvar pro_var
      set curvar $pro_var
    }
  .con.05.varlist component list configure \
    -listvariable ::varlist

  Label .con.02 -text "The converted variable is named\
    n88_(currentvariablename)"
  Button .con.1 -width 8 -text "Go" \
    -command {
      set convar "n88_$curvar"
      exp_send "$convar = data_datum_converter($curvar);\r"
      expect ">"
    }

  pack .con.05.varname .con.05.varlist -side left -padx 5
  pack .con.05 .con.02 .con.1  -side top -pady 10

  append_varlist "n88_$curvar"
}

proc keep_proc {} {
  global varlist curvar pro_var
  destroy .sel
  toplevel .sel
  wm title .sel "Keep Points Using..."
  frame .sel.05

  Label .sel.05.varname -text "Input Variable:"
  iwidgets::combobox .sel.05.varlist \
    -textvariable ::pro_var -editable false \
    -selectioncommand {
      global curvar pro_var
      set curvar $pro_var
    }

  ComboBox .sel.1 -text "Keep points using..." -width 16\
    -values { \
      Rubberband\ Box \
      Points\ in\ Polygon \
      Single\ Pixel\
    } \
    -modifycmd {
      global sels keep_var
      set sels [.sel.1 getvalue]
      if {$sels == 2} {
        set grow_keep 1
        set keep_var "finaldata"
      } else {
        set keep_var $curvar
      }
    } \
    -helptext "Keep points from \'workdata\' using any of the following\
      methods:\
      \n Rubberband Box\
      \n Points in Polygon\
      \n Single Pixel" \
    -editable 0

  checkbutton .sel.grow -text "Grow output variable" -variable grow_keep
  LabelEntry .sel.15 -relief sunken -label "Output Variable:" \
    -helptext "Define output variable" \
    -textvariable keep_var -text "workdata"

  Button .sel.2 -width 8 -text "Go" \
    -command {
      global varlist outvar sels keep_var curvar pro_var

      set sels [.sel.1 getvalue]
      if {$sels == 0} {
        set var_type $pro_var
        set selection [tk_messageBox  -icon info \
          -message "Drag a Rectangular Box in Window $win_no to define\
            region." \
          -type okcancel -title "Message"]
        if {$selection == "ok"} {
          if {$grow_keep == 0} {
            exp_send "$keep_var = sel_data_rgn($curvar, mode=2, win=$win_no)\r"
            expect ">"
          } else {
            exp_send "$keep_var = grow($keep_var,\
              sel_data_rgn($curvar, mode=2, win=$win_no));\r"
            expect ">"
          }
        }
      }
      if {$sels == 1} {
        set selection  [tk_messageBox  -icon info \
          -message "Draw a Polygon in Window $win_no to define a region using\
            a series of left mouse clicks.To complete the polygon, middle\
            mouse click OR <Ctrl> and left mouse click." \
          -type okcancel -title "Message" ]
        if {$selection == "ok"} {
          if {$grow_keep == 0} {
            exp_send "$keep_var = sel_data_rgn($curvar, mode=3, win=$win_no)\r"
            expect ">"
          } else {
            exp_send "$keep_var = grow($keep_var,\
              sel_data_rgn($curvar, mode=3, win=$win_no));\r"
            expect ">"
          }
        }
      }
      if {$sels == 2} {
        set selection [tk_messageBox  -icon info \
          -message "Select points to keep from window $win_no" \
          -type okcancel -title "Message"]
        if {$selection == "ok"} {
          if {$grow_keep == 0} {
            exp_send "$keep_var = select_points($curvar, win=$win_no);\r"
            expect ">"
          } else {
            exp_send "$keep_var = grow($keep_var,\
              select_points($curvar, win=$win_no));\r"
            expect ">"
          }
        }
      }
      if {$sels == -1} {
        error "Please Define Region."
      } else {
        append_varlist $curvar
      }
    }
  Button .sel.3 -width 8 -text "Dismiss" -command {
    destroy .sel
  }

  pack .sel.05.varname .sel.05.varlist -side left -padx 5
  pack .sel.05 .sel.1 .sel.grow .sel.15 -side top -pady 10
  pack .sel.2 .sel.3 -side left -padx 5 -pady 5
}

proc replace_proc {} {
  global varlist curvar croppeddata have_replaced have_undone rcf_buf_rgn \
    pro_var origvar
  set have_undone 0
  set have_replaced 0
  destroy .rep
  toplevel .rep
  wm title .rep "Replace Points Using..."
  frame .rep.05
  frame .rep.005
  frame .rep.15

  set sameinput 0
  Label .rep.05.varname -text "Input Variable:"

  iwidgets::combobox .rep.05.varlist \
    -textvariable pro_var -editable false \
    -selectioncommand {
      global curvar pro_var
      set curvar $pro_var
    }
  .rep.05.varlist component list configure \
    -listvariable ::varlist

  Label .rep.005.varname -text "Original Data Variable:"

  iwidgets::combobox .rep.005.varlist \
    -textvariable origvar -editable false
  .rep.005.varlist component list configure \
    -listvariable ::varlist

  set origvar $pro_var

  # Note: In code below, the yorick variables "croppeddata" and "workdata" are
  # created through sel_data_rgn
  #   croppeddata = (selected filtered points);
  #   workdata = (selected original data points);
  ComboBox .rep.1 -text "Select points to replace using..." -width 28 \
    -values { \
      Rubberband\ Box \
      Points\ in\ Polygon \
      Window\ Limits \
    } \
    -helptext "Select points to replace using any of the following methods:\
      \n Rubberband Box\
      \n Points in Polygon\
      \n Window Limits.\
      \nSelected points from the original data array will be written to\
      variable \"workdata\"" \
    -editable 0 \
    -modifycmd {
      set curidx [.rep.05.varlist getvalue]
      set curvar [lindex $varlist $curidx]
      set defr [.rep.1 getvalue]
      set sel_points buf_points
      set buffered_var bufferdata
      global rcf_buf_rgn
      if {$rcf_buf_rgn > 0} {
        if {$defr == 0} {
          set result [tk_messageBox  -icon info \
            -message "Drag a Rectangular Box in Window $win_no to define\
              region." \
            -type okcancel -title "Message"]
          if {$result == "ok"} {
            exp_send "$keep_var = $curvar;\r"
            exp_send "$sel_points = mouse(1,1,\
              \"Hold the left mouse button down, select a region:\");"
            expect ">"
            exp_send "temp_rgn = add_buffer_rgn($sel_points,\
              $rcf_buf_rgn, mode=1);\r"
            expect ">"
            exp_send "workdata = sel_data_rgn($origvar, mode=4, win=$win_no,\
              rgn=temp_rgn);\r"
            expect ">"
          }
        } elseif {$defr == 1} {
          set result [tk_messageBox -icon info \
            -message "Draw a Polygon in Window $win_no to define a region\
              using a series of left mouse clicks. To complete the polygon,\
              middle mouse click OR <Ctrl> and left mouse click." \
            -type okcancel -title "Message"]
          if {$result == "ok"} {
            exp_send "$keep_var = $curvar;\r"
            # For eval purposes, success stores if getPoly_add_buffer command
            # was successful. The yorick variables buf_points, temp_rgn, and
            # workdata are made.
            exp_send "success = getPoly_add_buffer($rcf_buf_rgn,\
              origdata=$origvar, windw=$win_no);\r"
            expect ">"
          }
        } elseif {$defr == 2} {
            exp_send "$keep_var = $curvar;\r"
            exp_send "window, $win_no;\
              $sel_points=limits()(1:4);\
              temp_rgn = add_buffer_rgn($sel_points,$rcf_buf_rgn,mode=3);\r"
            expect ">"
            exp_send "workdata = sel_data_rgn($origvar, mode=4, win=$win_no,\
              rgn=temp_rgn);\r"
            expect ">"
          }
          set have_replaced 0
          set have_undone 0
        } else {
          if {$defr == 0} {
            set result [tk_messageBox  -icon info \
              -message "Drag a Rectangular Box in Window $win_no to define\
                region." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              exp_send "$keep_var = sel_data_rgn($curvar, mode=2, win=$win_no,\
                exclude=1, make_workdata=1, origdata=$origvar);\r"
              expect ">"
              set have_replaced 0
              set have_undone 0
            }
          }
          if {$defr == 1} {
            set result [tk_messageBox  -icon info \
              -message "Draw a Polygon in Window $win_no to define a region\
                using a series of left mouse clicks. To complete the polygon,\
                middle mouse click OR <Ctrl> and left mouse click." \
              -type okcancel -title "Message"]
            if {$result == "ok"} {
              exp_send "$keep_var = sel_data_rgn($curvar, mode=3, win=$win_no,\
                exclude=1, make_workdata=1, origdata=$origvar);\r"
              expect ">"
              set have_replaced 0
              set have_undone 0
            }
          }
          if {$defr == 2} {
            exp_send "$keep_var = sel_data_rgn($curvar, mode=1, win=$win_no,\
              exclude=1, make_workdata=1, origdata=$origvar);\r"
            set have_replaced 0
            set have_undone 0
          }
        #end if/else rcf_buf_rgn
        }
    }

  Button .rep.type -text "Filter selected points" -width 15 -bd 5 \
    -command {
      global curvar have_replaced have_undone croppeddata outvar rcf_buf_rgn \
        sel_points
      if {$have_undone == 1} {
        if {$rcf_buf_rgn > 0} {
          exp_send "workdata = tempdata;\r"
        } else {
          exp_send "$keep_var = $keep_var (1: - numberof(croppeddata));\r"
        }
      } elseif {$have_replaced == 1} {
        if {$rcf_buf_rgn > 0} {
          exp_send "workdata = tempdata;\r"
        } else {
          exp_send "$keep_var = $keep_var (1: - numberof($outvar));\r"
        }
      }
      rcf_region
      .rcf.2.varlist setvalue @4
      set curvar [.rcf.2.varlist getvalue]
      set outvar rcf_workdata
      set have_replaced 0
      set have_undone 0
    }

  LabelEntry .rep.15.1 -relief sunken -label "Output Variable:" \
    -helptext "Define output variable" \
    -textvariable keep_var -text "finaldata"
  checkbutton .rep.15.2 -text "Same as input variable" -variable sameinput \
    -command {
      if {$sameinput == 1} {
        set keep_var $curvar
      }
    }
  LabelEntry .rep.15.3 -relief sunken -label "Buffer Region (m):" -width 5 \
    -helptext "Define the amount of buffer used in filtering for the selected\
      points" \
    -textvariable rcf_buf_rgn -text "0"

  Button .rep.15.4 -text "Click \[HERE\] for info" -bd 0 \
    -command {
      tk_messageBox -icon info \
        -message "Points in the buffer region will be used for filtering, but\
          will not be replaced into the output array." \
        -type ok -title "Use a buffer region help"
    }

# Significant change made by Jeremy Bracone 4/4/05
# Do No Replace as been fixed and now acts as an undo while Replace acts as a
# redo. Replace will put filtered data into output array, "Do Not Replace" will
# put original data into output array. If a replace or "Do Not Replace" has
# already been done, hitting replace or Do not will have no effect. If replace
# or "Do Not Replace" has already been done, hitting one will undo the action
# of the other and perform the expected operation; i.e. Replace was done, now
# hit Do Not Replace and it will take out the data inserted in the Replace and
# put in the original data. Same is true for opposite situation.
  Button .rep.2 -width 8 -text "Replace..." -bd 5 \
    -command {
      global varlist outvar reps keep_var curvar origvar have_replaced \
        have_undone croppeddata
      set selection [tk_messageBox -icon question \
        -message "Append array $outvar to $keep_var?" \
        -type yesno -title "Warning" ]
      if {$selection == "yes" && $have_replaced == 0 && $have_undone == 0} {
        if {$rcf_buf_rgn > 0} {
          # have to save workdata since sel_data_rgn with exclude set to 1 will
          # over-write it
          set $outvar rcf_workdata
          exp_send "tempdata = workdata;\r"
          exp_send "$keep_var = sel_data_rgn($keep_var, mode=4,\
            rgn=$sel_points, win=$win_no, exclude=1, make_workdata=1,\
            origdata=$origvar);\r"
          expect ">"
          # This is kind of confusing, but $outvar = rcf_workdata (love this
          # confuciated variable hiding)
          exp_send "workdata = tempdata;\
            $outvar = sel_data_rgn($outvar, mode=4, win=$win_no,\
              rgn=$sel_points);\r"
        }
        exp_send "$keep_var = grow($keep_var,$outvar);\r"
      }
      if {$selection == "yes" && $have_replaced == 0 && $have_undone == 1} {
        exp_send "$keep_var = $keep_var (1: - numberof(croppeddata));\r"
        exp_send "$keep_var = grow($keep_var, $outvar);\r"
        set have_undone 0
      }
      expect ">"
      set have_replaced 1
    }
  Button .rep.4 -width 10 -text "Do Not Replace..." -bd 5 \
    -command {
      global varlist outvar reps keep_var curvar origvar
      set selection [tk_messageBox -icon question \
        -message "Append ORIGINAL cropped array croppeddata to $keep_var?" \
        -type yesno -title "Warning" ]
      if {$selection == "yes"} {
        if {$have_replaced == 0 && $have_undone == 0} {
          if {$rcf_buf_rgn > 0} {
            # have to save workdata since sel_data_rgn with exclude set to 1
            # will over-write it
            set $outvar rcf_workdata
            exp_send "tempdata = workdata;\r"
            exp_send "$keep_var = sel_data_rgn($keep_var, mode=4,\
              rgn=$sel_points, win=$win_no, exclude=1, make_workdata=1,\
              origdata=$origvar);\r"
            expect ">"
            exp_send "workdata = tempdata;\
              $outvar = sel_data_rgn($outvar, mode=4, win=$win_no,\
                rgn=$sel_points);\r"
          }
          exp_send "$keep_var = grow($keep_var,croppeddata);\r"
        }
        if {$have_replaced == 1 && $have_undone == 0} {
          exp_send "$keep_var = $keep_var (1: - numberof($outvar));\r"
          exp_send "$keep_var = grow($keep_var, croppeddata);\r"
        }
        expect ">"
        set have_undone 1
        set have_replaced 0
      }
    }
  Button .rep.3 -width 8 -text "Close" -command {
    destroy .rep
  }

  Button .rep.5 -width 3 -text "Help" -command {
    tk_messageBox -icon info \
      -message "Hitting replace adds new filtered array to the output array\
        which Do Not Replace adds the original data back in." \
      -type ok -title "Info 1 of 3"
    tk_messageBox -icon info \
      -message "Once a replace or Do Not Replace has been done, the effects of\
        one can be replaced by the other." \
      -type ok -title "Info 2 of 3"
    tk_messageBox -icon info \
      -message "Example: Hit replace and insert filtered data, then hit DO NOT\
        REPLACE, and inserted data is taken out and original put in." \
      -type ok -title "Info 3 of 3"
  }

  pack .rep.05.varname .rep.05.varlist -side left -padx 5
  pack .rep.005.varname .rep.005.varlist -side left -padx 5
  pack .rep.15.1 .rep.15.2 -side top -pady 3
  pack .rep.15.4 .rep.15.3 -side right
  pack .rep.05 .rep.005 .rep.15 .rep.1 .rep.type  -side top -pady 10
  pack .rep.2 .rep.4 .rep.3 -side left -padx 5 -pady 5
  pack .rep.5 -side left -pady 5
}
Button .l1wid.bf45.r.5 -text "Append2Tile" -command {
  set curvar  $pro_var
  set selection  [tk_messageBox  -icon question \
    -message "Append \'$curvar\' array to final data array?" \
    -type yesno -title "Warning" ]
  if {$selection == "yes"} {
    exp_send "finaldata = grow(finaldata,$curvar);\r"
    expect ">"
  }
}
Button .l1wid.bf45.r.6 -text "Save Tile" -command {
  global tilefname initialpath

  if {[info exists initialpath] == 0} {set initialpath "~/"}
  exp_send "if (is_void(curzone)) curzone = 17;\
    tilefname = set_tile_filename(win=$win_no);\r"
  expect ">"
  if {[info exists tilefname] == 0} {
    set tilefname ""
  }
  set ofname [tk_getSaveFile -initialdir $initialpath \
    -defaultextension "*.pbd" \
    -initialfile $tilefname \
  ]
  if {$ofname != ""} {
    exp_send "$tilename = ifinaldata;\
      vname=tilename;\
      save, createb(\"$ofname\"), vname, $tilename;\r"
    expect ">"
  }
}


# This procedure builds a widget composed of a Label, a Spinbox, and a scale so
# one can enter values by direct entry, the spin clicks, or the scale.
proc sst {w var lbl rg} {
  frame $w
  SpinBox $w.sb -textvariable $var \
    -range $rg \
    -width 6
  scale $w.sc -showvalue 0 -orient horizontal  \
    -variable $var \
    -from [lindex $rg 0] \
    -to   [lindex $rg 1] \
    -resolution [ lindex $rg 2 ]
  label $w.lb -text $lbl
  pack $w.lb $w.sb $w.sc -side left -fill x -expand 1
  return $w
}

proc ud { a b c } {
  global cdelta min_thresh max_thresh plot_settings
  switch -- $b {
    cmax -
    cmin {
      set cdelta [expr {$plot_settings(cmax) - $plot_settings(cmin)}]
    }
  }
  if { [ winfo exists .rem ] } {
    set min_thresh $plot_settings(cmin)
    set max_thresh $plot_settings(cmax)
  }
}

trace remove variable plot_settings(cmin) write ud
trace remove variable plot_settings(cmax) write ud

trace add variable plot_settings(cmin) write ud
trace add variable plot_settings(cmax) write ud

sst .l1wid.bf45.sc.1.cmax plot_settings(cmax) "Cmax:" { -50 5000.0 0.1 }
sst .l1wid.bf45.sc.1.cmin plot_settings(cmin) "Cmin:" { -100 5000.0 0.1 }
sst .l1wid.bf45.sc.1.cdelta cdelta "Cdelta:"  { 0.0  2000.0 0.1 }
grid .l1wid.bf45.sc.1.cmax   -in .l1wid.bf45.sc.1 -column 0 -row 0 -sticky "e"
grid .l1wid.bf45.sc.1.cdelta -in .l1wid.bf45.sc.1 -column 0 -row 1 -sticky "e"
grid .l1wid.bf45.sc.1.cmin   -in .l1wid.bf45.sc.1 -column 0 -row 2 -sticky "e"

.l1wid.bf45.sc.1.cdelta.sc configure -state disabled
.l1wid.bf45.sc.1.cdelta.sb configure -state disabled

LabelFrame  .l1wid.bf45.sc.f -relief sunken -borderwidth 3 -text "Marker:"
SpinBox .l1wid.bf45.sc.f.msize \
  -range {0.1 10.0 0.1}  \
  -textvariable plot_settings(msize) \
  -helptext "Enter Marker Size (msize)" \
  -width 5

SpinBox .l1wid.bf45.sc.f.marker \
  -range {0 9 1}  \
  -textvariable plot_settings(mtype) \
  -helptext "Enter Marker Type (See help, marker for more details)" \
  -width 5

frame .l1wid.bf45.sc.g
LabelFrame .l1wid.bf45.sc.g.sk -relief groove -borderwidth 3 -text "Skip:"
SpinBox .l1wid.bf45.sc.g.sk.skip \
  -range {1 1000 1} \
  -textvariable skip \
  -helptext "Enter plot points to skip" \
  -width 5

checkbutton .l1wid.bf45.sc.g.fma -text "Auto Fma" -variable l1pro_fma

Button .l1wid.bf45.sc.pl -text "Plot" -width 6 -height 2 -bd 5 -command {
  plot_fltlines 0
}
pack \
  .l1wid.bf45.sc.f.msize \
  .l1wid.bf45.sc.f.marker \
   -side top
pack .l1wid.bf45.sc.g.sk.skip
pack \
  .l1wid.bf45.sc.g.fma \
  .l1wid.bf45.sc.g.sk \
  -side top -pady 5

Button .l1wid.bf4.2.proc -text "Process Now" -width 20 -bd 5\
  -command {
    global list lrnindx pro_var varlist
    set list {}
    set lrnindx {}
    exp_send "utm = $utm\n"
    set ptype [processing_mode]
    set defr [.l1wid.bf4.1.d getvalue]
    exp_send "ptype = $ptype\n\r"
    if {$defr == 3} {
      exp_send "q = gga_win_sel(2, win=6,\
        llarr=\[$mnlon, $mxlon, $mnlat, $mxlat\]);\r"
    }
    if {$ptype == 0} {
      exp_send "fs_all = make_fs(latutm=1, q=q, ext_bad_att=1,\
        usecentroid=$usecentroid);\r"
      expect ">"
      set pro_var [lindex $varlist 0]
    }
    if {$ptype == 1} {
      exp_send "depth_all = make_bathy(latutm = 1, q = q, ext_bad_depth=1,\
        ext_bad_att=1, avg_surf=$avg_surf);\r"
      expect ">"
      set pro_var [lindex $varlist 1]
    }
    if {$ptype == 2} {
      exp_send "veg_all = make_veg(latutm=1, q=q, ext_bad_att=1,\
        ext_bad_veg=1, use_centroid=$usecentroid);\r"
      expect ">"
      set pro_var [lindex $varlist 2]
    }
    if {$ptype == 3} {
      exp_send "cveg_all = make_veg(latutm=1, q=q, use_be_peak=$usecentroid,\
        multi_peaks=1);\r"
      expect ">"
      set pro_var [lindex $varlist 3]
    }
    if { $ptype == 4 }  {
      exp_send "process_for_dws,q\r"
      expect ">"
    }
  }

pack \
  .l1wid.bf4.1.d \
  .l1wid.bf4.1.p \
  .l1wid.bf4.1.m \
  .l1wid.bf4.1.lw \
  .l1wid.bf4.1.sw \
  -side left \
  -padx 5

pack  .l1wid.bf4.2.cen .l1wid.bf4.2.surf .l1wid.bf4.2.proc -side left -padx 10

grid .l1wid.bf4.1 -pady 10
grid .l1wid.bf4.2
#pack .l1wid.bf4.1 .l1wid.bf4.2 -side top -pady 10

#pack \
#  .l1wid.bf1 \
#  .l1wid.bf2 \
#  .l1wid.bf3 \
#  .l1wid.bf4 \
#  -side top -expand 1 -fill both

pack .l1wid.bf45.sc.1  -side left  -padx 3
pack .l1wid.bf45.sc.f .l1wid.bf45.sc.g .l1wid.bf45.sc.pl -side left -padx 5

pack \
  .l1wid.bf45.r.1 \
  .l1wid.bf45.r.7 \
  .l1wid.bf45.r.5 \
  .l1wid.bf45.r.6 \
  -side left

pack \
  .l1wid.bf45.q.f45.1 \
  .l1wid.bf45.q.f45.2 \
  -side top

pack \
  .l1wid.bf45.q.f46.1 \
  .l1wid.bf45.q.f46.2 \
  -side top

pack \
  .l1wid.bf45.q.1 \
  .l1wid.bf45.q.2  \
  .l1wid.bf45.q.3 \
  .l1wid.bf45.q.4  \
  .l1wid.bf45.q.44 \
  .l1wid.bf45.q.f45 \
  .l1wid.bf45.q.f46 \
  -side left

pack \
  .l1wid.bf45.p.14 \
  .l1wid.bf45.p.15 \
  .l1wid.bf45.p.25 \
  .l1wid.bf45.p.5 \
  .l1wid.bf45.p.2 \
  .l1wid.bf45.p.3 \
  -side left -fill x  -padx 2

pack \
  .l1wid.bf45.p \
  .l1wid.bf45.sc \
  .l1wid.bf45.q \
  .l1wid.bf45.r \
  -side top -fill x -expand 1

grid .l1wid.bf1
grid .l1wid.bf2
grid .l1wid.bf3
grid .l1wid.bf4
grid .l1wid.bf5 -pady 3
grid .l1wid.bf45 -pady 3

#pack \
#  .l1wid.bf5 \
#  .l1wid.bf45 \
#  -side top -pady 3 -fill x


proc send_latlon_to_l1pro {minlon maxlon minlat maxlat utm} {
  global mnlon mxlon mnlat mxlat utm
  set mnlon $minlon
  set mxlon $maxlon
  set mnlat $minlat
  set mxlat $maxlat
}


proc send_rnarr_to_l1pro {bstart bstop brnindx} {
  global start stop list lrnindx
  set start $bstart
  set stop $bstop
  set rnindx $brnindx
  set list1 [concat $start $stop]
  if {[llength $list] == 0} {
    set list $list1
    set lrnindx $rnindx
  } else {
    set list [concat $list $list1 ]
    set lrnindx [concat $lrnindx $rnindx]
  }
}


proc plot_fltlines {sel} {
  global l1pro_fma win_no cdelta varlist skip \
    plot_dpi setll changed_dpi plot_settings pro_var
  #fill in later using what to plot
  set fs 0
  set ba 0
  set de 0
  set lelv 0
  set fint 0
  set lint 0
  set cht 0
  set disp_type [display_type]
  set var_type $pro_var
  if {$disp_type == -1} {
    tk_messageBox  -icon warning \
      -message "You need to specify the type of data to display!" \
      -type ok
  }
  if {$disp_type == 0} { set fs  1}
  if {$disp_type == 1} { set ba  1}
  if {$disp_type == 2} { set de  1}
  if {$disp_type == 3} { set lelv  1}
  if {$disp_type == 4} { set fint 1}
  if {$disp_type == 5} { set lint 1}
  if {$disp_type == 6} { set cht 1}
  set ptype [processing_mode]
  if {$ptype == -1} {
    tk_messageBox  -icon warning \
      -message "You need to specify the type of processed data i.e. topo,\
        bathy or veg!" \
      -type ok
  } else {
    if { $l1pro_fma } {
      if {$changed_dpi == 1} {
        switch -- $plot_dpi {
          75  {
            set width_arg 450
            set height_arg 450
            set dpi_arg 75
            set style_arg work.gs
          }
          100 {
            set width_arg 600
            set height_arg 600
            set dpi_arg 100
            set style_arg work.gs
          }
          1100 {
            set width_arg 1100
            set height_arg 850
            set dpi_arg 100
            set style_arg landscape11x85.gs
          }
        }
        if {[lsearch {75 100 1100} $plot_dpi] >= 0} {
          exp_send "winkill, $win_no;\
            window, $win_no, dpi=$dpi_arg,\
              width=$width_arg, height=$height_arg,\
              style=\"$style_arg\";\
            fma;\
            limits, square=1;\
            window, $win_no, width=0, height=0;\r"
          expect ">"
        }
        set changed_dpi 0
      } else {
        exp_send "window, $win_no; fma;\r"
        expect ">"
      }
    }
    if {$setll} {
      exp_send "limits, _ytk_ll(1), _ytk_ll(2), _ytk_ll(3), _ytk_ll(4);\r"
      expect ">"
    }
  }

  # Set the color bar values in yorick
  ycbar

  if {$ptype == 0} {
    set cmax1 [expr $plot_settings(cmax)*100.]
    set cmin1 [expr $plot_settings(cmin)*100.]
    if {$disp_type == 0} {
      if {$sel == 0} {
        # using display_veg instead of display since it plots faster and works
        # with the skip keyword.
        exp_send "window, $win_no;\
          display_veg, $var_type, win=$win_no,\
            cmin=$plot_settings(cmin), cmax=$plot_settings(cmax),\
            size=$plot_settings(msize), marker=$plot_settings(mtype),\
            edt=1, felv=$fs, lelv=$lelv, fint=$fint, lint=$lint, cht=$cht,\
            skip=$skip;\r"
      } else {
        exp_send "window, $win_no;\
          display, fs_some, win=$win_no, cmin=$cmin1, cmax=$cmax1,\
            size=$plot_settings(msize), marker=$plot_settings(mtype),\
            edt=1;\r"
      }
      expect ">"
    } elseif { $disp_type == 4 } {
      if {$sel == 0} {
        exp_send "window, $win_no;\
          display_veg, $var_type, win=$win_no, edt=1,\
            cmin=$plot_settings(cmin), cmax=$plot_settings(cmax),\
            size=$plot_settings(msize), marker=$plot_settings(mtype),\
            felv=$fs, lelv=$lelv, fint=$fint, lint=$lint, cht=$cht,\
            skip=$skip;\r"
      } else {
        exp_send "window, $win_no;\
          display, fs_some, mode=\"intensity\", win=$win_no,\
            size=$plot_settings(msize), marker=$plot_settings(mtype),\
            cmin=$cmin1, cmax=$cmax1;\r"
      }
      expect ">"
    }
  }
  if {$ptype == 1} {
    if {$sel == 0} {
      exp_send "window, $win_no;\
        plot_bathy, $var_type, win=$win_no, ba=$ba, fs=$fs, de=$de,\
          cmin=$plot_settings(cmin), cmax=$plot_settings(cmax),\
          msize=$plot_settings(msize), marker=$plot_settings(mtype),\
          fint=$fint, lint=$lint, skip=$skip; \r"
    } else {
      exp_send "window, $win_no;\
        plot_bathy, depth_some, win=$win_no, ba=$ba, fs=$fs, de=$de,\
          cmin=$plot_settings(cmin), cmax=$plot_settings(cmax),\
          msize=$plot_settings(msize), marker=$plot_settings(mtype),\
          fint=$fint, lint=$lint, skip=$skip; \r"
    }
    expect ">"
    exp_send "\r"
  }
  if {$ptype == 2} {
    if {$sel == 0} {
      exp_send "window, $win_no;\
        display_veg, $var_type, win=$win_no,\
          cmin=$plot_settings(cmin), cmax=$plot_settings(cmax),\
          size=$plot_settings(msize), marker=$plot_settings(mtype),\
          edt=1, felv=$fs, lelv=$lelv, fint=$fint, lint=$lint,\
          cht=$cht, skip=$skip;\r"
    } else {
      exp_send "window, $win_no;\
        display_veg, veg_some, win=$win_no,\
          cmin=$plot_settings(cmin), cmax=$plot_settings(cmax),\
          size=$plot_settings(msize), marker=$plot_settings(mtype),\
          edt=1, felv=$fs, lelv=$lelv, fint=$fint, lint=$lint,\
          cht=$cht, skip=$skip;\r"
    }
    expect ">"
    exp_send "\r"
  }
  if {$ptype == 3} {
    set cmax1 [expr $plot_settings(cmax)*100.]
    set cmin1 [expr $plot_settings(cmin)*100.]
    if {$disp_type == 0} {
      if {$sel == 0} {
        exp_send "display, $var_type, win=$win_no, cmin=$cmin1, cmax=$cmax1,\
          size=$plot_settings(msize), marker=$plot_settings(mtype),\
          edt=1, skip=$skip;\r"
      } else {
        exp_send "display, cveg_some, win=$win_no, cmin=$cmin1, cmax=$cmax1,\
          size=$plot_settings(msize), marker=$plot_settings(mtype),\
          edt=1, skip=$skip;\r"
      }
      expect ">"
      exp_send "\r"
    } elseif { $disp_type == 4 } {
      if {$sel == 0} {
        exp_send "display, $var_type, mode=\"intensity\", win=$win_no,\
          size=$plot_settings(msize), marker=$plot_settings(mtype),\
          cmin=$cmin1, cmax=$cmax1, skip=$skip;\r"
      } else {
        exp_send "display, cveg_some, mode=\"intensity\", win=$win_no,\
          size=$plot_settings(msize), marker=$plot_settings(mtype),\
          cmin=$cmin1, cmax=$cmax1, skip=$skip;\r"
      }
      expect ">"
      exp_send "\r"
    }
  }
}

proc limits_tool {} {
  # Added by Jeremy Bracone 4/15/05
  # Opens a limits tool that makes a few functions a little quicker to perform.
  # The main function it provides is to set the limits from one window equal to
  # another.
  destroy .limitstool
  toplevel .limitstool
  wm title .limitstool "Limits Tool"
  frame .limitstool.1 -relief groove -bd 4
  label .limitstool.1.t1 -text "Apply limits from window "
  ComboBox .limitstool.1.c1 -text "0" -width 2 -editable 0 \
    -values { 0 1 2 3 4 5 6 7 } \
    -takefocus 0

  label .limitstool.1.t2 -text " to window "
  ComboBox .limitstool.1.c2 -text "0" -width 2 -editable 0 \
    -values { 0 1 2 3 4 5 6 7 } \
    -takefocus 0

  Button .limitstool.1.limits -text "Set Limits" \
    -helptext "Set Limits in window from box 2 equal to limits in window from\
      box 1.\
      \ni.e. Make the second window look like the first." \
    -command {
      set window1 [.limitstool.1.c1 getvalue]
      set window2 [.limitstool.1.c2 getvalue]
      if {$window1 >= 0 && $window2 >= 0} {
        #This function provided by l1pro.i
        exp_send "winlimits($window1,$window2); \r"
      }
    }

  frame .limitstool.2
  Button .limitstool.2.l -text "Limits()" \
    -helptext "Set current window limits to view entire plot" \
    -command {
      exp_send "limits\r"
      expect ">"
    }
  Button .limitstool.2.dismiss -text "Dismiss" -command {
    destroy .limitstool
  }
  pack .limitstool.1 -side top
  pack .limitstool.1.t1 .limitstool.1.c1 .limitstool.1.t2 .limitstool.1.c2 \
    .limitstool.1.limits -side left -fill both
  pack .limitstool.2 -side right
  pack .limitstool.2.dismiss .limitstool.2.l -padx 4 -side right
}

proc write_binary_file { ofname } {
  global ply_type q_type write_some var_type
  if { $ofname != "" }  {
    switch [ file extension $ofname ] {
      ".pbd" {
        if {($ply_type == "") && ($q_type == "")} {
          exp_send "vname=\"$var_type\";\
            save, createb(\"$ofname\"), vname, $var_type; \r"
        } elseif {($ply_type == "") && !($q_type == "")} {
          exp_send "vname=\"$var_type\";\
            qname=\"$q_type\";\
            save, createb(\"$ofname\"), vname, $var_type, qname, $q_type; \r"
        } elseif {!($ply_type == "") && !($q_type == "")} {
          exp_send "vname=\"$var_type\";\
            qname=\"$q_type\";\
            plyname=\"$ply_type\";\
            save, createb(\"$ofname\"), vname, $var_type, qname, $q_type,\
              plyname, $ply_type; \r"
        } else { ;# !($ply_type == "") && ($q_type == "")
          exp_send "vname=\"$var_type\";\
            plyname=\"$ply_type\";\
            save, createb(\"$ofname\"), vname, $var_type, plyname,\
              $ply_type; \r"
        }
        destroy .l1write
      }
      ".bin" -
      ".edf" {
        set opath  "[ file dirname $ofname ]/"
        set ofname [ file tail    $ofname ]
        if { ![ string equal  "" $ofname ] } {
          if {$ptype == 0} {
            if {$write_some == 0} {
              exp_send "write_topo, \"$opath\", \"$ofname\", $var_type; \r"
              expect ">"
            } else {
              exp_send "write_topo, \"$opath\", \"$ofname\", fs_some; \r"
              expect ">"
            }
          } elseif {$ptype == 1} {
            if {$write_some == 0} {
              exp_send "write_bathy, \"$opath\", \"$ofname\", $var_type; \r"
              expect ">"
            } else {
              exp_send "write_bathy, \"$opath\", \"$ofname\", depth_some; \r"
              expect ">"
            }
          } elseif {$ptype == 2} {
            if {$write_some == 0} {
              exp_send "write_veg, \"$opath\", \"$ofname\", $var_type; \r"
              expect ">"
            } else {
              exp_send "write_veg, \"$opath\", \"$ofname\", veg_some; \r"
              expect ">"
            }
          } elseif {$ptype == 3} {
            if {$write_some == 0} {
              exp_send "write_multipeak_veg, $var_type, opath=\"$opath\",\
                ofname=\"$ofname\"; \r"
              expect ">"
            } else {
              exp_send "write_multipeak_veg, cveg_some, opath=\"$opath\",\
                ofname=\"$ofname\"; \r"
              expect ">"
            }
          }
        } else {
          tk_messageBox  -icon warning \
            -message "You need to specify an output file name" \
            -type ok
        }
        set write_some 0
      }
      default {
        tk_messageBox -icon warning \
          -message "You need to specify an output file with a valid file\
            extension (pbd, bin, or edf)" \
          -type ok
      }
    }
  } else {
    tk_messageBox  -icon warning \
    -message "You need to specify an output file name" \
    -type ok
  }
}

proc ycbar { } {
  global cdelta plot_settings
  if { ![ info exists plot_settings(cmax) ] } {
    set plot_settings(cmax) 0
    set plot_settings(cmin) 0
    set cdelta 0
  }
  exp_send "cbar.cmax=$plot_settings(cmax);\
    cbar.cmin=$plot_settings(cmin);\
    cbar.cdelta=$cdelta;\r"
}

source "$src_path/bathctl.ytk"
source "$src_path/data_segments.ytk"
