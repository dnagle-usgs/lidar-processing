# vim: set tabstop=4 softtabstop=4 shiftwidth=4 autoindent shiftround expandtab:

# $Id$

package require dict
package require json

if {![info exists mission_conf]} {
    array set mission_conf [list]
}
if {![info exists mission_date]} {
    set mission_date ""
}

# The procedures in this file are largely identical to those in mission_conf.i.
# Please refer to mission_conf.i for documentation on any procedure without
# documentation here.

proc mission_get {key {date -}} {
    global mission_conf mission_date
    default date $mission_date
    if {[mission_has $key $date]} {
        return $mission_conf([list $date $key])
    } else {
        return
    }
}

proc mission_set {key value {date -}} {
    global mission_conf mission_date
    default date $mission_date
    if {![string length $date]} {
        error "Please provide a date or set mission_date."
    }
    set mission_conf([list $date $key]) $value
}

proc mission_has {key {date -}} {
    global mission_conf mission_date
    default date $mission_date
    return [info exists mission_conf([list $date $key])]
}

proc mission_dates {} {
    global mission_conf
    set dates [list]
    foreach key [array names mission_conf] {
        lappend dates [lindex $key 0]
    }
    return [lsort -unique $dates]
}

proc mission_delete {key {date -}} {
    global mission_conf mission_date
    default date $mission_date
    if {![string length $date]} {
        error "Please provide a date or set mission_date."
    }
    array unset mission_conf [list $date $key]
}

proc mission_delete_date {date} {
    global mission_conf
    array unset mission_conf [list $date *]
}

proc mission_json_export {} {
    global mission_conf
    set data [dict create]
    foreach key [array names mission_conf] {
        dict set data [lindex $key 0] [lindex $key 1] $mission_conf($key)
    }
    set json_list [list]
    dict for {date date_data} $data {
        set date_list [list]
        dict for {key value} $date_data {
            set json_key [json_stringify $key]
            set json_val [json_stringify $value]
            lappend date_list "    \"$json_key\": \"$json_val\""
        }
        set json_date [json_stringify $date]
        set date_out ""
        append date_out "  \"$json_date\": {\n"
        append date_out [join $date_list ",\n"]
        append date_out "\n  }"
        lappend json_list $date_out
    }
    set json_out ""
    append json_out "{\n"
    append json_out [join $json_list ",\n"]
    append json_out "\n}\n"
    return $json_out
}

proc mission_json_import {json} {
    global mission_conf
    set data [::json::json2dict $json]
    array unset mission_conf
    dict for {date date_data} $data {
        dict for {key value} $date_data {
            set mission_conf([list $date $key]) $value
        }
    }
}

proc mission_save {filename} {
    set json_out [mission_json_export]
    set f [open $filename "w"]
    puts -nonewline $f $json_out
    close $f
}

proc mission_load {filename} {
    set f [open $filename "r"]
    set json_in [read $f]
    close $f
    mission_json_import $json_in
}

proc mission_send {} {
    global mission_date
    set data [yorick_stringify [mission_json_export]]
    exp_send "mission_json_import, \"$data\";\r"
    expect ">"
    set yor_date [yorick_stringify $mission_date]
    exp_send "mission_date = \"$yor_date\";\r"
    expect ">"
}

proc mission_receive {} {
    exp_send, "mission_send;\r"
    expect ">"
}

# default varName value
# This is used within a procedure to specify a default value for a parameter.
# This is useful when the default value is dynamic.
proc default {varName value} {
    upvar $varName var
    set caller [info level -1]
    set caller_args [info args [lindex $caller 0]]
    set arg_index [lsearch -exact $caller_args $varName]
    incr arg_index
    if {$arg_index > 0} {
        if {[llength $caller] <= $arg_index} {
            set var $value
        }
    } else {
        error "Calling function does not have parameter $varName"
    }
}

# json_stringify raw_val
# Sanitizes a string using JSON conventions.
proc json_stringify {raw_val} {
    return [string map [list \
        \\  \\\\    \
        \"  \\\"    \
        /   \\/     \
        \n  \\n     \
        \b  \\b     \
        \f  \\f     \
        \r  \\r     \
        \t  \\t     \
    ] $raw_val]
}

# yorick_stringify
# Sanitizes a string so that it can be safely sent to Yorick.
proc yorick_stringify {raw_val} {
    return [string map [list \
        \\  \\\\    \
        \"  \\\"    \
        \n  \\n     \
        \b  \\b     \
        \f  \\f     \
        \r  \\r     \
        \t  \\t     \
    ] $raw_val]
}
