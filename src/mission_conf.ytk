# vim: set tabstop=4 softtabstop=4 shiftwidth=4 autoindent shiftround expandtab:

package require struct::set
package require fileutil
package require misc

if {[catch [list package require json]]} {
    puts "No JSON"
    return
}

source [file join $src_path gui_procs.ytk]

### INITIALIZATION

if {![info exists __mission_conf]} {
    set __mission_conf [dict create]
}
if {![info exists __mission_day]} {
    set __mission_day ""
}

if {![info exists __mission_path]} {
    set __mission_path ""
}

# __mission_cache -- not needed

if {![info exists __mission_settings]} {
    set __mission_settings [dict create \
        "relative paths" [list "data_path" "edb file" "pnav file" \
            "ins file" "ops_conf file" "cir dir" "rgb dir" "rgb file"] \
    ]
}

ybkg require \"mission_conf.i\"
ybkg h_set __mission_settings \"ytk\" 1

### COMMON WITH YORICK

# The procedures in this file are largely identical to those in mission_conf.i.
# Please refer to mission_conf.i for documentation on any procedure without
# documentation here.

proc mission_clear {{sync 1}} {
    global __mission_conf
    set __mission_conf [dict create]
    if {$sync} {
        ycmd mission_clear [list] [list sync 0]
    }
}

proc mission_get {key {day -}} {
    global __mission_conf __mission_day __mission_settings __mission_path
    default day $__mission_day
    if {[mission_has $key $day]} {
        set result [dict get $__mission_conf $day $key]
        set rel_paths [dict get $__mission_settings "relative paths"]
        if {[::struct::set contains $rel_paths $key]} {
            set result [file join $__mission_path $result]
        }
        return $result
    } else {
        return
    }
}

proc mission_set {key value {day -} {sync 1}} {
    global __mission_conf __mission_day __mission_settings __mission_path
    default day $__mission_day
    if {![string length $day]} {
        error "Please provide a day or set __mission_day."
    }
    if {$sync} {
        ycmd mission_set \
            [list [ystr $key] [ystr $value]] \
            [list day [ystr $day] sync 0]
    }
    set rel_paths [dict get $__mission_settings "relative paths"]
    if {[::struct::set contains $rel_paths $key]} {
        set value [::fileutil::relative $__mission_path $value]
    }
    dict set __mission_conf $day $key $value
}

proc mission_has {key {day -}} {
    global __mission_conf __mission_day
    default day $__mission_day
    return [dict exists $__mission_conf $day $key]
}

proc missionday_current {{day NODAYPROVIDED} {sync 1}} {
    global __mission_day
    if {$day ne "NODAYPROVIDED"} {
        set __mission_day $day
        if {$sync} {
            ycmd missionday_current [list [ystr $day]] [list sync 0]
        }
    }
    return $__mission_day
}

proc missionday_list {} {
    global __mission_conf
    set days [list]
    return [lsort [dict keys $__mission_conf]]
}

proc mission_delete {key {day -} {sync 1}} {
    global __mission_conf __mission_day
    default day $__mission_day
    if {![string length $day]} {
        error "Please provide a day or set __mission_day."
    }
    dict unset __mission_conf $day $key
    if {$sync} {
        ycmd mission_delete [list [ystr $key]] [list day [ystr $day] sync 0]
    }
}

proc missionday_add {day {sync 1}} {
    global __mission_conf
    dict set __mission_conf $day [dict create]
    if {$sync} {
        ycmd missionday_add [list [ystr $day]] [list sync 0]
    }
}

proc missionday_delete {day {sync 1}} {
    global __mission_conf
    dict unset __mission_conf $day
    if {$sync} {
        ycmd missionday_delete [list [ystr $day]] [list sync 0]
    }
}

proc missionday_exists {{day -}} {
    global __mission_conf __mission_day
    default day $__mission_day
    if {![string length $day]} {
        error "Please provide a day or set __mission_day."
    }
    return [dict exists $__mission_conf $day]
}

proc missionday_set {hash {day -} {sync 1}} {
    global __mission_conf __mission_day
    default day $__mission_day
    if {![string length $day]} {
        error "Please provide a day or set __mission_day."
    }
    missionday_delete $day $sync
    dict for {key val} $hash {
        mission_set $key $val $day $sync
    }
}

proc missionday_get {{day -}} {
    global __mission_conf __mission_day
    default day $__mission_day
    if {![string length $day]} {
        error "Please provide a day or set __mission_day."
    }
    if {[missionday_exists $day]} {
        return [dict get $__mission_conf $day]
    } else {
        return
    }
}

proc __json_key_str {key val} {
    set val [json_stringify $val]
    return [__json_key_val $key "\"$val\""]
}

proc __json_key_val {key val} {
    set key [json_stringify $key]
    return "\"$key\": $val"
}

proc mission_json_export {} {
    global __mission_conf

    set json_list [list]

    # Build up __mission_conf's data
    set conf_list [list]
    dict for {day day_data} $__mission_conf {
        set day_list [list]
        dict for {key value} $day_data {
            lappend day_list "      [__json_key_str $key $value]"
        }
        set day_val [join $day_list ",\n"]
        set day_val "{\n$day_val\n    }"
        lappend conf_list "    [__json_key_val $day $day_val]"
    }
    set conf_val [join $conf_list ",\n"]
    set conf_val "{\n$conf_val\n  }"
    lappend json_list "  [__json_key_val days $conf_val]"

    set json_out [join $json_list ",\n"]
    set json_out "{\n$json_out\n}\n"
    
    return $json_out
}

proc mission_json_import {json {sync 1}} {
    global __mission_conf
    set data [::json::json2dict $json]
    if {[dict exists $data days]} {
        set __mission_conf [dict get $data days]
    } else {
        set __mission_conf $data
    }
    if {$sync} {
        mission_send
    }
}

proc mission_save {filename} {
    set json_out [mission_json_export]
    set f [open $filename "w"]
    puts -nonewline $f $json_out
    close $f
    logger info "Mission configuration saved to: $filename"
}

proc mission_load {filename} {
    ycmd mission_load [list [ystr $filename]]
}

proc mission_send {} {
    global __mission_day
    ycmd mission_json_import [list [ystr [mission_json_export]]] [list sync 0]
    yset __mission_day = [ystr $__mission_day]
}

proc mission_receive {} {
    ycmd mission_send
}

proc missiondata_cache {action} {
    ycmd missiondata_cache [list [ystr $action]]
}

# missiondata_wrap
# missiondata_unwrap

proc missiondata_load {type {day -}} {
    global __mission_day
    default day $__mission_day

    ycmd missiondata_load [list [ystr $type]] [list day [ystr $day]]
}

proc missiondata_read {filename} {
    ycmd missiondata_read [list [ystr $filename]]
}

proc missiondata_write {filename type {overwrite 1}} {
    ycmd missiondata_write [list [ystr $filename] [ystr $type]] \
        [list overwrite $overwrite]
}

proc mission_path {{path NOPATHPROVIDED} {sync 1}} {
    global __mission_path
    if {$path ne "NOPATHPROVIDED"} {
        set __mission_path $path
        if {$sync} {
            ycmd mission_path [list [ystr $path]] [list sync 0]
        }
    }
    return $__mission_path
}

proc mission_initialize_from_path {mission_path} {
    ycmd mission_initialize_from_path [list [ystr $mission_path]]
}

### UTILITY

proc json_stringify {raw_val} {
# json_stringify raw_val
# Sanitizes a string using JSON conventions.
    return [string map [list \
        \\  \\\\    \
        \"  \\\"    \
        /   \\/     \
        \n  \\n     \
        \b  \\b     \
        \f  \\f     \
        \r  \\r     \
        \t  \\t     \
    ] $raw_val]
}

### GUI CODE

namespace eval mission {
    namespace eval v {
        variable toplevel .mission_conf
        variable dateframe ""
        variable filetypes [list \
            [list JSON .json] \
            [list "All files" *] \
        ]
        variable currentfile ""
        variable config_temp
    }

    proc launch_gui {} {
        if {[winfo exists $v::toplevel]} {
            wm deiconify $v::toplevel
            register_traces
        } else {
            create_gui
        }
    }
    
    proc create_gui {} {
        set win $v::toplevel
        destroy $win

        toplevel $win
        wm resizable $win 0 0
        wm title $win "Mission Configuration"

        set mb $win.mb
        menu $mb
        $win configure -menu $mb

        curry @ namespace code

        menu $mb.file
        $mb add cascade -label File -underline 0 -menu $mb.file

        $mb.file add command -label "New" -command [@ menu_new] -underline 0
        $mb.file add command -label "Open" -command [@ menu_open] -underline 0
        $mb.file add command -label "Save" -command [@ menu_save] -underline 0
        $mb.file add command -label "Save As" -command [@ menu_save_as] \
            -underline 5
        $mb.file add separator
        $mb.file add command -label "Close" -command [@ menu_close] -underline 0

        menu $mb.act
        $mb add cascade -label Actions -underline 0 -menu $mb.act

        $mb.act add command -label "Initialize from mission directory" \
            -underline 0 \
            -command [@ menu_initialize_from_mission_dir]

        $mb.act add separator
        $mb.act add command -label "Launch RGB" -command [@ menu_launch_rgb]
        $mb.act add command -label "Launch CIR" -command [@ menu_launch_cir]
        $mb.act add command -label "Dump CIR" -command [@ menu_dump_cir]
        $mb.act add separator
        $mb.act add command -label "Generate KMZ" -command [@ menu_gen_kmz]
        $mb.act add command -label "Show EDB summary" -command [@ menu_edb_summary]

        menu $mb.cache
        $mb add cascade -label Cache -underline 0 -menu $mb.cache
        $mb.cache add command -label "Enable cache" \
            -command {exp_send "missiondata_cache, \"enable\";\r"}
        $mb.cache add command -label "Disable cache" \
            -command {exp_send "missiondata_cache, \"disable\";\r"}
        $mb.cache add command -label "Preload cache" \
            -command {exp_send "missiondata_cache, \"preload\";\r"}
        $mb.cache add command -label "Clear cache" \
            -command {exp_send "missiondata_cache, \"clear\";\r"}

        set f $win.fraDates
        set v::dateframe $f
        frame $f

        pack $f -expand 1 -fill x

        button $win.btnAdd -text "Add new mission day..." \
            -padx 2m -pady 1m \
            -command [@ date_add]
        pack $win.btnAdd -anchor w

        button $win.btnPath -text "Specify mission path..." \
            -padx 2m -pady 1m \
            -command [@ set_mission_path]
        pack $win.btnPath -anchor w

        button $win.btnRgb -text "All RGB" \
            -padx 2m -pady 1m \
            -command [@ menu_launch_rgb]
        pack $win.btnRgb -anchor w

        button $win.btnCir -text "All Cir" \
            -padx 2m -pady 1m \
            -command [@ menu_launch_cir]
        pack $win.btnCir -anchor w

        wm protocol $win WM_DELETE_WINDOW [@ menu_close]

        uncurry @

        register_traces

        update_gui
    }

    proc register_traces {} {
        global __mission_conf
        trace add variable __mission_conf {write unset} [namespace code update_gui]
    }

    proc unregister_traces {} {
        trace remove variable __mission_conf {write unset} [namespace code update_gui]
    }

    proc menu_new {} {
        mission_clear
    }

    proc menu_open {} {
        global _ytk
        set filename [tk_getOpenFile \
            -initialdir $_ytk(initialdir) \
            -parent $v::toplevel \
            -title "Select the mission configuration file to load" \
            -filetypes $v::filetypes]
        if {$filename ne ""} {
            mission_load $filename
            set v::currentfile $filename
        }
    }

    proc menu_save {} {
        if {$v::currentfile ne ""} {
            mission_save $v::currentfile
        } else {
            menu_save_as
        }
    }

    proc menu_save_as {} {
        set filename [tk_getSaveFile \
            -initialdir [mission_path] \
            -parent $v::toplevel \
            -title "Enter the filename for the mission configuration file" \
            -filetypes $v::filetypes]
        if {$filename ne ""} {
            set v::currentfile $filename
            menu_save
        }
    }

    proc menu_close {} {
        unregister_traces
        wm withdraw $v::toplevel
    }

    proc menu_initialize_from_mission_dir {} {
        set dir [tk_chooseDirectory \
            -parent $v::toplevel \
            -title "Select the mission directory" \
            -mustexist 1]
        if {$dir ne ""} {
            mission_initialize_from_path $dir
            update_gui
        }
    }

    proc menu_launch_rgb {} {
        set rgb_p [list]
        set rgb_t [list]
        foreach day [missionday_list] {
            if {[mission_has "rgb dir" $day]} {
                lappend rgb_p [mission_get "rgb dir" $day]
            }
            if {[mission_has "rgb file" $day]} {
                lappend rgb_t [mission_get "rgb file" $day]
            }
        }
        if {[llength $rgb_p]} {
            set rgb [sf::controller %AUTO%]
            $rgb load rgb::f2006::tarpaths -paths $rgb_p
            ybkg set_sf_bookmarks \"$rgb\"
        } elseif {[llength $rgb_t]} {
            set rgb [sf::controller %AUTO%]
            $rgb load rgb::f2001::tarfiles -files $rgb_t
            ybkg set_sf_bookmarks \"$rgb\"
        }
    }

    proc menu_launch_cir {} {
        set paths [list]
        foreach day [missionday_list] {
            if {[mission_has "cir dir" $day]} {
                lappend paths [mission_get "cir dir" $day]
            }
        }
        if {[llength $paths]} {
            set cir [sf::controller %AUTO%]
            $cir load cir::tarpaths -paths $paths
            ybkg set_sf_bookmarks \"$cir\"
        }
    }

    proc menu_dump_cir {} {
        set outdir [tk_chooseDirectory \
            -title "Select destination for CIR imagery" \
            -initialdir [mission_path]]
        if {$outdir ne ""} {
            ::sf::tools::dump_mission_cir $outdir
        }
    }

    proc menu_gen_kmz {} {
        set response [tk_messageBox -type yesno \
            -icon question -title "Generate KMZ files?" \
            -message "Would you like to generate KMZ files for the current\
                mission configuration? Your KMZ files will be placed in a 'kml'\
                subdirectory of the mission."]
        if {$response eq "yes"} {
            exp_send "kml_mission;\r"
        }
    }

    proc menu_edb_summary {} {
        exp_send "mission_edb_summary\r"
    }

    proc update_gui {args} {
        set f $v::dateframe
        foreach w [winfo children $f] {
            destroy $w
        }
        curry @ namespace code
        foreach date [missionday_list] {
            label $f.lbl$date -text $date
            button $f.btnConfig$date -text Configure \
                -padx 2m -pady 1m \
                -command [@ [list date_config $date]]
            button $f.btnLoad$date -text Load \
                -padx 2m -pady 1m \
                -command [@ [list date_load $date]]
            button $f.btnRgb$date -text RGB \
                -padx 2m -pady 1m \
                -command [@ [list date_rgb $date]]
            button $f.btnCir$date -text Cir \
                -padx 2m -pady 1m \
                -command [@ [list date_cir $date]]
            button $f.btnDelete$date -text X \
                -padx 2m -pady 1m \
                -command [@ [list date_delete $date]]
            grid $f.lbl$date $f.btnConfig$date $f.btnLoad$date \
                $f.btnRgb$date $f.btnCir$date $f.btnDelete$date
            grid $f.lbl$date -sticky w
        }
        uncurry @
    }

    proc __date_config_path_helper {w var dlg} {
        foreach child [list Edb Pnav Ins Ops Cir RgbDir RgbTar] {
            $w.ent$child configure -initialdir [set [set var]([list $dlg data_path])]
        }
    }

    proc date_config {date} {
        set dlg [iwidgets::dialog $v::toplevel.#auto \
            -title "Mission day: $date" \
            -modality application]
        $dlg hide Help
        $dlg hide Apply

        curry % list $dlg
        curry @ namespace code
        curry & namespace which -variable

        $dlg buttonconfigure OK -command [@ [list $dlg deactivate 1]]
        $dlg buttonconfigure Cancel -command [@ [list $dlg deactivate 0]]

        set v::config_temp([% date]) [mission_get date $date]
        set v::config_temp([% data_path]) [mission_get data_path $date]
        set v::config_temp([% "edb file"]) [mission_get "edb file" $date]
        set v::config_temp([% "pnav file"]) [mission_get "pnav file" $date]
        set v::config_temp([% "ins file"]) [mission_get "ins file" $date]
        set v::config_temp([% "ops_conf file"]) [mission_get "ops_conf file" $date]
        set v::config_temp([% "cir dir"]) [mission_get "cir dir" $date]
        set v::config_temp([% "rgb dir"]) [mission_get "rgb dir" $date]
        set v::config_temp([% "rgb file"]) [mission_get "rgb file" $date]

        set w [$dlg childsite]

        iwidgets::Entryfield $w.entDate \
            -labeltext "Date:" \
            -textvariable [& v::config_temp]([% date])

        GUI::FileEntryButton $w.entPath \
            -labeltext "Data path:" \
            -actiontype dir \
            -parent $dlg \
            -initialdir [mission_path] \
            -updatecommand [@ [list __date_config_path_helper $w [& v::config_temp] $dlg]] \
            -textvariable [& v::config_temp]([% data_path])
        GUI::FileEntryButton $w.entEdb \
            -labeltext "EDB file:" \
            -actiontype open \
            -filetypes {
                {{EAARL Database Index files} {.idx}}
                {{All files} *}
            } \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "edb file"])
        GUI::FileEntryButton $w.entPnav \
            -labeltext "PNAV file:" \
            -actiontype open \
            -filetypes {
                {{PNAV files} {.ybin}}
                {{All files} *}
            } \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "pnav file"])
        GUI::FileEntryButton $w.entIns \
            -labeltext "INS file:" \
            -actiontype open \
            -filetypes {
                {{pbd files} {.pbd}}
                {{TANS files} {.ybin}}
                {{All files} *}
            } \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "ins file"])
        GUI::FileEntryButton $w.entOps \
            -labeltext "ops_conf.i file:" \
            -actiontype open \
            -filetypes {
                {{Yorick files} {.i}}
                {{All files} *}
            } \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "ops_conf file"])
        GUI::FileEntryButton $w.entCir \
            -labeltext "CIR path:" \
            -actiontype dir \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "cir dir"])
        GUI::FileEntryButton $w.entRgbDir \
            -labeltext "RGB path (newer datasets):" \
            -actiontype dir \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "rgb dir"])
        GUI::FileEntryButton $w.entRgbTar \
            -labeltext "RGB tar file (older datasets):" \
            -actiontype open \
            -filetypes {
                {{tar files} {.tar}}
                {{All files} *}
            } \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "rgb file"])

        __date_config_path_helper $w [& v::config_temp] $dlg

        foreach ent [list Date Path Edb Pnav Ins Ops Cir RgbDir RgbTar] {
            [$w.ent$ent component entry] configure \
                -width 60
        }

        iwidgets::Labeledwidget::alignlabels \
            $w.entDate \
            $w.entPath $w.entEdb $w.entPnav $w.entIns $w.entOps \
            $w.entCir $w.entRgbDir $w.entRgbTar

        pack \
            $w.entDate \
            $w.entPath $w.entEdb $w.entPnav $w.entIns $w.entOps \
            $w.entCir $w.entRgbDir $w.entRgbTar \
            -side top -pady 5 -padx 10 -fill x -expand yes

        set prompt_user 1
        while {$prompt_user} {
            set missing_needed 0
            set prompt_user 0
            if {[$dlg activate]} {
                set temp_data [dict create]
                set keys [list date data_path "edb file" "pnav file" \
                    "ins file" "ops_conf file" "cir dir" "rgb dir" \
                    "rgb file"]
                foreach key $keys {
                    if {[string length $v::config_temp([% $key])]} {
                        dict set temp_data $key $v::config_temp([% $key])
                    }
                }
                if {[llength [dict keys $temp_data]]} {
                    if {
                        [dict exists $temp_data data_path] &&
                        [dict exists $temp_data "edb file"]
                    } {
                        missionday_set $temp_data $date
                    } else {
                        set missing_needed 1
                    }
                } else {
                    set missing_needed 1
                }
            }
            if {$missing_needed} {
                set response [tk_messageBox \
                    -icon warning -parent $dlg -type yesno \
                    -message "A mission day must have a data path and EAARL\
                        edb file at a minimum. Do you want to return to the\
                        form to enter this information? (Answering 'No'\
                        will abort changes to the entry entirely.)"]
                switch -- $response {
                    yes {set prompt_user 1}
                    no  {set prompt_user 0}
                }
            }
        }

        uncurry %
        uncurry @
        uncurry &

        destroy $dlg
    }

    proc date_delete {date} {
        missionday_delete $date
        update_gui
    }

    proc date_load {date} {
        missionday_current $date
        missiondata_load all
    }

    proc date_rgb {day} {
        if {[mission_has "rgb dir" $day]} {
            set rgb [sf::controller %AUTO%]
            $rgb load rgb::f2006::tarpath -path [mission_get "rgb dir" $day]
            ybkg set_sf_bookmark \"$rgb\" \"$day\"
        } elseif {[mission_has "rgb file" $day]} {
            set rgb [sf::controller %AUTO%]
            $rgb load rgb::f2001::tarfiles -files [list [mission_get "rgb file" $day]]
            ybkg set_sf_bookmark \"$rgb\" \"$day\"
        }
    }

    proc date_cir {day} {
        if {[mission_has "cir dir" $day]} {
            set cir [sf::controller %AUTO%]
            $cir load cir::tarpath -path [mission_get "cir dir" $day]
            ybkg set_sf_bookmark \"$cir\" \"$day\"
        }
    }

    proc date_add {} {
        set dlg [iwidgets::promptdialog $v::toplevel.#auto \
            -modality application \
            -title "Add new mission day" \
            -labeltext "Please enter a name for the mission day (such as YYYY-MM-DD):"]
        $dlg hide Help
        $dlg hide Apply
        focus [$dlg component prompt component entry]
        $dlg center
        if {[$dlg activate]} {
            set date [$dlg get]
            if {[missionday_exists $date]} {
                tk_messageBox \
                    -icon warning -parent $dlg -type ok \
                    -message "That mission day already exists. If you want to\
                        modify, please use the mission day's configure\
                        button."
            } else {
                after idle [list after 0 [namespace code [list date_config $date]]]
            }
        }
        destroy $dlg
    }

    proc set_mission_path {} {
        set continue yes
        if {[llength [missionday_list]] > 0} {
            set continue [tk_messageBox \
                -icon warning -parent $dlg -type yesno \
                -message "Changing the mission path will clear all currently\
                    defined mission days. Are you sure you want to continue?"]
        }
        if {$continue eq "yes"} {
            set dlg [iwidgets::fileselectiondialog $v::toplevel.#auto \
                -title "Specify mission path" \
                -modality application \
                -fileson 0]

            #$dlg hide 1 ;# Filter
            #$dlg default 0
            #$dlg center
            if {[$dlg activate]} {
                set path [$dlg get]
                if {[file isdirectory $path]} {
                    if {$path eq [mission_path]} {
                        tk_messageBox \
                            -icon warning -parent $dlg -type ok \
                            -message "The path you selected is identical to the\
                                path already in use. No change made."
                    } else {
                        mission_clear
                        mission_path $path
                    }
                } else {
                    tk_messageBox \
                        -icon warning -parent $dlg -type ok \
                        -message "The directory you entered does not exist;\
                            aborting."
                }
            }
        }
    }
}
