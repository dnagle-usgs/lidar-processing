# vim: set tabstop=4 softtabstop=4 shiftwidth=4 autoindent shiftround expandtab:

# $Id$

package require dict
package require json
package require struct::set
package require fileutil

### INITIALIZATION

if {![info exists __mission_conf]} {
    set __mission_conf [dict create]
}
if {![info exists __mission_date]} {
    set __mission_date ""
}

if {![info exists __mission_path]} {
    set __mission_path ""
}

# __mission_cache -- not needed

if {![info exists __mission_settings]} {
    set __mission_settings [dict create \
        "relative paths" [list "data_path" "edb file" "pnav file" \
            "dmars file" "ops_conf file"] \
    ]
}

ycmd require [list [ystr mission_conf.i]]
ycmd h_set [list __mission_settings [ystr ytk] 1]

### COMMON WITH YORICK

# The procedures in this file are largely identical to those in mission_conf.i.
# Please refer to mission_conf.i for documentation on any procedure without
# documentation here.

proc mission_get {key {date -}} {
    global __mission_conf __mission_date __mission_settings __mission_path
    default date $__mission_date
    if {[mission_has $key $date]} {
        set result [dict get $__mission_conf $date $key]
        set rel_paths [dict get $__mission_settings "relative paths"]
        if {[::struct::set contains $rel_paths $key]} {
            set result [file join $__mission_path $result]
        }
        return $result
    } else {
        return
    }
}

proc mission_set {key value {date -} {sync 1}} {
    global __mission_conf __mission_date __mission_settings __mission_path
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    if {$sync} {
        ycmd mission_set \
            [list [ystr $key] [ystr $value]] \
            [list date [ystr $date] sync 0]
    }
    set rel_paths [dict get $__mission_settings "relative paths"]
    if {[::struct::set contains $rel_paths $key]} {
        set value [::fileutil::relative $__mission_path $value]
    }
    dict set __mission_conf $date $key $value
}

proc mission_has {key {date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    return [dict exists $__mission_conf $date $key]
}

proc missiondate_current {{date NODATEPROVIDED} {sync 1}} {
    global __mission_date
    if {$date ne "NODATEPROVIDED"} {
        set __mission_date $date
        if {$sync} {
            ycmd missiondate_current [list [ystr $date]] [list sync 0]
        }
    }
    return $__mission_date
}

proc missiondate_list {} {
    global __mission_conf
    set dates [list]
    return [lsort [dict keys $__mission_conf]]
}

proc mission_delete {key {date -} {sync 1}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    dict unset __mission_conf $date $key
    if {$sync} {
        ycmd mission_delete [list [ystr $key]] [list date [ystr $date] sync 0]
    }
}

proc missiondate_add {date {sync 1}} {
    global __mission_conf
    dict set __mission_conf $date [dict create]
    if {$sync} {
        ycmd missiondate_add [list [ystr $date]] [list sync 0]
    }
}

proc missiondate_delete {date {sync 1}} {
    global __mission_conf
    dict unset __mission_conf $date
    if {$sync} {
        ycmd missiondate_delete [list [ystr $date]] [list sync 0]
    }
}

proc missiondate_exists {{date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    return [dict exists $__mission_conf $date]
}

proc missiondate_set {hash {date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    dict set __mission_conf $date $hash
    if {$sync} {
        mission_send;
    }
}

proc missiondate_get {{date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    if {[missiondate_exists $date]} {
        return [dict get $__mission_conf $date]
    } else {
        return
    }
}

proc mission_json_export {} {
    global __mission_conf
    set json_list [list]
    dict for {date date_data} $__mission_conf {
        set date_list [list]
        dict for {key value} $date_data {
            set json_key [json_stringify $key]
            set json_val [json_stringify $value]
            lappend date_list "    \"$json_key\": \"$json_val\""
        }
        set json_date [json_stringify $date]
        set date_out ""
        append date_out "  \"$json_date\": {\n"
        append date_out [join $date_list ",\n"]
        append date_out "\n  }"
        lappend json_list $date_out
    }
    set json_out ""
    append json_out "{\n"
    append json_out [join $json_list ",\n"]
    append json_out "\n}\n"
    return $json_out
}

proc mission_json_import {json {sync 1}} {
    global __mission_conf
    set __mission_conf [::json::json2dict $json]
    if {$sync} {
        mission_send
    }
}

proc mission_save {filename} {
    set json_out [mission_json_export]
    set f [open $filename "w"]
    puts -nonewline $f $json_out
    close $f
}

proc mission_load {filename} {
    set f [open $filename "r"]
    set json_in [read $f]
    close $f
    mission_json_import $json_in
}

proc mission_send {} {
    global __mission_date
    ycmd mission_json_import [list [ystr [mission_json_import]]] [list sync 0]
    yset __mission_date = [ystr $__mission_date]
}

proc mission_receive {} {
    ycmd mission_send
}

proc missiondata_cache {action} {
    ycmd missiondata_cache [list [ystr $action]]
}

# missiondata_wrap
# missiondata_unwrap

proc missiondata_load {type {date -}} {
    global __mission_date
    default date $__mission_date

    ycmd missiondata_load [list [ystr $type]] [list date [ystr $date]]
}

proc missiondata_read {filename} {
    ycmd missiondata_read [list [ystr $filename]]
}

proc missiondata_write {filename type {overwrite 1}} {
    ycmd missiondata_write [list [ystr $filename] [ystr $type]] \
        [list overwrite $overwrite]
}

proc mission_path {{path NOPATHPROVIDED} {sync 1}} {
    global __mission_path
    if {$path ne "NOPATHPROVIDED"} {
        set __mission_path $path
        if {$sync} {
            ycmd mission_path [list [ystr $path]] [list sync 0]
        }
    }
    return $__mission_path
}

proc mission_initialize_from_path {mission_path} {
    ycmd mission_initialize_from_path [list [ystr $mission_path]]
}

### UTILITY

# default varName value
# This is used within a procedure to specify a default value for a parameter.
# This is useful when the default value is dynamic.
proc default {varName value} {
    upvar $varName var
    set caller [info level -1]
    set caller_args [info args [lindex $caller 0]]
    set arg_index [lsearch -exact $caller_args $varName]
    incr arg_index
    if {$arg_index > 0} {
        if {[llength $caller] <= $arg_index} {
            set var $value
        }
    } else {
        error "Calling function does not have parameter $varName"
    }
}

# json_stringify raw_val
# Sanitizes a string using JSON conventions.
proc json_stringify {raw_val} {
    return [string map [list \
        \\  \\\\    \
        \"  \\\"    \
        /   \\/     \
        \n  \\n     \
        \b  \\b     \
        \f  \\f     \
        \r  \\r     \
        \t  \\t     \
    ] $raw_val]
}

