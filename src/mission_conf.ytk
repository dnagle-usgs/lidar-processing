# vim: set tabstop=4 softtabstop=4 shiftwidth=4 autoindent shiftround expandtab:

# $Id$

package require dict
package require struct::set
package require fileutil

if {[catch [list package require json]]} {
    puts "No JSON"
    return
}

source [file join $src_path gui_procs.ytk]
source [file join $src_path misc.ytk]

### INITIALIZATION

if {![info exists __mission_conf]} {
    set __mission_conf [dict create]
}
if {![info exists __mission_date]} {
    set __mission_date ""
}

if {![info exists __mission_path]} {
    set __mission_path ""
}

# __mission_cache -- not needed

if {![info exists __mission_settings]} {
    set __mission_settings [dict create \
        "relative paths" [list "data_path" "edb file" "pnav file" \
            "dmars file" "ops_conf file"] \
    ]
}

ycmd require [list [ystr mission_conf.i]]
ycmd h_set [list __mission_settings [ystr ytk] 1]

### COMMON WITH YORICK

# The procedures in this file are largely identical to those in mission_conf.i.
# Please refer to mission_conf.i for documentation on any procedure without
# documentation here.

proc mission_clear {{sync 1}} {
    global __mission_conf
    set __mission_conf [dict create]
    if {$sync} {
        ycmd mission_clear [list] [list sync 0]
    }
}

proc mission_get {key {date -}} {
    global __mission_conf __mission_date __mission_settings __mission_path
    default date $__mission_date
    if {[mission_has $key $date]} {
        set result [dict get $__mission_conf $date $key]
        set rel_paths [dict get $__mission_settings "relative paths"]
        if {[::struct::set contains $rel_paths $key]} {
            set result [file join $__mission_path $result]
        }
        return $result
    } else {
        return
    }
}

proc mission_set {key value {date -} {sync 1}} {
    global __mission_conf __mission_date __mission_settings __mission_path
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    if {$sync} {
        ycmd mission_set \
            [list [ystr $key] [ystr $value]] \
            [list date [ystr $date] sync 0]
    }
    set rel_paths [dict get $__mission_settings "relative paths"]
    if {[::struct::set contains $rel_paths $key]} {
        set value [::fileutil::relative $__mission_path $value]
    }
    dict set __mission_conf $date $key $value
}

proc mission_has {key {date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    return [dict exists $__mission_conf $date $key]
}

proc missiondate_current {{date NODATEPROVIDED} {sync 1}} {
    global __mission_date
    if {$date ne "NODATEPROVIDED"} {
        set __mission_date $date
        if {$sync} {
            ycmd missiondate_current [list [ystr $date]] [list sync 0]
        }
    }
    return $__mission_date
}

proc missiondate_list {} {
    global __mission_conf
    set dates [list]
    return [lsort [dict keys $__mission_conf]]
}

proc mission_delete {key {date -} {sync 1}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    dict unset __mission_conf $date $key
    if {$sync} {
        ycmd mission_delete [list [ystr $key]] [list date [ystr $date] sync 0]
    }
}

proc missiondate_add {date {sync 1}} {
    global __mission_conf
    dict set __mission_conf $date [dict create]
    if {$sync} {
        ycmd missiondate_add [list [ystr $date]] [list sync 0]
    }
}

proc missiondate_delete {date {sync 1}} {
    global __mission_conf
    dict unset __mission_conf $date
    if {$sync} {
        ycmd missiondate_delete [list [ystr $date]] [list sync 0]
    }
}

proc missiondate_exists {{date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    return [dict exists $__mission_conf $date]
}

proc missiondate_set {hash {date -} {sync 1}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    dict set __mission_conf $date $hash
    if {$sync} {
        mission_send;
    }
}

proc missiondate_get {{date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    if {[missiondate_exists $date]} {
        return [dict get $__mission_conf $date]
    } else {
        return
    }
}

proc mission_json_export {} {
    global __mission_conf
    set json_list [list]
    dict for {date date_data} $__mission_conf {
        set date_list [list]
        dict for {key value} $date_data {
            set json_key [json_stringify $key]
            set json_val [json_stringify $value]
            lappend date_list "    \"$json_key\": \"$json_val\""
        }
        set json_date [json_stringify $date]
        set date_out ""
        append date_out "  \"$json_date\": {\n"
        append date_out [join $date_list ",\n"]
        append date_out "\n  }"
        lappend json_list $date_out
    }
    set json_out ""
    append json_out "{\n"
    append json_out [join $json_list ",\n"]
    append json_out "\n}\n"
    return $json_out
}

proc mission_json_import {json {sync 1}} {
    global __mission_conf
    set __mission_conf [::json::json2dict $json]
    if {$sync} {
        mission_send
    }
}

proc mission_save {filename} {
    set json_out [mission_json_export]
    set f [open $filename "w"]
    puts -nonewline $f $json_out
    close $f
}

proc mission_load {filename} {
    set f [open $filename "r"]
    set json_in [read $f]
    close $f
    mission_json_import $json_in
}

proc mission_send {} {
    global __mission_date
    ycmd mission_json_import [list [ystr [mission_json_export]]] [list sync 0]
    yset __mission_date = [ystr $__mission_date]
}

proc mission_receive {} {
    ycmd mission_send
}

proc missiondata_cache {action} {
    ycmd missiondata_cache [list [ystr $action]]
}

# missiondata_wrap
# missiondata_unwrap

proc missiondata_load {type {date -}} {
    global __mission_date
    default date $__mission_date

    ycmd missiondata_load [list [ystr $type]] [list date [ystr $date]]
}

proc missiondata_read {filename} {
    ycmd missiondata_read [list [ystr $filename]]
}

proc missiondata_write {filename type {overwrite 1}} {
    ycmd missiondata_write [list [ystr $filename] [ystr $type]] \
        [list overwrite $overwrite]
}

proc mission_path {{path NOPATHPROVIDED} {sync 1}} {
    global __mission_path
    if {$path ne "NOPATHPROVIDED"} {
        set __mission_path $path
        if {$sync} {
            ycmd mission_path [list [ystr $path]] [list sync 0]
        }
    }
    return $__mission_path
}

proc mission_initialize_from_path {mission_path} {
    ycmd mission_initialize_from_path [list [ystr $mission_path]]
}

### UTILITY

# json_stringify raw_val
# Sanitizes a string using JSON conventions.
proc json_stringify {raw_val} {
    return [string map [list \
        \\  \\\\    \
        \"  \\\"    \
        /   \\/     \
        \n  \\n     \
        \b  \\b     \
        \f  \\f     \
        \r  \\r     \
        \t  \\t     \
    ] $raw_val]
}

### GUI CODE

namespace eval mission {
    namespace eval v {
        variable toplevel .mission_conf
        variable dateframe ""
        variable modify_commands [list mission_set missiondate_current \
            mission_delete missiondate_add missiondate_delete \
            mission_json_import mission_path mission_clear]
        variable filetypes [list \
            [list JSON .json] \
            [list "All files" *] \
        ]
        variable currentfile ""
        variable config_temp
    }

    proc launch_gui {} {
        if {[winfo exists $v::toplevel]} {
            wm deiconify $v::toplevel
            register_traces
        } else {
            create_gui
        }
    }
    
    proc create_gui {} {
        set win $v::toplevel
        destroy $win

        toplevel $win
        wm resizable $win 0 0
        wm title $win "Mission Configuration"

        set mb $win.mb
        menu $mb
        $win configure -menu $mb

        curry @ namespace code

        menu $mb.file
        $mb add cascade -label File -underline 0 -menu $mb.file

        $mb.file add command -label "New" -command [@ menu_new] -underline 0
        $mb.file add command -label "Open" -command [@ menu_open] -underline 0
        $mb.file add command -label "Save" -command [@ menu_save] -underline 0
        $mb.file add command -label "Save As" -command [@ menu_save_as] \
            -underline 5
        $mb.file add separator
        $mb.file add command -label "Close" -command [@ menu_close] -underline 0

        menu $mb.act
        $mb add cascade -label Actions -underline 0 -menu $mb.act

        $mb.act add command -label "Initialize from mission directory" \
            -underline 0 \
            -command [@ menu_initialize_from_mission_dir]

        set f $win.fraDates
        set v::dateframe $f
        frame $f

        pack $f -expand 1 -fill x

        button $win.btnAdd -text "Add new mission day..." \
            -padx 2m -pady 1m \
            -command [@ date_add]
        pack $win.btnAdd -anchor w

        wm protocol $win WM_DELETE_WINDOW [@ menu_close]

        uncurry @

        register_traces

        update_gui
    }

    proc register_traces {} {
        global __mission_conf
        trace add variable __mission_conf {write unset} [namespace code update_gui]
    }

    proc unregister_traces {} {
        trace remove variable __mission_conf {write unset} [namespace code update_gui]
    }

    proc menu_new {} {
        mission_clear
    }

    proc menu_open {} {
        set filename [tk_getOpenFile \
            -parent $v::toplevel \
            -title "Select the mission configuration file to load" \
            -filetypes $v::filetypes]
        if {$filename ne ""} {
            mission_load $filename
            set v::currentfile $filename
            mission_path [file dirname $filename]
        }
    }

    proc menu_save {} {
        if {$v::currentfile ne ""} {
            mission_save $v::currentfile
        } else {
            menu_save_as
        }
    }

    proc menu_save_as {} {
        set filename [tk_getSaveFile \
            -initialdir [mission_path] \
            -parent $v::toplevel \
            -title "Enter the filename for the mission configuration file" \
            -filetypes $v::filetypes]
        if {$filename ne ""} {
            set v::currentfile $filename
            menu_save
        }
    }

    proc menu_close {} {
        unregister_traces
        wm withdraw $v::toplevel
    }

    proc menu_initialize_from_mission_dir {} {
        set dir [tk_chooseDirectory \
            -parent $v::toplevel \
            -title "Select the mission directory" \
            -mustexist 1]
        if {$dir ne ""} {
            mission_initialize_from_path $dir
            update_gui
        }
    }

    proc update_gui {args} {
        set f $v::dateframe
        foreach w [winfo children $f] {
            destroy $w
        }
        curry @ namespace code
        foreach date [missiondate_list] {
            label $f.lbl$date -text $date
            button $f.btnConfig$date -text Configure \
                -padx 2m -pady 1m \
                -command [@ [list date_config $date]]
            button $f.btnLoad$date -text Load \
                -padx 2m -pady 1m \
                -command [@ [list date_load $date]]
            button $f.btnDelete$date -text X \
                -padx 2m -pady 1m \
                -command [@ [list date_delete $date]]
            grid $f.lbl$date $f.btnConfig$date $f.btnLoad$date $f.btnDelete$date
        }
        uncurry @
    }

    proc date_config {date} {
        set dlg [iwidgets::dialog $v::toplevel.#auto \
            -title "Mission day: $date" \
            -modality application]
        $dlg hide Help
        $dlg hide Apply

        curry % list $dlg
        curry @ namespace code
        curry & namespace which -variable

        $dlg buttonconfigure OK -command [@ [list $dlg deactivate 1]]
        $dlg buttonconfigure Cancel -command [@ [list $dlg deactivate 0]]

        set v::config_temp([% data_path]) [mission_get data_path $date]
        set v::config_temp([% "edb file"]) [mission_get "edb file" $date]
        set v::config_temp([% "pnav file"]) [mission_get "pnav file" $date]
        set v::config_temp([% "dmars file"]) [mission_get "dmars file" $date]
        set v::config_temp([% "ops_conf file"]) [mission_get "ops_conf file" $date]

        set w [$dlg childsite]

        GUI::FileEntryButton $w.entPath \
            -labeltext "Data path:" \
            -actiontype dir \
            -parent $dlg \
            -textvariable [& v::config_temp]([% data_path])
        GUI::FileEntryButton $w.entEdb \
            -labeltext "EDB file:" \
            -actiontype open \
            -filetypes {
                {{EAARL Database Index files} {.idx}}
                {{All files} *}
            } \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "edb file"])
        GUI::FileEntryButton $w.entPnav \
            -labeltext "PNAV file:" \
            -actiontype open \
            -filetypes {
                {{PNAV files} {.ybin}}
                {{All files} *}
            } \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "pnav file"])
        GUI::FileEntryButton $w.entDmars \
            -labeltext "DMARS file:" \
            -actiontype open \
            -filetypes {
                {{pbd files} {.pbd}}
                {{All files} *}
            } \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "dmars file"])
        GUI::FileEntryButton $w.entOps \
            -labeltext "ops_conf.i file:" \
            -actiontype open \
            -filetypes {
                {{Yorick files} {.i}}
                {{All files} *}
            } \
            -parent $dlg \
            -textvariable [& v::config_temp]([% "ops_conf file"])

        foreach ent [list Path Edb Pnav Dmars Ops] {
            [$w.ent$ent component entry] configure \
                -width 60
        }

        iwidgets::Labeledwidget::alignlabels \
            $w.entPath $w.entEdb $w.entPnav $w.entDmars $w.entOps

        pack \
            $w.entPath $w.entEdb $w.entPnav $w.entDmars $w.entOps \
            -side top -pady 5 -padx 10 -fill x -expand yes

        set prompt_user 1
        while {$prompt_user} {
            set missing_needed 0
            set prompt_user 0
            if {[$dlg activate]} {
                set temp_data [dict create]
                set keys [list data_path "edb file" "pnav file" "dmars file" \
                    "ops_conf file"]
                foreach key $keys {
                    if {[string length $v::config_temp([% $key])]} {
                        dict set temp_data $key $v::config_temp([% $key])
                    }
                }
                if {[llength [dict keys $temp_data]]} {
                    if {
                        [dict exists $temp_data data_path] &&
                        [dict exists $temp_data "edb file"]
                    } {
                        missiondate_set $temp_data $date
                    } else {
                        set missing_needed 1
                    }
                } else {
                    set missing_needed 1
                }
            }
            if {$missing_needed} {
                set response [tk_messageBox \
                    -icon warning -parent $dlg -type yesno \
                    -message "A mission day must have a data path and EAARL\
                        edb file at a minimum. Do you want to return to the\
                        form to enter this information? (Answering 'No'\
                        will abort changes to the entry entirely.)"]
                switch -- $response {
                    yes {set prompt_user 1}
                    no  {set prompt_user 0}
                }
            }
        }

        uncurry %
        uncurry @
        uncurry &

        destroy $dlg
    }

    proc date_delete {date} {
        missiondate_delete $date
        update_gui
    }

    proc date_load {date} {
        missiondate_current $date
        missiondata_load all
    }

    proc date_add {} {
        set dlg [iwidgets::promptdialog $v::toplevel.#auto \
            -modality application \
            -title "Add new mission day" \
            -labeltext "Please enter the mission date as YYYY-MM-DD:"]
        $dlg hide Help
        $dlg hide Apply
        focus [$dlg component prompt component entry]
        $dlg center
        if {[$dlg activate]} {
            set date [$dlg get]
            if {[missiondate_exists $date]} {
                tk_messageBox \
                    -icon warning -parent $dlg -type ok \
                    -message "That mission date already exists. If you want to\
                        modify, please use the mission date's configure\
                        button."
            } else {
                after idle [list after 0 [namespace code [list date_config $date]]]
            }
        }
        destroy $dlg
    }
}

