# vim: set tabstop=4 softtabstop=4 shiftwidth=4 autoindent shiftround expandtab:

# $Id$

package require dict
package require json
package require struct::set
package require fileutil

source [file join $src_path gui_procs.ytk]
source [file join $src_path misc.ytk]

### INITIALIZATION

if {![info exists __mission_conf]} {
    set __mission_conf [dict create]
}
if {![info exists __mission_date]} {
    set __mission_date ""
}

if {![info exists __mission_path]} {
    set __mission_path ""
}

# __mission_cache -- not needed

if {![info exists __mission_settings]} {
    set __mission_settings [dict create \
        "relative paths" [list "data_path" "edb file" "pnav file" \
            "dmars file" "ops_conf file"] \
    ]
}

ycmd require [list [ystr mission_conf.i]]
ycmd h_set [list __mission_settings [ystr ytk] 1]

### COMMON WITH YORICK

# The procedures in this file are largely identical to those in mission_conf.i.
# Please refer to mission_conf.i for documentation on any procedure without
# documentation here.

proc mission_clear {{sync 1}} {
    global __mission_conf
    set __mission_conf [dict create]
    if {$sync} {
        ycmd mission_clear [list] [list sync 0]
    }
}

proc mission_get {key {date -}} {
    global __mission_conf __mission_date __mission_settings __mission_path
    default date $__mission_date
    if {[mission_has $key $date]} {
        set result [dict get $__mission_conf $date $key]
        set rel_paths [dict get $__mission_settings "relative paths"]
        if {[::struct::set contains $rel_paths $key]} {
            set result [file join $__mission_path $result]
        }
        return $result
    } else {
        return
    }
}

proc mission_set {key value {date -} {sync 1}} {
    global __mission_conf __mission_date __mission_settings __mission_path
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    if {$sync} {
        ycmd mission_set \
            [list [ystr $key] [ystr $value]] \
            [list date [ystr $date] sync 0]
    }
    set rel_paths [dict get $__mission_settings "relative paths"]
    if {[::struct::set contains $rel_paths $key]} {
        set value [::fileutil::relative $__mission_path $value]
    }
    dict set __mission_conf $date $key $value
}

proc mission_has {key {date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    return [dict exists $__mission_conf $date $key]
}

proc missiondate_current {{date NODATEPROVIDED} {sync 1}} {
    global __mission_date
    if {$date ne "NODATEPROVIDED"} {
        set __mission_date $date
        if {$sync} {
            ycmd missiondate_current [list [ystr $date]] [list sync 0]
        }
    }
    return $__mission_date
}

proc missiondate_list {} {
    global __mission_conf
    set dates [list]
    return [lsort [dict keys $__mission_conf]]
}

proc mission_delete {key {date -} {sync 1}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    dict unset __mission_conf $date $key
    if {$sync} {
        ycmd mission_delete [list [ystr $key]] [list date [ystr $date] sync 0]
    }
}

proc missiondate_add {date {sync 1}} {
    global __mission_conf
    dict set __mission_conf $date [dict create]
    if {$sync} {
        ycmd missiondate_add [list [ystr $date]] [list sync 0]
    }
}

proc missiondate_delete {date {sync 1}} {
    global __mission_conf
    dict unset __mission_conf $date
    if {$sync} {
        ycmd missiondate_delete [list [ystr $date]] [list sync 0]
    }
}

proc missiondate_exists {{date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    return [dict exists $__mission_conf $date]
}

proc missiondate_set {hash {date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    dict set __mission_conf $date $hash
    if {$sync} {
        mission_send;
    }
}

proc missiondate_get {{date -}} {
    global __mission_conf __mission_date
    default date $__mission_date
    if {![string length $date]} {
        error "Please provide a date or set __mission_date."
    }
    if {[missiondate_exists $date]} {
        return [dict get $__mission_conf $date]
    } else {
        return
    }
}

proc mission_json_export {} {
    global __mission_conf
    set json_list [list]
    dict for {date date_data} $__mission_conf {
        set date_list [list]
        dict for {key value} $date_data {
            set json_key [json_stringify $key]
            set json_val [json_stringify $value]
            lappend date_list "    \"$json_key\": \"$json_val\""
        }
        set json_date [json_stringify $date]
        set date_out ""
        append date_out "  \"$json_date\": {\n"
        append date_out [join $date_list ",\n"]
        append date_out "\n  }"
        lappend json_list $date_out
    }
    set json_out ""
    append json_out "{\n"
    append json_out [join $json_list ",\n"]
    append json_out "\n}\n"
    return $json_out
}

proc mission_json_import {json {sync 1}} {
    global __mission_conf
    set __mission_conf [::json::json2dict $json]
    if {$sync} {
        mission_send
    }
}

proc mission_save {filename} {
    set json_out [mission_json_export]
    set f [open $filename "w"]
    puts -nonewline $f $json_out
    close $f
}

proc mission_load {filename} {
    set f [open $filename "r"]
    set json_in [read $f]
    close $f
    mission_json_import $json_in
}

proc mission_send {} {
    global __mission_date
    ycmd mission_json_import [list [ystr [mission_json_export]]] [list sync 0]
    yset __mission_date = [ystr $__mission_date]
}

proc mission_receive {} {
    ycmd mission_send
}

proc missiondata_cache {action} {
    ycmd missiondata_cache [list [ystr $action]]
}

# missiondata_wrap
# missiondata_unwrap

proc missiondata_load {type {date -}} {
    global __mission_date
    default date $__mission_date

    ycmd missiondata_load [list [ystr $type]] [list date [ystr $date]]
}

proc missiondata_read {filename} {
    ycmd missiondata_read [list [ystr $filename]]
}

proc missiondata_write {filename type {overwrite 1}} {
    ycmd missiondata_write [list [ystr $filename] [ystr $type]] \
        [list overwrite $overwrite]
}

proc mission_path {{path NOPATHPROVIDED} {sync 1}} {
    global __mission_path
    if {$path ne "NOPATHPROVIDED"} {
        set __mission_path $path
        if {$sync} {
            ycmd mission_path [list [ystr $path]] [list sync 0]
        }
    }
    return $__mission_path
}

proc mission_initialize_from_path {mission_path} {
    ycmd mission_initialize_from_path [list [ystr $mission_path]]
}

### UTILITY

# json_stringify raw_val
# Sanitizes a string using JSON conventions.
proc json_stringify {raw_val} {
    return [string map [list \
        \\  \\\\    \
        \"  \\\"    \
        /   \\/     \
        \n  \\n     \
        \b  \\b     \
        \f  \\f     \
        \r  \\r     \
        \t  \\t     \
    ] $raw_val]
}

### GUI CODE

namespace eval mission {
    namespace eval v {
        variable toplevel .mission_conf
        variable dateframe ""
        variable modify_commands [list mission_set missiondate_current \
            mission_delete missiondate_add missiondate_delete \
            mission_json_import mission_path mission_clear]
        variable filetypes [list \
            [list JSON .json] \
            [list "All files" *] \
        ]
        variable currentfile ""
    }

    proc launch_gui {} {
        if {[winfo exists $v::toplevel]} {
            wm deiconify $v::toplevel
            register_traces
        } else {
            create_gui
        }
    }
    
    proc create_gui {} {
        set win $v::toplevel
        destroy $win

        toplevel $win
        wm resizable $win 0 0
        wm title $win "Mission Configuration"

        set mb $win.mb
        menu $mb
        $win configure -menu $mb

        curry @ namespace code

        menu $mb.file
        $mb add cascade -label File -underline 0 -menu $mb.file

        $mb.file add command -label "New" -command [@ menu_new]
        $mb.file add command -label "Open" -command [@ menu_open]
        $mb.file add command -label "Save" -command [@ menu_save]
        $mb.file add command -label "Save As" -command [@ menu_save_as]
        $mb.file add separator
        $mb.file add command -label "Close" -command [@ menu_close]

        menu $mb.act
        $mb add cascade -label Actions -underline 0 -menu $mb.act

        $mb.act add command -label "Initialize from mission directory" \
            -command [@ menu_initialize_from_mission_dir]

        set f $win.fraDates
        set v::dateframe $f
        frame $f

        pack $f -expand 1 -fill x

        button $win.btnAdd -text "Add new mission day..." \
            -padx 2m -pady 1m \
            -state disabled \
            -command [@ date_add]
        pack $win.btnAdd -anchor w

        wm protocol $win WM_DELETE_WINDOW [@ menu_close]

        uncurry @

        register_traces

        update_gui
    }

    proc register_traces {} {
        foreach cmd $v::modify_commands {
            trace add execution $cmd leave [namespace code update_gui]
        }
    }

    proc unregister_traces {} {
        foreach cmd $v::modify_commands {
            trace remove execution $cmd leave [namespace code update_gui]
        }
    }

    proc menu_new {} {
        mission_clear
    }

    proc menu_open {} {
        set filename [tk_getOpenFile \
            -parent $v::toplevel \
            -title "Select the mission configuration file to load" \
            -filetypes $v::filetypes]
        if {$filename ne ""} {
            mission_load $filename
        }
        set v::currentfile $filename
    }

    proc menu_save {} {
        if {$v::currentfile ne ""} {
            mission_save $v::currentfile
        } else {
            menu_save_as
        }
    }

    proc menu_save_as {} {
        set filename [tk_getSaveFile \
            -initialdir [mission_path] \
            -parent $v::toplevel \
            -title "Enter the filename for the mission configuration file" \
            -filetypes $v::filetypes]
        if {$filename ne ""} {
            set v::currentfile $filename
            menu_save
        }
    }

    proc menu_close {} {
        unregister_traces
        wm withdraw $v::toplevel
    }

    proc menu_initialize_from_mission_dir {} {
        set dir [tk_chooseDirectory \
            -parent $v::toplevel \
            -title "Select the mission directory" \
            -mustexist 1]
        if {$dir ne ""} {
            mission_initialize_from_path $dir
            update_gui
        }
    }

    proc update_gui {args} {
        set f $v::dateframe
        foreach w [winfo children $f] {
            destroy $w
        }
        curry @ namespace code
        foreach date [missiondate_list] {
            label $f.lbl$date -text $date
            button $f.btnConfig$date -text config \
                -padx 1m -pady 0m \
                -state disabled \
                -command [@ [list date_config $date]]
            button $f.btnDelete$date -text delete \
                -padx 1m -pady 0m \
                -command [@ [list date_delete $date]]
            button $f.btnLoad$date -text load \
                -padx 1m -pady 0m \
                -command [@ [list date_load $date]]
            grid $f.lbl$date $f.btnConfig$date $f.btnDelete$date $f.btnLoad$date
        }
        uncurry @
    }

    proc date_config {date} {

    }

    proc date_delete {date} {
        missiondate_delete $date
        update_gui
    }

    proc date_load {date} {
        missiondate_current $date
        missiondata_load all
    }

    proc date_add {} {

    }
}

