# vim: set tabstop=3 softtabstop=3 shiftwidth=3 autoindent shiftround expandtab:

package require Iwidgets
package require Itcl
package require misc

source [file join $src_path data_stats.ytk]

option add *SegmentedDataWindow.title "Data Segments" widgetDefault

if {[info commands SegmentedDataWindow] eq ""} {
   itcl::class SegmentedDataWindow {
      inherit iwidgets::Shell

      constructor {args} {}
      destructor {}

      # All options should be treated as read-only after creation
      # Variable containing the list of variables
      itk_option define -varlistvariable varlistVariable Variable ""
      # Variable containing list of valid windows
      itk_option define -maxwin maxWin MaxWin 64
      # Variable containing list of variables to populate interface with
      itk_option define -segmentvariables segmentVariables VariableList ""
      itk_option define -windowvariable windowVariable Variable ""
      itk_option define -fmavariable fmaVariable Variable ""

      method init_opt_var {opt default} {}
      method size_optimally {} {}
      method refresh_times {} {}
      method configure_times {} {}
      method set_time {idx time_start time_end} {}
      method clear_time {idx} {}
      method plot_segment {args} {}
      method plot_selected {} {}
      method merge_selected {} {}
      method launch_stats {args} {}
      method define_region {} {}
      method define_region_not_possible {} {}
      method define_region_is_possible {} {}
      method define_region_successful {} {}
      method define_region_mismatch {} {}
      method define_region_multilines {} {}
      method new_segment_window {} {}

      # Holds per-segment data
      variable _segment
      # The window to plot selected items in jointly
      variable _ywindow 0
      # The variable to merge data into
      variable _merge_var merged_segments
      # How many items does the interface hold?
      variable _count
      # Do we frame advance prior to plots?
      variable _fma
      # For holding private GUI variables (array)
      variable _private
      # The format to use for time
      variable _timeformat full
   }
}

itcl::body SegmentedDataWindow::init_opt_var {opt default} {
   if {![string length $itk_option($opt)]} {
      set itk_option($opt) [itcl::scope _private($opt)]
      set $itk_option($opt) $default
   }
}

itcl::body SegmentedDataWindow::constructor {args} {
   wm protocol $itk_component(hull) WM_DELETE_WINDOW \
      [itcl::code itcl::delete object $this]
   eval itk_initialize $args

   wm resizable $itk_component(hull) 1 1
   wm minsize $itk_component(hull) 460 100

   init_opt_var -varlistvariable \
      [list fs_all depth_all veg_all cveg_all workdata]
   init_opt_var -windowvariable 0
   init_opt_var -fmavariable 0

   set w $itk_interior

   set f1 $w.fraVariables
   iwidgets::scrolledframe $f1 \
      -vscrollmode dynamic \
      -hscrollmode dynamic \
      -relief groove

   set f [$f1 childsite]
   $f configure -padx 4

   label $f.lblHeadingVariables -text "Variable"
   button $f.btnHeadingTime -text "Times (refresh)" \
      -command [itcl::code $this refresh_times]
   label $f.lblHeadingPlot -text "Plot Segment"

   grid configure x $f.lblHeadingVariables \
      $f.lblHeadingPlot - $f.btnHeadingTime \
      -sticky ew

   set _count [llength $itk_option(-segmentvariables)]
   set idx 0
   foreach segment $itk_option(-segmentvariables) {
      incr idx

      if {[lsearch [set $itk_option(-varlistvariable)] $segment] < 0} {
         lappend $itk_option(-varlistvariable) $segment
      }
      set _segment($idx,var) $segment
      set _segment($idx,use) 1
      set _segment($idx,time) "..."
      set _segment($idx,win) 0

      checkbutton $f.chk$idx \
         -variable [itcl::scope _segment($idx,use)]

      ::misc::combobox $f.cbo$idx \
         -textvariable [itcl::scope _segment($idx,var)] \
         -state readonly \
         -modifycmd [itcl::code $this clear_time $idx] \
         -listvariable $itk_option(-varlistvariable)

      button $f.btnPlot$idx -text "Plot in:" \
         -command [itcl::code $this plot_segment $idx]

      spinbox $f.spnWin$idx \
         -textvariable [itcl::scope _segment($idx,win)] \
         -from 0 -to $itk_option(-maxwin) -width 2

      label $f.lbl$idx \
         -textvariable [itcl::scope _segment($idx,time)]

      grid $f.chk$idx $f.cbo$idx \
         $f.btnPlot$idx $f.spnWin$idx $f.lbl$idx \
         -sticky ew
   }
   unset idx
   grid columnconfigure $f 1 -weight 1 -minsize 80

   labelframe $w.fraWithSelected -text "With selected variables..."

   set f $w.fraWithSelected.fraBottom1
   frame $f
   button $f.btnMerge -text "Merge to:" \
      -command [itcl::code $this merge_selected]
   entry $f.entMergeVar \
      -textvariable [itcl::scope _merge_var]

   button $f.btnPlot -text "Plot in:" \
      -command [itcl::code $this plot_selected]

   spinbox $f.spnWin \
      -textvariable $itk_option(-windowvariable) \
      -from 0 -to $itk_option(-maxwin) -width 2

   button $f.btnStats -text "Statistics" \
      -command [itcl::code $this launch_stats]

   grid $f.btnPlot $f.spnWin x $f.btnStats x $f.btnMerge $f.entMergeVar \
      -sticky we
   grid columnconfigure $f 6 -weight 2 -minsize 80
   grid columnconfigure $f [list 2 4] -weight 1

   set f $w.fraWithSelected.fraBottom2
   frame $f
   button $f.btnDefine -text "Define Region to Process" \
      -command [itcl::code $this define_region]
   button $f.btnNew -text "New Segment Window" \
      -command [itcl::code $this new_segment_window]

   grid $f.btnDefine x $f.btnNew -sticky we
   grid columnconfigure $f 1 -weight 1

   grid $w.fraWithSelected.fraBottom1 -sticky we
   grid $w.fraWithSelected.fraBottom2 -sticky we
   grid columnconfigure $w.fraWithSelected 0 -weight 1

   set f $w.fraOptions
   labelframe $f -text "Options"

   checkbutton $f.chkFma \
      -text "Auto Fma" \
      -variable $itk_option(-fmavariable)

   button $f.btnTimeConfig -text "Time Format" \
      -command [itcl::code $this configure_times]

   grid $f.chkFma -sticky w
   grid $f.btnTimeConfig -sticky we
   grid columnconfigure $f 0 -weight 1

   grid $w.fraVariables - -sticky wens
   grid $w.fraWithSelected $w.fraOptions -sticky wens
   grid columnconfigure $w 0 -weight 1

   grid rowconfigure $w 0 -weight 1

   refresh_times
   size_optimally
   after idle [list after 250 [itcl::code $this size_optimally]]
   after idle [list after 1000 [itcl::code $this size_optimally]]
}

itcl::body SegmentedDataWindow::size_optimally {} {
   set hull $itk_component(hull)
   set f $itk_interior.fraVariables

   $f configure \
      -vscrollmode none \
      -hscrollmode none
   
   set offset [join [lrange [split [wm geometry $hull] +] 1 2] +]
   wm geometry $hull ""

   set hw [winfo width $hull]
   set fsw [winfo width $f]
   set frw [winfo reqwidth [$f childsite]]
   set padw [expr {[[$f childsite] cget -padx] * 2}]
   set nw [expr {$hw + ($frw - $fsw) + $padw + 4}]

   set hh [winfo height $hull]
   set fsh [winfo height $f]
   set frh [winfo reqheight [$f childsite]]
   set padh [expr {[[$f childsite] cget -pady] * 2}]
   set nh [expr {$hh + ($frh - $fsh) + $padh + 4}]

   set too_w 0
   set sw [expr {[winfo screenwidth $hull] - 100}]
   if {$nw > $sw} {
      set nw $sw
      set too_w 1
   }

   set too_h 0
   set sh [expr {[winfo screenheight $hull] - 100}]
   if {$nh > $sh} {
      set nh $sh
      set too_h 1
   }

   if {$too_w && ! $too_h} {
      incr nh [expr {8 + [$f cget -sbwidth]}]
   }

   if {$too_h && ! $too_w} {
      incr nw [expr {8 + [$f cget -sbwidth]}]
   }

   $f configure \
      -vscrollmode dynamic \
      -hscrollmode dynamic

   wm geometry $hull "${nw}x${nh}+$offset"

   $f configure \
      -vscrollmode none \
      -hscrollmode none
   update idletasks
   set xv [$f xview]
   set yv [$f yview]
   $f configure \
      -vscrollmode dynamic \
      -hscrollmode dynamic
   update idletasks
   eval [[$f component canvas] cget -xscrollcommand] $xv
   eval [[$f component canvas] cget -yscrollcommand] $yv
   eval [[$f component canvas] cget -xscrollcommand] [$f xview]
   eval [[$f component canvas] cget -yscrollcommand] [$f yview]
}

itcl::body SegmentedDataWindow::refresh_times {} {
   for {set i 1} {$i <= $_count} {incr i} {
      exp_send "tk_sdw_send_times, \"[itcl::scope $this]\", $i,\
         $_segment($i,var);\r"
      expect ">"
   }
}

itcl::body SegmentedDataWindow::configure_times {} {
   set dlg [iwidgets::dialog .#auto \
      -title "Configure Time Format" \
      -modality application]

   $dlg hide Help
   $dlg hide Apply

   set w [$dlg childsite]

   set f $w.fraChoices
   labelframe $f -text "Select a format:"

   pack $f -fill both -expand yes

   set options [list \
      full "2004-01-10 12:00:00 - 2004-01-15 14:00:00" \
      short "01-10 12:00 - 01-15 14:00" \
      date "2004-01-10 - 2004-01-15" \
      time "12:00:00 - 14:00:00" \
      startfull "2004-01-10 12:00:00" \
      startfulllen "2004-01-10 12:00:00 (05 min 13 sec)" \
      starttime "12:00:00"]

   foreach {tag desc} $options {
      grid [radiobutton $f.rdb$tag -value $tag \
         -text $desc \
         -variable [itcl::scope _timeformat]] \
         -sticky w
   }

   set backup_format $_timeformat

   if {[$dlg activate]} {
      refresh_times
   } else {
      set _timeformat $backup_format
   }
}

itcl::body SegmentedDataWindow::set_time {idx time_start time_end} {
   set start [clock scan $time_start]
   set end [clock scan $time_end]
   set diff [expr {$end - $start}]
   switch -- $_timeformat {
      full {
         set format "%Y-%m-%d %H:%M:%S"
         set s [clock format $start -format $format]
         set e [clock format $end -format $format]
         set _segment($idx,time) "$s - $e"
      }
      short {
         set format "%m-%d %H:%M"
         set s [clock format $start -format $format]
         set e [clock format $end -format $format]
         set _segment($idx,time) "$s - $e"
      }
      date {
         set format "%Y-%m-%d"
         set s [clock format $start -format $format]
         set e [clock format $end -format $format]
         set _segment($idx,time) "$s - $e"
      }
      time {
         set format "%H:%M:%S"
         set s [clock format $start -format $format]
         set e [clock format $end -format $format]
         set _segment($idx,time) "$s - $e"
      }
      startfull {
         set format "%Y-%m-%d %H:%M:%S"
         set s [clock format $start -format $format]
         set _segment($idx,time) "$s"
      }
      startfulllen {
         set format "%Y-%m-%d %H:%M:%S"
         set s [clock format $start -format $format]
         set d [clock format $diff -format "(%M min %S sec)"]
         set _segment($idx,time) "$s $d"
      }
      starttime {
         set format "%H:%M:%S"
         set s [clock format $start -format $format]
         set _segment($idx,time) "$s"
      }
   }
}

itcl::body SegmentedDataWindow::clear_time {idx} {
   set _segment($idx,time) "..."
}

itcl::body SegmentedDataWindow::plot_segment {idx} {
   global pro_var win_no l1pro_fma

   set fma_bkp $l1pro_fma
   set win_bkp $win_no
   set var_bkp $pro_var

   set l1pro_fma [set $itk_option(-fmavariable)]
   set win_no $_segment($idx,win)
   set pro_var $_segment($idx,var)
   plot_fltlines 0

   set l1pro_fma $fma_bkp
   set win_no $win_bkp
   set pro_var $var_bkp
}

itcl::body SegmentedDataWindow::plot_selected {} {
   global pro_var l1pro_fma

   set fma_bkp $l1pro_fma
   set var_bkp $pro_var

   set l1pro_fma [set $itk_option(-fmavariable)]
   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         set pro_var $_segment($idx,var)
         plot_fltlines 0
         set l1pro_fma 0
      }
   }

   set l1pro_fma $fma_bkp
   set pro_var $var_bkp
}

itcl::body SegmentedDataWindow::merge_selected {} {
   global pro_var

   exp_send "$_merge_var = \[\];\r"
   expect ">"

   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         exp_send "grow, $_merge_var, $_segment($idx,var) ;\r"
         expect ">"
      }
   }

   append_varlist $_merge_var
   tk_messageBox -icon info -type ok -parent $itk_component(hull) \
      -message "The selected variables have been merged to $_merge_var."
}

itcl::body SegmentedDataWindow::launch_stats {args} {
   set seg_vars [list]
   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         lappend seg_vars $_segment($idx,var)
      }
   }

   if {[llength $seg_vars]} {
      launch_datastatswindow $seg_vars
   } else {
      tk_messageBox -icon warning \
         -message "No variables were selected." \
         -type ok
   }
}

itcl::body SegmentedDataWindow::define_region {} {
   exp_send "tk_swd_define_region_possible, \"[itcl::scope $this]\";\r"
}

itcl::body SegmentedDataWindow::define_region_not_possible {} {
   tk_messageBox -icon error -type ok -parent .l1wid \
      -message "It is not possible to define a region. You must ensure\
         that you have loaded pnav and edb data first."
}

itcl::body SegmentedDataWindow::define_region_is_possible {} {
   set region_list [list]
   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         lappend region_list $_segment($idx,var)
      }
   }
   if {[llength $region_list]} {
      set region_list [join $region_list ", "]
      exp_send "tk_sdw_define_region_variables,\
         \"[itcl::scope $this]\", $region_list;\r"
   } else {
      tk_messageBox -icon error -type ok -parent .l1wid \
         -message "You must select at least one variable in order to define\
            a region."
   }
}

itcl::body SegmentedDataWindow::define_region_successful {} {
   tk_messageBox -icon info -type ok -parent .l1wid \
      -message "The region has been defined."
}

itcl::body SegmentedDataWindow::define_region_mismatch {} {
   tk_messageBox -icon error -type ok -parent .l1wid \
      -message "One or more of the selected data variables do not match the\
         loaded data. Please only select data variables whose time frame falls\
         within the loaded edb and pnav data."
}

itcl::body SegmentedDataWindow::define_region_multilines {} {
   # Prompt for action
   set response [tk_messageBox -icon question -type yesno -parent .l1wid \
      -message "One or more of the selected data variables appears to contain\
         merged data from multiple flightlines. Do you still want to define\
         the region?"]
   if {$response eq "yes"} {
      exp_send "q = _tk_swd_region;\r"
      expect ">"
      tk_messageBox -icon info -type ok -parent .l1wid \
         -message "The region has been defined."
   }
}

itcl::body SegmentedDataWindow::new_segment_window {} {
   set seg_vars [list]
   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         lappend seg_vars $_segment($idx,var)
      }
   }

   if {[llength $seg_vars]} {
      select_data_segments $seg_vars
   } else {
      tk_messageBox -icon warning \
         -message "No variables were selected." \
         -type ok
   }
}

proc segment_by_flightlines {yvar} {
   set var_prefix "::tempvar_[expr {round(rand()*1000)}]_[clock seconds]_"
   set i 1
   while {[info exists $var_prefix$i]} {
      incr i
   }
   set var $var_prefix$i
   set $var -1

   exp_send "require, \"data_segments.i\";\r"
   expect ">"
   exp_send "fptr = split_by_fltline($yvar);\r"
   expect ">"
   exp_send "tkcmd, swrite(format=\"set $var %d\", numberof(fptr));\r"
   expect ">"

   ::misc::idle [list _segment_by_flightlines_post $yvar $var]
}

proc _segment_by_flightlines_post {yvar count_var} {
   if {[set $count_var] < 0} {
      ::misc::idle [list _segment_by_flightlines_post $yvar $count_var]
   } else {
      set segment_count [set $count_var]
      unset $count_var

      set seg_vars [list]
      for {set i 1} {$i <= $segment_count} {incr i} {
         set seg_var ${yvar}_flt$i
         exp_send "$seg_var = *fptr($i)\r"
         expect ">"
         lappend seg_vars $seg_var
      }
      exp_send "fptr = \[\];\r"

      launch_segmenteddatawindow $seg_vars \
         -title "Flightline Segments for $yvar"
   }
}

proc launch_segmenteddatawindow {segments args} {
   set sdw [eval \
      [list SegmentedDataWindow .#auto \
         -varlistvariable ::varlist \
         -maxwin 64 \
         -segmentvariables $segments \
         -windowvariable ::win_no \
         -fmavariable ::l1pro_fma] \
      $args]
   $sdw activate
}

proc select_data_segments {{selected {}}} {
   global varlist

   set d [iwidgets::dialog .#auto -title "Select variables" \
      -master .l1wid \
      -modality application]
   $d hide Apply
   $d hide Help

   set w [$d childsite]

   iwidgets::disjointlistbox $w.djlVariables \
      -lhslabeltext "Available variables" \
      -rhslabeltext "Selected variables" \
      -lhsbuttonlabel "Add >>" \
      -rhsbuttonlabel "<< Remove"

   pack $w.djlVariables -fill both -expand true
   $w.djlVariables setlhs $varlist

   if {[llength $selected]} {
      $w.djlVariables setrhs $selected
   }

   if {[$d activate]} {
      set selected [$w.djlVariables getrhs]
      if {[llength $selected]} {
         launch_segmenteddatawindow $selected
      }
   }

   destroy $d
}
