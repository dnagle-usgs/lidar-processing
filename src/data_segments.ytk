# vim: set ts=3 sts=3 sw=3 ai sr et:

package require Iwidgets
package require Itcl
package require misc

source [file join $src_path data_stats.ytk]

option add *SegmentedDataWindow.title "Data Segments" widgetDefault

if {[info commands SegmentedDataWindow] eq ""} {
   itcl::class SegmentedDataWindow {
      inherit iwidgets::Shell

      constructor {args} {}
      destructor {}

      # All options should be treated as read-only after creation
      # Variable containing the list of variables
      itk_option define -varlistvariable varlistVariable Variable ""
      # Variable containing list of valid windows
      itk_option define -maxwin maxWin MaxWin 64
      # Variable containing list of variables to populate interface with
      itk_option define -segmentvariables segmentVariables VariableList ""
      itk_option define -windowvariable windowVariable Variable ""
      itk_option define -fmavariable fmaVariable Variable ""

      method init_opt_var {opt default} {}
      method size_optimally {} {}
      method refresh_times {} {}
      method set_time {idx time_start time_end} {}
      method clear_time {idx} {}
      method plot_segment {args} {}
      method plot_selected {} {}
      method merge_selected {} {}
      method launch_stats {args} {}
      method define_region {} {}
      method define_region_not_possible {} {}
      method define_region_is_possible {} {}
      method define_region_successful {} {}
      method define_region_mismatch {} {}
      method define_region_multilines {} {}
      method new_segment_window {} {}
      method close_clear {} {}
      method selected {cmd} {}

      # Holds per-segment data
      variable _segment
      # The window to plot selected items in jointly
      variable _ywindow 0
      # The variable to merge data into
      variable _merge_var merged_segments
      # How many items does the interface hold?
      variable _count
      # Do we frame advance prior to plots?
      variable _fma
      # For holding private GUI variables (array)
      variable _private
      # The format to use for time
      variable _dateformat "%Y-%m-%d"
      variable _timeformat "%H:%M:%S"
      variable _rangeformat "START - END"
   }
}

itcl::body SegmentedDataWindow::init_opt_var {opt default} {
   if {![string length $itk_option($opt)]} {
      set itk_option($opt) [itcl::scope _private($opt)]
      set $itk_option($opt) $default
   }
}

itcl::body SegmentedDataWindow::constructor {args} {
   wm protocol $itk_component(hull) WM_DELETE_WINDOW \
      [itcl::code itcl::delete object $this]
   itk_initialize {*}$args

   wm resizable $itk_component(hull) 1 1
   wm minsize $itk_component(hull) 460 100

   init_opt_var -varlistvariable \
      [list fs_all depth_all veg_all cveg_all workdata]
   init_opt_var -windowvariable 0
   init_opt_var -fmavariable 0

   set w $itk_interior

   set f1 $w.fraVariables
   iwidgets::scrolledframe $f1 \
      -vscrollmode dynamic \
      -hscrollmode dynamic \
      -relief groove

   set f [$f1 childsite]
   $f configure -padx 4

   set mb $f.btnHeadingSelect.mb
   # \u2713 is Unicode for a checkmark
   # \u2714 is a heavier version
   menubutton $f.btnHeadingSelect -menu $mb -text \u2713 -relief raised
   menu $mb
   $mb add command -label "Select all" \
      -command [itcl::code $this selected all]
   $mb add command -label "Select none" \
      -command [itcl::code $this selected none]
   $mb add command -label "Toggle selection" \
      -command [itcl::code $this selected toggle]
   label $f.lblHeadingVariables -text "Variable"
   set mb $f.btnHeadingTime.mb
   menubutton $f.btnHeadingTime -text "Time Format/Refresh" -menu $mb \
      -relief raised
   menu $mb
   menu $mb.date
   menu $mb.time
   menu $mb.range
   $mb add cascade -label "Date format" -menu $mb.date
   $mb.date add radiobutton -label "YYYY-MM-DD" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _dateformat] -value "%Y-%m-%d"
   $mb.date add radiobutton -label "MM-DD" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _dateformat] -value "%m-%d"
   $mb.date add radiobutton -label "YYYY-DOY" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _dateformat] -value "%Y-%j"
   $mb.date add radiobutton -label "DOY" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _dateformat] -value "%j"
   $mb.date add radiobutton -label "(omit)" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _dateformat] -value " "
   $mb add cascade -label "Time format" -menu $mb.time
   $mb.time add radiobutton -label "HH:MM:SS" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _timeformat] -value "%H:%M:%S"
   $mb.time add radiobutton -label "HH:MM" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _timeformat] -value "%H:%M"
   $mb.time add radiobutton -label "SOE" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _timeformat] -value "SOE"
   $mb.time add radiobutton -label "SOD" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _timeformat] -value "SOD"
   $mb.time add radiobutton -label "(omit)" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _timeformat] -value " "
   $mb add cascade -label "Range format" -menu $mb.range
   $mb.range add radiobutton -label "START - END" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _rangeformat] -value "START - END"
   $mb.range add radiobutton -label "START" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _rangeformat] -value "START"
   $mb.range add radiobutton -label "START (DURATION)" \
      -command [itcl::code $this refresh_times] \
      -variable [itcl::scope _rangeformat] -value "START (DURATION)"
   $mb add command -label "Refresh" \
      -command [itcl::code $this refresh_times]
   label $f.lblHeadingPlot -text "Plot Segment"

   grid configure $f.btnHeadingSelect $f.lblHeadingVariables \
      $f.lblHeadingPlot - $f.btnHeadingTime

   set _count [llength $itk_option(-segmentvariables)]
   set idx 0
   foreach segment $itk_option(-segmentvariables) {
      incr idx

      if {[lsearch [set $itk_option(-varlistvariable)] $segment] < 0} {
         lappend $itk_option(-varlistvariable) $segment
      }
      set _segment($idx,var) $segment
      set _segment($idx,use) 1
      set _segment($idx,time) "..."
      set _segment($idx,win) 5

      checkbutton $f.chk$idx \
         -variable [itcl::scope _segment($idx,use)]

      ::mixin::combobox $f.cbo$idx \
         -textvariable [itcl::scope _segment($idx,var)] \
         -state readonly \
         -modifycmd [itcl::code $this clear_time $idx] \
         -listvariable $itk_option(-varlistvariable)

      button $f.btnPlot$idx -text "Plot in:" \
         -command [itcl::code $this plot_segment $idx]

      ttk::spinbox $f.spnWin$idx \
         -textvariable [itcl::scope _segment($idx,win)] \
         -from 0 -to $itk_option(-maxwin) -width 2

      label $f.lbl$idx \
         -textvariable [itcl::scope _segment($idx,time)]

      grid $f.chk$idx $f.cbo$idx \
         $f.btnPlot$idx $f.spnWin$idx $f.lbl$idx \
         -sticky ew
   }
   unset idx
   grid columnconfigure $f 1 -weight 1 -minsize 80

   labelframe $w.fraWithSelected -text "With selected variables..."

   set f $w.fraWithSelected.fraBottom1
   frame $f
   button $f.btnMerge -text "Merge to:" \
      -command [itcl::code $this merge_selected]
   entry $f.entMergeVar \
      -textvariable [itcl::scope _merge_var]

   button $f.btnPlot -text "Plot in:" \
      -command [itcl::code $this plot_selected]

   ttk::spinbox $f.spnWin \
      -textvariable $itk_option(-windowvariable) \
      -from 0 -to $itk_option(-maxwin) -width 2

   button $f.btnStats -text "Statistics" \
      -command [itcl::code $this launch_stats]

   grid $f.btnPlot $f.spnWin x $f.btnStats x $f.btnMerge $f.entMergeVar \
      -sticky we
   grid columnconfigure $f 6 -weight 2 -minsize 80
   grid columnconfigure $f [list 2 4] -weight 1

   set f $w.fraWithSelected.fraBottom2
   frame $f
   button $f.btnDefine -text "Define Region to Process" \
      -command [itcl::code $this define_region]
   button $f.btnNew -text "New Segment Window" \
      -command [itcl::code $this new_segment_window]

   grid $f.btnDefine x $f.btnNew -sticky we
   grid columnconfigure $f 1 -weight 1

   grid $w.fraWithSelected.fraBottom1 -sticky we
   grid $w.fraWithSelected.fraBottom2 -sticky we
   grid columnconfigure $w.fraWithSelected 0 -weight 1

   set f $w.fraOptions
   labelframe $f -text "Options"

   checkbutton $f.chkFma \
      -text "Auto Fma" \
      -variable $itk_option(-fmavariable)

   button $w.btnCloseClear -text "Close & Clear" \
      -command [itcl::code $this close_clear]

   grid $f.chkFma -sticky w
   grid columnconfigure $f 0 -weight 1

   grid $w.fraVariables - -sticky wens
   grid $w.fraWithSelected $w.fraOptions -sticky wens
   grid ^ $w.btnCloseClear -sticky sw
   grid columnconfigure $w 0 -weight 1

   grid rowconfigure $w 0 -weight 1

   refresh_times
   size_optimally
   after idle [list after 250 [itcl::code $this size_optimally]]
   after idle [list after 1000 [itcl::code $this size_optimally]]
}

itcl::body SegmentedDataWindow::size_optimally {} {
   set hull $itk_component(hull)
   set f $itk_interior.fraVariables

   $f configure \
      -vscrollmode none \
      -hscrollmode none
   
   set offset [join [lrange [split [wm geometry $hull] +] 1 2] +]
   wm geometry $hull ""

   set hw [winfo width $hull]
   set fsw [winfo width $f]
   set frw [winfo reqwidth [$f childsite]]
   set padw [expr {[[$f childsite] cget -padx] * 2}]
   set nw [expr {$hw + ($frw - $fsw) + $padw + 4}]

   set hh [winfo height $hull]
   set fsh [winfo height $f]
   set frh [winfo reqheight [$f childsite]]
   set padh [expr {[[$f childsite] cget -pady] * 2}]
   set nh [expr {$hh + ($frh - $fsh) + $padh + 4}]

   set too_w 0
   set sw [expr {[winfo screenwidth $hull] - 100}]
   if {$nw > $sw} {
      set nw $sw
      set too_w 1
   }

   set too_h 0
   set sh [expr {[winfo screenheight $hull] - 100}]
   if {$nh > $sh} {
      set nh $sh
      set too_h 1
   }

   if {$too_w && ! $too_h} {
      incr nh [expr {8 + [$f cget -sbwidth]}]
   }

   if {$too_h && ! $too_w} {
      incr nw [expr {8 + [$f cget -sbwidth]}]
   }

   $f configure \
      -vscrollmode dynamic \
      -hscrollmode dynamic

   wm geometry $hull "${nw}x${nh}+$offset"

   $f configure \
      -vscrollmode none \
      -hscrollmode none
   update idletasks
   set xv [$f xview]
   set yv [$f yview]
   $f configure \
      -vscrollmode dynamic \
      -hscrollmode dynamic
   update idletasks
   {*}[[$f component canvas] cget -xscrollcommand] {*}$xv
   {*}[[$f component canvas] cget -yscrollcommand] {*}$yv
   {*}[[$f component canvas] cget -xscrollcommand] {*}[$f xview]
   {*}[[$f component canvas] cget -yscrollcommand] {*}[$f yview]
}

itcl::body SegmentedDataWindow::refresh_times {} {
   for {set i 1} {$i <= $_count} {incr i} {
      after [expr {$i * 20}] [list \
         ybkg tk_sdw_send_times \"[itcl::scope $this]\" $i $_segment($i,var)]
   }
}

itcl::body SegmentedDataWindow::set_time {idx time_start time_end} {
   set start [clock scan $time_start -gmt 1]
   set end [clock scan $time_end -gmt 1]
   set diff [expr {$end - $start}]

   set date0 [clock format $start -format $_dateformat -gmt 1]
   set date1 [clock format $end -format $_dateformat -gmt 1]

   switch -- $_timeformat {
      SOE {
         set time0 $start
         set time1 $end
      }
      SOD {
         set time0 [expr {$start % 86400}]
         set time1 [expr {$end % 86400}]
      }
      default {
         set time0 [clock format $start -format $_timeformat -gmt 1]
         set time1 [clock format $end -format $_timeformat -gmt 1]
      }
   }

   set datetime0 [string trim "$date0 $time0"]
   set datetime1 [string trim "$date1 $time1"]

   switch -- $_rangeformat {
      "START - END" {
         set _segment($idx,time) "$datetime0 - $datetime1"
      }
      "START" {
         set _segment($idx,time) "$datetime0"
      }
      "START (DURATION)" {
         set d [clock format $diff -format "(%M min %S sec)" -gmt 1]
         set _segment($idx,time) "$datetime0 $d"
      }
   }
}

itcl::body SegmentedDataWindow::clear_time {idx} {
   set _segment($idx,time) "..."
}

itcl::body SegmentedDataWindow::plot_segment {idx} {
   ::display_data -var $_segment($idx,var) -win $_segment($idx,win) \
      -fma [set $itk_option(-fmavariable)]
}

itcl::body SegmentedDataWindow::plot_selected {} {
   set fma [set $itk_option(-fmavariable)]
   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         ::display_data -var $_segment($idx,var) \
            -win [set $itk_option(-windowvariable)] \
            -fma $fma
         set fma 0
      }
   }
}

itcl::body SegmentedDataWindow::merge_selected {} {
   global pro_var

   exp_send "$_merge_var = \[\];\r"
   expect ">"

   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         exp_send "grow, $_merge_var, $_segment($idx,var) ;\r"
         expect ">"
      }
   }

   append_varlist $_merge_var
   tk_messageBox -icon info -type ok -parent $itk_component(hull) \
      -message "The selected variables have been merged to $_merge_var."
}

itcl::body SegmentedDataWindow::launch_stats {args} {
   set seg_vars [list]
   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         lappend seg_vars $_segment($idx,var)
      }
   }

   if {[llength $seg_vars]} {
      launch_datastatswindow $seg_vars
   } else {
      tk_messageBox -icon warning \
         -message "No variables were selected." \
         -type ok
   }
}

itcl::body SegmentedDataWindow::define_region {} {
   ybkg tk_swd_define_region_possible \"[itcl::scope $this]\"
}

itcl::body SegmentedDataWindow::define_region_not_possible {} {
   tk_messageBox -icon error -type ok -parent .l1wid \
      -message "It is not possible to define a region. You must ensure\
         that you have loaded pnav and edb data first."
}

itcl::body SegmentedDataWindow::define_region_is_possible {} {
   set region_list [list]
   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         lappend region_list $_segment($idx,var)
      }
   }
   if {[llength $region_list]} {
      set region_list [join $region_list ", "]
      exp_send "tk_sdw_define_region_variables,\
         \"[itcl::scope $this]\", $region_list;\r"
   } else {
      tk_messageBox -icon error -type ok -parent .l1wid \
         -message "You must select at least one variable in order to define\
            a region."
   }
}

itcl::body SegmentedDataWindow::define_region_successful {} {
   tk_messageBox -icon info -type ok -parent .l1wid \
      -message "The region has been defined."
}

itcl::body SegmentedDataWindow::define_region_mismatch {} {
   tk_messageBox -icon error -type ok -parent .l1wid \
      -message "One or more of the selected data variables do not match the\
         loaded data. Please only select data variables whose time frame falls\
         within the loaded edb and pnav data."
}

itcl::body SegmentedDataWindow::define_region_multilines {} {
   # Prompt for action
   set response [tk_messageBox -icon question -type yesno -parent .l1wid \
      -message "One or more of the selected data variables appears to contain\
         merged data from multiple flightlines. Do you still want to define\
         the region?"]
   if {$response eq "yes"} {
      ybkg funcset q _tk_swd_region
      tk_messageBox -icon info -type ok -parent .l1wid \
         -message "The region has been defined."
   }
}

itcl::body SegmentedDataWindow::new_segment_window {} {
   set seg_vars [list]
   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         lappend seg_vars $_segment($idx,var)
      }
   }

   if {[llength $seg_vars]} {
      select_data_segments $seg_vars
   } else {
      tk_messageBox -icon warning \
         -message "No variables were selected." \
         -type ok
   }
}

itcl::body SegmentedDataWindow::close_clear {} {
   set vars $itk_option(-segmentvariables)
   if {[llength $vars] > 1} {
      set this_var "these variables"
   } else {
      set this_var "this variable"
   }

   set response [tk_messageBox -icon question -type yesno \
         -title Warning -message "Do you want to delete ${this_var}?\n$vars"]
   if {$response eq "yes"} {
      set cmd ""
      foreach var $vars {
         append cmd "$var = \[\];"
         delete_varlist $var
      }
      exp_send "$cmd\r"
   }

   itcl::delete object $this
}

itcl::body SegmentedDataWindow::selected {cmd} {
   for {set idx 1} {$idx <= $_count} {incr idx} {
      switch -- $cmd {
         all {
            set _segment($idx,use) 1
         }
         none {
            set _segment($idx,use) 0
         }
         toggle {
            set _segment($idx,use) [expr {1 - $_segment($idx,use)}]
         }
      }
   }
}

proc segment_data_launcher {how {yvar -}} {
   if {$yvar eq "-"} {
      set yvar $::pro_var
   }
   set how \[\"[join $how \",\"]\"\]
   exp_send "tk_sdw_launch_split, \"$yvar\", $how;\r"
   expect "> "
}

proc launch_segmenteddatawindow {segments args} {
   set sdw [SegmentedDataWindow .#auto \
      -varlistvariable ::varlist \
      -maxwin 64 \
      -segmentvariables $segments \
      -windowvariable ::win_no \
      -fmavariable ::l1pro_fma \
      {*}$args]
   $sdw activate
}

proc select_data_segments {{selected {}}} {
   global varlist

   set d [iwidgets::dialog .#auto -title "Select variables" \
      -master .l1wid \
      -modality application]
   $d hide Apply
   $d hide Help

   set w [$d childsite]

   iwidgets::disjointlistbox $w.djlVariables \
      -lhslabeltext "Available variables" \
      -rhslabeltext "Selected variables" \
      -lhsbuttonlabel "Add >>" \
      -rhsbuttonlabel "<< Remove"

   pack $w.djlVariables -fill both -expand true
   $w.djlVariables setlhs $varlist

   if {[llength $selected]} {
      $w.djlVariables setrhs $selected
   }

   if {[$d activate]} {
      set selected [$w.djlVariables getrhs]
      if {[llength $selected]} {
         launch_segmenteddatawindow $selected
      }
   }

   destroy $d
}
