# $Id$
# vim: set tabstop=3 softtabstop=3 shiftwidth=3 autoindent shiftround expandtab:

package require Tk
package require Iwidgets
package require Itcl

option add *SegmentedDataWindow.title "Data Segments" widgetDefault

if {[info commands SegmentedDataWindow] eq ""} {
   itcl::class SegmentedDataWindow {
      inherit iwidgets::Shell

      constructor {args} {}
      destructor {}

      # All options should be treated as read-only after creation
      # Variable containing the list of variables
      itk_option define -varlistvariable varlistVariable Variable ""
      # Variable containing list of valid windows
      itk_option define -maxwin maxWin MaxWin 64
      # Variable containing list of variables to populate interface with
      itk_option define -segmentvariables segmentVariables VariableList ""

      itk_option define -windowvariable windowVariable Variable ""

      method refresh_times {} {}
      method set_time {idx time_start time_end} {}
      method clear_time {idx} {}
      method plot_segment {args} {}
      method plot_selected {} {}
      method merge_selected {} {}
      method launch_stats {args} {}
      method define_region {} {}
      method new_segment_window {} {}

      # Holds per-segment data
      variable _segment
      # The window to plot selected items in jointly
      variable _ywindow 0
      # The variable to merge data into
      variable _merge_var merged_segments
      # How many items does the interface hold?
      variable _count
   }
}

itcl::body SegmentedDataWindow::constructor {args} {
   wm protocol $itk_component(hull) WM_DELETE_WINDOW \
      [itcl::code itcl::delete object $this]
   eval itk_initialize $args

   set w $itk_interior

   set f $w.fraVariables

   labelframe $f -text "Variables"
   label $f.lblHeadingVariables -text "Variable"
   button $f.btnHeadingTime -text "Time Frame (refresh)" \
      -command [itcl::code $this refresh_times]
   label $f.lblHeadingPlot -text "Plot Segment"

   grid configure x $f.lblHeadingVariables $f.btnHeadingTime \
      $f.lblHeadingPlot - -sticky ew

   set _count [llength $itk_option(-segmentvariables)]
   set idx 0
   foreach segment $itk_option(-segmentvariables) {
      incr idx

      if {[lsearch [set $itk_option(-varlistvariable)] $segment] < 0} {
         lappend $itk_option(-varlistvariable) $segment
      }
      set _segment($idx,var) $segment
      set _segment($idx,use) 1
      set _segment($idx,time) "..."
      set _segment($idx,win) 0

      checkbutton $f.chk$idx \
         -variable [itcl::scope _segment($idx,use)]

      iwidgets::combobox $f.cbo$idx \
         -textvariable [itcl::scope _segment($idx,var)] \
         -editable false \
         -selectioncommand [itcl::code $this clear_time $idx]
      $f.cbo$idx component list configure \
         -listvariable $itk_option(-varlistvariable)

      label $f.lbl$idx \
         -textvariable [itcl::scope _segment($idx,time)]

      button $f.btnPlot$idx -text "Plot in:" \
         -command [itcl::code $this plot_segment $idx]

      spinbox $f.spnWin$idx \
         -textvariable [itcl::scope _segment($idx,win)] \
         -from 0 -to $itk_option(-maxwin) -width 2

      grid $f.chk$idx $f.cbo$idx $f.lbl$idx \
         $f.btnPlot$idx $f.spnWin$idx \
         -sticky ew
      grid columnconfigure $f 1 -weight 1
   }
   unset idx

   set f $w.fraBottom1
   frame $f
   button $f.btnMerge -text "Merge to:" \
      -command [itcl::code $this merge_selected]
   entry $f.entMergeVar \
      -textvariable [itcl::scope _merge_var]

   button $f.btnPlot -text "Plot in:" \
      -command [itcl::code $this plot_selected]

   spinbox $f.spnWin \
      -textvariable $itk_option(-windowvariable) \
      -from 0 -to $itk_option(-maxwin) -width 2

   button $f.btnStats -text "Statistics" \
      -state disabled

   grid $f.btnPlot $f.spnWin x $f.btnStats x $f.btnMerge $f.entMergeVar \
      -sticky we
   grid columnconfigure $f 6 -weight 2
   grid columnconfigure $f [list 2 4] -weight 1

   set f $w.fraBottom2
   frame $f
   button $f.btnDefine -text "Define Region to Process" \
      -state disabled
   button $f.btnNew -text "New Segment Window" \
      -command [itcl::code $this new_segment_window]

   grid $f.btnDefine x $f.btnNew -sticky we
   grid columnconfigure $f 1 -weight 1

   grid $w.fraVariables -sticky we
   grid $w.fraBottom1 -sticky we
   grid $w.fraBottom2 -sticky we
   grid columnconfigure $w 0 -weight 1

   refresh_times
}

itcl::body SegmentedDataWindow::refresh_times {} {
   for {set i 1} {$i <= $_count} {incr i} {
      exp_send "tk_sdw_send_times, \"[itcl::scope $this]\", $i,\
         $_segment($i,var);\r"
      expect ">"
   }
}

itcl::body SegmentedDataWindow::set_time {idx time_start time_end} {
   set _segment($idx,time) "$time_start - $time_end"
}

itcl::body SegmentedDataWindow::clear_time {idx} {
   set _segment($idx,time) "..."
}

itcl::body SegmentedDataWindow::plot_segment {idx} {
   global pro_var win_no

   set win_bkp $win_no
   set var_bkp $pro_var

   set win_no $_segment($idx,win)
   set pro_var $_segment($idx,var)
   plot_fltlines 0

   set win_no $win_bkp
   set pro_var $var_bkp
}

itcl::body SegmentedDataWindow::plot_selected {} {
   global pro_var l1pro_fma

   set fma_bkp $l1pro_fma
   set var_bkp $pro_var

   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         set pro_var $_segment($idx,var)
         plot_fltlines 0
         set l1pro_fma 0
      }
   }

   set l1pro_fma $fma_bkp
   set pro_var $var_bkp
}

itcl::body SegmentedDataWindow::merge_selected {} {
   global pro_var

   exp_send "$_merge_var = \[\];\r"
   expect ">"

   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         exp_send "grow, $_merge_var, $_segment($idx,var) ;\r"
         expect ">"
      }
   }

   append_varlist $_merge_var
   set _merge_var ""
}

itcl::body SegmentedDataWindow::launch_stats {args} {
}

itcl::body SegmentedDataWindow::define_region {} {
}

itcl::body SegmentedDataWindow::new_segment_window {} {
   set seg_vars [list]
   for {set idx 1} {$idx <= $_count} {incr idx} {
      if {$_segment($idx,use)} {
         lappend seg_vars $_segment($idx,var)
      }
   }

   if {[llength $seg_vars]} {
      set sdw [SegmentedDataWindow .#auto \
         -varlistvariable ::varlist \
         -maxwin 64 \
         -segmentvariables $seg_vars \
         -windowvariable ::win_no]

      $sdw activate
   } else {
      tk_messageBox -icon warning \
         -message "No variables were selected." \
         -type ok
   }
}

proc segment_by_flightlines {yvar} {
   set var_prefix "::tempvar_[expr {round(rand()*1000)}]_[clock seconds]_"
   set i 1
   while {[info exists $var_prefix$i]} {
      incr i
   }
   set var $var_prefix$i
   set $var -1

   exp_send "require, \"data_segments.i\";\r"
   expect ">"
   exp_send "fptr = split_by_fltline($yvar);\r"
   expect ">"
   exp_send "tkcmd, swrite(format=\"set $var %d\", numberof(fptr));\r"
   expect ">"

   idle [list _segment_by_flightlines_post $yvar $var]
}

proc _segment_by_flightlines_post {yvar count_var} {
   if {[set $count_var] < 0} {
      idle [list _segment_by_flightlines_post $yvar $count_var]
   } else {
      set segment_count [set $count_var]
      unset $count_var

      set seg_vars [list]
      for {set i 1} {$i <= $segment_count} {incr i} {
         set seg_var ${yvar}_flt$i
         exp_send "$seg_var = *fptr($i)\r"
         expect ">"
         lappend seg_vars $seg_var
      }

      set sdw [SegmentedDataWindow .#auto \
         -varlistvariable ::varlist \
         -maxwin 64 \
         -segmentvariables $seg_vars \
         -windowvariable ::win_no \
         -title "Flightline Segments for $yvar"]

      $sdw activate
   }
}

proc idle {cmd} {
   after idle [list after 0 $cmd]
}

