#!/bin/sh
# \
exec wish "$0" ${1+"$@"}

# /* vim: set tabstop=3 softtabstop=3 shiftwidth=3 shiftround autoindent expandtab syntax=tcl: */

# Program to add some limited tcl/Tk GUI capability to Yorick programs.
#
# Original - C. W. Wright wwright@usgs.gov
#
# This program is copyrighted under the terms of
# The GNU GENERAL PUBLIC LICENSE,  Version 2, June 1991.
# A full copy can be found at: http://www.gnu.org/licenses/gpl.txt
#
# The main site for this program is:
#     http://ytk.sourceforge.net
# *** NOTE: The newer version at ytk.sourceforge.net isn't compatible
# with ytk (yet) so don't try using it.
#
# This version of Ytk is a fork from the version found at SourceForge,
# tailored for ALPS.
#
# Revision history
#
# 11/12/2008 - David Nagle
#  * Refactored most of the code into procs
#  * Simplified and reduced repetitive chunks of code
#  * Implemented a -nogui option that suppresses the YTK GUI menubar
#  * Implemented a -gui option that forces the display of the YTK GUI menubar
#    (it shows by default; however, "./ytk -nogui -gui" results in -gui
#    overriding -nogui)
#  * The logic for finding the yorick executable has been cleaned up and improved.
#  * Removed large sections of commented-out code that was obsolete. Also
#    removed some left over code relics that were no longer in use.
#  * Removed a bunch of disabled menu entries that had no functionality
#    supplied under Graph -> Plot. I left a note in the comments indicating
#    what was removed, with a "TODO" note suggesting that they get added back
#    later once code has been written to implement them.
#  * Improved robustness in the spawning process slightly. If spawning via
#    rlterm is requested but fails, it will move on to try using rlwrap (if
#    enabled), and then on to spawning yorick without any wrappers.
#  * Updated the comments up above to indicate that this version of "ytk" has
#    diverged from the version found at Sourceforge.
#
# 06/02/2005 - Amar Nayegandhi
#  Added option to use rlwrap or rlterm with yorick. Default setting uses
#  rlwrap. Download rlwrap from: http://www.maumae.net/yorick/rlwrap-0.18.tar.gz
#
# 5/31/2003 Added runline commands.  Now you can say:  ytk somefile.[ytk,i,tcl,tk]
# 1/3/2002
#  -> Added  extended help for menu items.
#  -> Moved fifos to users home dir and use a unique name so several
#     Ytks can run at once.
#  -) Added "Save Options" button in Edit pulldown.
#  -) Added .ytkrc default file in users home dir.
#  -) Changed many variables to be elements of the _ytk array so
#     they can easily be saved/restored in .ytkrc
#
#   1/2/2002 ww *) Moved fifos to user's home dir and added some "uniqueness"
#                  to the name to avoid problems when two or more ytks are running.
# 12/31/2001 ww *) Minor changes to gracefully fail if ytk can't find Yorick.
#               *) Added code to look for yorick and rlterm and use what it
#                  finds if it can't use what the user provided.
# 12/28/2001 ww Added some simple most recent file selection stuff
# 12/21/2001 ww Added /tmp/ytk fifo for passing data back from yorick
#               to tcl/tk.  Also added /tmp/tky for sending stuff from
#               tcl/tk to Yorick in cases where you want/need to avoid
#               using the exp_send command.

# Exit codes
# 0 - Program ended normally
# 1 - Problem encountered with one of the files passed to load on the command line
# 2 - No Yorick found
# 3 - Problem encountered while spawning Yorick

proc app_root_dir {} {
   # Copied from http://wiki.tcl.tk/1710
   set originalPath [pwd]
   set scriptPath   $::argv0
   set workingPath  [file dirname $::argv0]
   while {![catch {file readlink $scriptPath} result]} {
      cd $workingPath
      set scriptPath  [file join [pwd] $result]
      set workingPath [file dirname $scriptPath]
   }
   cd [file dirname $scriptPath]
   set scriptPath [pwd]
   cd $originalPath
   return $scriptPath
}

proc check_requirements {} {
   if {[package vcompare [info patchlevel] 8.5] < 0} {
      puts "                         *** *** *** ERROR! *** *** ***

ALPS requires Tcl version 8.5 or later. You are running version [info patchlevel].

Please upgrade your installation of ALPS. Directions can be found in
[file join [file dirname [app_root_dir]] doc/install-alps.html]"
      exit
   }

   if {![file isdirectory [file join [app_root_dir] tcllib l1pro]]} {
      puts "                         *** *** *** ERROR! *** *** ***

Your ALPS is missing required source subdirectories. Please run cvs update
using the -d option to update subdirectories:

   cvs update -d"
      exit
   }

   set missing 0
   if {
      [catch {package require getstring}] || [catch {package require Iwidgets}] ||
      [catch {package require BWidget}] || [catch {package require Expect}]
   } {
      puts "                         *** *** *** ERROR! *** *** ***

ALPS cannot find some required packages in Tcl.

Please upgrade your installation of ALPS. Directions can be found in
[file join [file dirname [app_root_dir]] doc/install-alps.html]"
      exit
   }
}

check_requirements

::tcl::tm::path add [file join [app_root_dir] tcllib]

# Ensures that programs in .../eaarl/bin are detected and take precedence when
# using auto_execok
set bindir [file join [file dirname [file dirname [app_root_dir]]] bin]
set pathsep [expr {$::tcl_platform(platform) eq "windows" ? ";" : ":"}]
set env(PATH) $bindir$pathsep$env(PATH)

package require Tk
package require tile
package require BWidget
package require Expect
package require Iwidgets
package require fileutil
package require log
package require struct::list
package require mixin
package require yorick

option add *tearOff 0
foreach __theme [ttk::style theme names] {
   ttk::style theme settings $__theme {
      ttk::style configure TButton -justify center
   }
}
unset __theme
wm withdraw .

set gui_enabled 1
if { ![catch {package require cmdline}] } {
   set ytk_cmdline_options {
      {gui     "force ytk gui to load"}
      {nogui   "disable ytk gui"}
   }
   set usage ": ytk \[options] \[filename]\n:options:"
   array set params [::cmdline::getoptions argv $ytk_cmdline_options $usage]
   if { $params(nogui) } {
      set gui_enabled 0
   }
   if { $params(gui) } {
      set gui_enabled 1
   }
}

set load_on_start ""
if { $argc != 0 } {
  set load_on_start $argv
}

set ycode_dir "."
set ytkcode_dir "."
set Y_SITE ""

################################################################################
#                                  Procedures                                  #
################################################################################

proc ystr {val {quoted 1}} {
##
# ystr val [quoted]
#  Sanitizes a string so that it can be safely sent to Yorick. Things like
#  quotes, newlines, and tabs will be escaped.
#
# Arguments:
#  val - The string to sanitize
#  quoted - Optional. By default, the returned string will be surrounded in
#     quotes. Set this to 0 to omit the quotes.
#
# Returns:
#  A sanitized string suitable for Yorick.
#
# Side effects:
#  None
##
   set yval [string map [list \
      \\ \\\\  \
      \" \\\"  \
      \n \\n   \
      \b \\b   \
      \f \\f   \
      \r \\r   \
      \t \\t   \
   ] $val]
   if {$quoted} {
      set yval "\"$yval\""
   }
   return $yval
}

proc string_to_hex input {
# Converts input, which can be any arbitrar string of data, into hexadecimal
# format. This is a simple form of ASCII-armoring and is used by ybkg to
# protect newlines and other potentially troublesome characters.
   join [::struct::list mapfor c [split $input {}] {format %02x [scan $c %c]}] ""
}

# From http://wiki.tcl.tk/727
proc intgen {{seed 0}} {
   set self [lindex [info level 0] 0]
   proc $self "{seed [incr seed]}" [info body $self]
   set seed
}

proc sleep {{ms 200}} {
   set sleepvar "::__sleep_var_[intgen]__"
   after $ms [list set $sleepvar 0]
   vwait $sleepvar
   unset $sleepvar
}

set __ybkg__wait 0
proc ybkg args {
##
# ybkg args
#  Sends a command to Yorick in the background. This does NOT accept normal
#  Yorick commands!! You must format them in a format acceptable to funcdef. In
#  Yorick, use 'help, funcdef' for more information.
#
#  Some examples:
#
#     ybkg write 1 2 3
#        -- Corresponds to: write, 1, 2, 3
#
#     ybkg write \"Hello, world!\"
#        -- Corresponds to: write, "Hello, world!"
#
#     ybkg write {"Hello, world!"}
#        -- Corresponds to: write, "Hello, world!"
#
#     ybkg {write "Hello, world!"}
#        -- Corresponds to: write, "Hello, world!"
#
#     ybkg funcset foo 10
#        -- Corresponds to: funcset, foo, 10
#           which corresponds to: foo = 10
#
#  Please be aware that you will NOT receive any notifications in the case of
#  errors! They will be silently ignored.
#
#  Also, do not use ystr with this. The input for funcdef does not require as
#  many escapes.
#
#  Also, do not send any input that includes newlines. It just doesn't work
#  yet.
##
   set cmd [eval concat $args]
   set ::__ybkg__wait 1
   set cmd [string_to_hex $cmd]
   puts $::tky_fifo "bkg $cmd"
   while {$::__ybkg__wait} {sleep 1}
}

proc yget yvar {
##
# set val [yget yvar]
#  This retrieves the value of a yorick variable yvar.
##
   set wait_var ::__yvar_tmp_[intgen]__
   set cancel [after 1000 [list set $wait_var {}]]
   after 0 [list after idle [list ybkg tksetvar \"$wait_var\" \"$yvar\"]]
   vwait $wait_var
   after cancel $cancel
   set result [set $wait_var]
   unset $wait_var
   return $result
}

proc tky_tie {cmd type tkvar - yvar args} {
##
# Subcommands:
#     tky_tie add broadcast tkvarName to yvarName [-initialize 1]
#     tky_tie add sync tkvarName with yvarName [-initialize 1 -src tcl]
#     tky_tie add read tkvarName from yvarName [-initialize 1]
#     tky_tie remove broadcast tkvarName to yvarName
#     tky_tie remove sync tkvarName with yvarName
#     tky_tie remove read tkvarName from yvarName
#
# This adds or removes a tie between a Tcl variable and a Yorick variable.
# There are two kinds of ties: broadcast and sync.
#
# broadcast
#  With a broadcast tie, the Tcl variable will broadcast its value to Yorick
#  whenever it gets set. However, Yorick will still remain free to change this
#  value at will in between broadcasts. The broadcast only happens when the
#  variable is set. You can force a new broadcast by doing this:
#     set tkVar [set $tkVar]
#
#  The broadcast tie supports one optional setting. If you specify "-initialize
#  1", then Yorick will be initialized with the Tcl variable's current value.
#  Without this option, Yorick doesn't get update until the variable is
#  assigned to next.
#
# sync
#  With a sync tie, Tcl does its best to keep the same value in both Yorick and
#  Tcl. When Tcl sets the variable to a new value, that value is broadcast to
#  Yorick. When Tcl needs to retrieve the variable's value, it asks Yorick what
#  the current value is. Thus, the Tcl variable effectively becomes an alias
#  for the Yorick variable.
#
#  One major caveat: Changing the Yorick variable will not immediately provoke
#  a change in the Tcl variable. For example, if you are using the Tcl variable
#  in a GUI, the GUI will not immediately update. It won't update until Tcl
#  next references that variable explicitly in some fashion.
#
#  You can force a sync by doing this:
#     set tkVar
#
#  The sync tie supports two optional settings. If you specify "-initailize 1",
#  then Yorick will be initialized with the Tcl variable's current value. If
#  you additionally specify -src tcl, then the reverse will happen: Tcl will be
#  initialized with the Yorick variable's current value.
#
# read
#  With a read tie, the Tcl variable will ask Yorick for its value whenever it
#  is acccessed. As with sync, this only occurs when the variable is explicitly
#  checked.
#
#  When a read tie is in effect, it is still technically permissible to set the
#  Tcl variable. However, the changes have no effect so this is not
#  recommended.
#
#  The read tie supports one optional setting. If you specify "-initialize 1",
#  then Tcl will be initialized with the Yorick variable's current value. This
#  is useful if tying to a variable that is used in a GUI.
##
   array set opts [list -initialize 0 -src yor]
   array set opts $args
   switch -- $cmd {
      add - remove {}
      append {
         if {![string length [info procs trace_append]]} {
            error "Unknown command: $cmd"
         }
      }
      default {
         error "Unknown command: $cmd"
      }
   }
   if {[regexp {^(.*?)(?:\((.*)\))$} $tkvar - var key]} {
      set tkvar [uplevel [list namespace which -variable $var]]($key)
   } else {
      set tkvar [uplevel [list namespace which -variable $tkvar]]
   }
   switch -- $type {
      broadcast {
         if {$cmd ne "remove" && $opts(-initialize)} {
            __tky_tie_write $tkvar $yvar - - -
         }
         if {$cmd eq "append"} {
            trace_append variable $tkvar write [list __tky_tie_write $tkvar $yvar]
         } else {
            trace $cmd variable $tkvar write [list __tky_tie_write $tkvar $yvar]
         }
      }
      sync {
         if {$cmd ne "remove" && $opts(-initialize)} {
            if {$opts(-src) eq "tcl"} {
               __tky_tie_write $tkvar $yvar - - -
            } else {
               __tky_tie_read $tkvar $yvar - - -
            }
         }
         if {$cmd eq "append"} {
            trace_append variable $tkvar write [list __tky_tie_write $tkvar $yvar]
            trace_append variable $tkvar read [list __tky_tie_read $tkvar $yvar]
         } else {
            trace $cmd variable $tkvar write [list __tky_tie_write $tkvar $yvar]
            trace $cmd variable $tkvar read [list __tky_tie_read $tkvar $yvar]
         }
      }
      read {
         if {$cmd ne "remove" && $opts(-initialize)} {
            __tky_tie_read $tkvar $yvar - - -
         }
         if {$cmd eq "append"} {
            trace_append variable $tkvar read [list __tky_tie_read $tkvar $yvar]
         } else {
            trace $cmd variable $tkvar read [list __tky_tie_read $tkvar $yvar]
         }
      }
      default {
         error "Unknown type $type"
      }
   }
   return
}

proc __tky_tie_write {tkvar yvar name1 name2 op} {
# Used by tky_tie
   ybkg var_expr_tkupdate \"$yvar\" \"[set $tkvar]\"
}

proc __tky_tie_read {tkvar yvar name1 name2 op} {
# Used by tky_tie
   set $tkvar [yget $yvar]
}

proc tky_set {varName val} {
# Used by ytk.i's tksetval.
   upvar $varName var

   if {[string match {"*"} $val]} {
      # Scalar string, need to eval to unescape newlines and lose quotes
      eval set var $val
   } elseif {[string match {\[*\]} $val]} {
      if {[string match *\"* $val]} {
         # Array of strings... cannot parse safely so we pass through
         set var $val
      } else {
         # Array of non-strings, easy to convert to a list
         set var [lindex [string map [list \[ \{ \] \} , " "] $val] 0]
      }
   } else {
      # Anything else either doesn't require special handling, or requires
      # special handling we cannot provide so we pass it through
      set var $val
   }
}

proc y_messageBox {message type title} {
##
# y_messageBox message type title
#  Displays a messagebox, waits for the user to click a button, then returns
#  their response to Yorick. This is used by tk_messageBox in Yorick.
#
#  The primary reason for using this over the native tk_messageBox is to ensure
#  that the dialog is visible to the user. The normal tk_messageBox does not
#  raise above other windows, which means it's often not seen right away.
#
# Arguments:
#  message - A string to show in the box.
#  type - The type of message box, identical to tk_messageBox -type options.
#  title - The title for the message box window.
##
   set dlg [iwidgets::messagedialog .#auto -title $title \
      -modality application -text $message]

   switch -- $type {
      abortretryignore {
         $dlg buttonconfigure 0 \
            -text "Abort" -command [list $dlg deactivate abort]
         $dlg buttonconfigure 1 \
            -text "Retry" -command [list $dlg deactivate retry]
         $dlg buttonconfigure 2 \
            -text "Ignore" -command [list $dlg deactivate ignore]
         $dlg hide 3
      }
      ok {
         $dlg buttonconfigure 0 \
            -text "OK" -command [list $dlg deactivate ok]
         $dlg hide 1
         $dlg hide 2
         $dlg hide 3
      }
      okcancel {
         $dlg buttonconfigure 0 \
            -text "OK" -command [list $dlg deactivate ok]
         $dlg buttonconfigure 1 \
            -text "Cancel" -command [list $dlg deactivate cancel]
         $dlg hide 2
         $dlg hide 3
      }
      retrycancel {
         $dlg buttonconfigure 0 \
            -text "Retry" -command [list $dlg deactivate retry]
         $dlg buttonconfigure 1 \
            -text "Cancel" -command [list $dlg deactivate cancel]
         $dlg hide 2
         $dlg hide 3
      }
      yesno {
         $dlg buttonconfigure 0 \
            -text "Yes" -command [list $dlg deactivate yes]
         $dlg buttonconfigure 1 \
            -text "No" -command [list $dlg deactivate no]
         $dlg hide 2
         $dlg hide 3
      }
      yesnocancel {
         $dlg buttonconfigure 0 \
            -text "Yes" -command [list $dlg deactivate yes]
         $dlg buttonconfigure 1 \
            -text "No" -command [list $dlg deactivate no]
         $dlg buttonconfigure 2 \
            -text "Cancel" -command [list $dlg deactivate cancel]
         $dlg hide 3
      }
   }

   $dlg center
   after 1 raise $dlg
   exp_send "[$dlg activate]\r"
}

proc yorick_executable {} {
##
# yorick_executable
#  Attempts to determine the yorick executable file.
#
#  In order of priority, tries to use the following:
#     - value of _ytk(yorick_executable), if set (from .ytkrc)
#     - ../../bin/yorick
#     - ../../yorick/bin/yorick
#     - yorick in path (shell call to "which yorick")
#     - yorick provided by user when prompted for one
#     - empty string (which means Ytk will probably exit)
#
# Arguments:
#  None
#
# Returns:
#  A string representing the path+filename to the Yorick executable. If no
#  executable is available, an empty string is returned.
##
   set flag yes
   while {[auto_execok yorick] eq "" && $flag eq "yes"} {
      set flag [tk_messageBox -icon error -type yesno \
         -message "Ytk cannot locate Yorick, which it needs to function. Would you like to manually locate a Yorick? (If you answer no, Ytk will exit.)"]
      if { $flag eq "yes" } {
         set ::_ytk(yorick_executable) [tk_getOpenFile -initialdir /]
      }
   }
}

proc trace__ytk {name1 name2 op} {
# When entries are added to _ytk in the form NAME_executable, auto_execs is
# updated so that NAME returns the new value placed in _ytk.
   if {[string match "*_executable" $name2]} {
      set cmd [string range $name2 0 end-11]
      set ::auto_execs($cmd) $::_ytk($name2)
   } elseif {$name2 eq "executables_path"} {
      set pathsep [expr {$::tcl_platform(platform) eq "windows" ? ";" : ":"}]
      set path [split $::env(PATH) $pathsep]
      set path [lreplace $path 0 0 $::_ytk($name2)]
      set ::env(PATH) [join $path $pathsep]
   }
}

proc restore_defaults {} {
##
# restore_defaults
#  Restores default values to the _ytk global.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Unsets the global _ytk, the defines it to a set of default values.
##
   global _ytk
   array unset _ytk *
   set _ytk(use_rlterm)          No
   set _ytk(use_rlwrap)          Yes
   set _ytk(separate_help_win)   Yes
   set _ytk(ycode_dir)           .
   set _ytk(ytkcode_dir)         /opt/eaarl/lidar-processing/src/
   set _ytk(plmk_default_color)  black
   set _ytk(plmk_default_msize)  0.2
   set _ytk(plmk_default_width)  0.5
   set _ytk(log_file)            ""
   set _ytk(log_level)           info
   set _ytk(initialdir)          /data/0
   set _ytk(rlwrap_nodupes)      1
}

proc save_options {} {
##
# save_options
#  Saves the user's _ytk options to a file for later retrieval.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Creates the file ~/.ytkrc and stores the contents of global _ytk to it.
#  Afterwards, the user will receive a GUI messagebox indicating whether it
#  succeeded or not.
##
   global _ytk
   set fn "~/.ytkrc"
   if { [catch {set f [open $fn "w+"]} err] } {
      tk_messageBox -icon error -message $err -type ok
   } else {
      foreach x [array names _ytk] {
         puts $f [format "set %32s    %-32s"  "_ytk($x)" $_ytk($x)]
      }
      close $f
      tk_messageBox -icon info -message "Options saved to: $fn" -type ok
   }
}

proc load_options {} {
##
# load_options
#  Loads the user's _ytk options from a file previously saved via save_options.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Restores the default values for _ytk (as defined by restore_defaults). Then
#  sources ~/.ytkrc, which presumbly updates some of the _ytk values with the
#  user's preferences. However, the sourcing is not done safely so this could
#  have virtually any side effect.
##
   global _ytk

   # Restore defaults -- in case .ytkrc doesn't specify everything
   restore_defaults

   set ytkrc_paths [list /etc/ytkrc ~/.ytkrc .ytkrc]

   foreach rc $ytkrc_paths {
      if {[file exists $rc]} {
         puts "Loading ytk configuration file: $rc"
         set cnf [interp create -safe]
         if {[catch [list interp invokehidden $cnf source $rc] err]} {
            puts "Error encountered in configuration file: $err"
         } else {
            if {[interp eval $cnf array exists _ytk]} {
               foreach key [interp eval $cnf array names _ytk] {
                  set _ytk($key) [interp eval $cnf set _ytk($key)]
               }
            }
         }
         interp delete $cnf
      }
   }
}

proc initialize_globals {} {
##
# initialize_globals
#  Initializes the values of global variables that are not initialized
#  elsewhere:
#     _ytk_mrl: The most recently used file list.
#     _ytk_mrl_idx: The current index into _ytk_mrl.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
##
   global _ytk_mrl_idx _ytk_mrl

   set _ytk_mrl_idx 1
   for { set i 1 } { $i <= 8 } { incr i } {
      set _ytk_mrl($i) ""
   }
}

proc establish_fifos {} {
##
# establish_fifos
#  Creates and configures the fifos needed for communication between Yorick and
#  Tcl (in both directions).
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Establishes the following global variables:
#     ytk_fifo_name: The filename of the Yorick->Tcl fifo.
#     tky_fifo_name: The filename of the Tcl->Yorick fifo.
#     ytk_fifo: The filehandle for the Yorick->Tcl fifo.
#     tky_fifo: The filehandle for the Tcl->Yorick fifo.
#     tkcmd_line: Set to 0.
#  Also configures ytk_fifo to call ytk_fifo_fileevent for the readable
#  fileevent.
##
   global ytk_fifo_name tky_fifo_name tkcmd_line ytk_fifo tky_fifo

   set tkcmd_line 0

   set fifos [::yorick::create_fifos]
   lassign $fifos ytk_fifo ytk_fifo_name tky_fifo tky_fifo_name

   fileevent $ytk_fifo readable ytk_fifo_fileevent
}

proc ytk_fifo_fileevent {} {
##
# ytk_fifo_filevent
#  Processes a command received on the Yorick->Tcl fifo. This is invoked by the
#  fileevent readable on $ytk_fifo.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  This will evaluate the first string found on the fifo $ytk_fifo. If .tx.doc
#  exists, it will be updated accordingly. If an error is encountered, the user
#  is notified via expect as well as on .tx.doc.
#
#  If there isn't a complete line available on the fifo, this does nothing.
##
   global tkcmd_line ytk_fifo

   set ycmdstr [gets $ytk_fifo]

   # If a full line isn't available, gets will return ""
   if {[string length $ycmdstr]} {
      incr tkcmd_line
      tx_doc "$tkcmd_line:$ycmdstr\n"

      if { [catch { uplevel #0 $ycmdstr } errcode] } {
         send_user "*** Ytk Error in:$ycmdstr\n"
         tx_doc "**ERROR:  $errcode\n"
      }

      # Disabling this update for now, as it shouldn't be necessary and because
      # update is often a source of bugs.
      update idletasks
   }
}

proc tx_doc {message} {
##
# tx_doc message
#  Updates .tx.doc with the given message. If .tx.doc does not exist, this is a
#  no-op.
#
# Arguments:
#  A list that comprises valid arguments to .tx.doc.
#
# Returns:
#  Nothing
#
# Side effects:
#  Inserts $message at the end of .tx.doc; scrolls to the bottom; and deletes
#  all but the last 100 lines.
##
   if {[winfo exists .tx.doc]} {
      .tx.doc insert end $message
      .tx.doc yview moveto 1.0
      .tx.doc delete 1.0 "end - 100 lines"
   }
}

proc spawn_yorick {} {
##
# spawn_yorick
#  Attempts to spawn Yorick. If rlterm or rlwrap are available on the system
#  path, they will be used if the user has enabled them (rlterm takes
#  precedence over rlwrap if both exist and are enabled).
#
# Arguments:
#  None
#
# Returns:
#  0 if the spawn succeeded; 1 if it did not.
#
# Side effects:
#  If successful, then expect does whatever it does when spawn works (including
#  setting various expect-related variables), in the global scope.
##
   global _ytk ytk_fifo_name tky_fifo_name
   set rlterm [expr {$_ytk(use_rlterm) eq "Yes"}]
   set rlwrap [expr {$_ytk(use_rlwrap) eq "Yes"}]
   return [::yorick::spawn $ytk_fifo_name $tky_fifo_name -rlwrap $rlwrap \
      -rlterm $rlterm]
}

proc ytk_exit {code} {
##
# ytk_exit code
#  Exits Yorick with the given code after performing cleanup (which consists of
#  closing and deleting the fifos).
#
# Arguments:
#  code: A integer in the range 0-127, which will be returned as the exit code.
#
# Returns:
#  Nothing
#
# Side effects:
#  The fifos are closed and their corresponding files deleted. Then the
#  application terminates with the given exit $code.
##
   global ytk_fifo_name tky_fifo_name ytk_fifo tky_fifo
   ::yorick::destroy_fifos $ytk_fifo $ytk_fifo_name $tky_fifo $tky_fifo_name
   exit $code
}

proc most_recent_loaded {} {
##
# most_recent_loaded
#  Creates a GUI window that lists the most recently loaded files, as defined
#  in _ytk_mrl. Double-clicking an entry will cause it to be sourced via
#  most_recent_lb_dbl_clk.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   global _ytk_mrl

   set w .most_recent

   destroy $w
   toplevel $w
   wm transient $w .

   listbox $w.lb -height 0 -width 0
   button $w.dismiss -text "Dismiss" -command [list destroy $w]
   pack   $w.lb $w.dismiss -side top -fill x
   for { set i 1 } { $i <= 8 } { incr i } {
      if { $_ytk_mrl($i) != "" } {
         $w.lb insert end "$i [file tail $_ytk_mrl($i)]"
      }
   }

   bind $w.lb <Double-Button-1> most_recent_lb_dbl_clk
}

proc most_recent_lb_dbl_clk {} {
##
# most_recent_lb_dbl_clk
#  Used by the binding of <Double-Button-1> on .most_recent (created in
#  most_recent_loaded). This sources the code file represented by that entry in
#  the list box.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Global _ytk_fn is set to the filename represented by the listbox selection.
#  If _ytk_fn ends with .i, then global ycode_dir is set to match _ytk_fn's
#  directory.
#
#  If _ytk_fn ends with .tcl, .tk, or .ytk, it is sourced at the global level
#  and could have any effect. If ytk_fn ends with .i, it is sourced into Yorick
#  and could have any effect; also, Tcl's and Yorick's current directories are
#  changed to ycode_dir.
##
   global _ytk_fn _ytk_mrl

   set idx [lindex [selection get] 0]
   set _ytk_fn $_ytk_mrl($idx)

   source_ytk_file $_ytk_fn
}

proc source_ytk_file {filename} {
##
# source_ytk_file filename
#  Sources the file defined by $filename -- in Yorick if it's a .i file, in Tcl
#  if it's a .ytk, .tk, or .tcl file.
#
# Arguments:
#  None
#
# Returns:
#  1 if the file is one of .i, .ytk, .tk, or .tcl; 0 otherwise.
#
# Side effects:
#  The file is sourced (in either Yorick or Tcl), which could have any effect
#  depending on the code in question.
#
#  If the file is a .i file, then global ycode_dir is set to its containing
#  directory and both Tcl and Yorick have their working directory updated to
#  match it.
##
   global ycode_dir
   switch [file extension $filename] {
      ".tcl" -
      ".tk"  -
      ".ytk" {
         uplevel #0 [list source $filename]
         return 1
      }
      ".i" {
         set ycode_dir [file dirname $filename]
         cd $ycode_dir
         ybkg cd \"$ycode_dir\"
         exp_send "#include \"$filename\"\r"
         expect "> "
         return 1
      }
      default {
         return 0
      }
   }
}

proc ytk_mr_enqueue {f} {
##
# ytk_mr_enqueue filename
#  Addes a file to the "most recently loaded" files list.
#
# Arguments:
#  filename: The name of a file to put in the most recent files list.
#
# Returns:
#  Nothing
#
# Side effects:
#  Stores $filename in global _ytk_mrl in the index specified by global
#  _ytk_mrl_idx, then increments _ytk_mrl_idx (but sets it to 1 if it exceeds
#  8).
##
   global _ytk_mrl _ytk_mrl_idx
   set _ytk_mrl($_ytk_mrl_idx) $f
   incr _ytk_mrl_idx
   if { $_ytk_mrl_idx > 8 } { set _ytk_mrl_idx 1 }
}

proc select_ytk_fn {start_dir} {
##
# select_ytk_fn start_dir
#  Prompts the user to select a file to source (with starting directory
#  $start_dir), the sources it.
#
# Arguments:
#  start_dir: String indicating the directory to start in when prompting for a
#     file.
#
# Returns:
#  Nothing
#
# Side effects:
#  Global _ytk_fn is set to the selected file's name.
#
#  The file is sourced at the global scope, which could have any effect; see
#  source_ytk_file.
#
#  If the file is recognized as a valid kind of file by source_ytk_file, then
#  it's added to the "most recent files" list by way of ytk_mr_enqueue.
##
   global _ytk_fn

   set _ytk_fn [tk_getOpenFile \
      -initialdir $start_dir -filetypes {
         {{Yorick Specfic Tcl/Tk Programs} {.ytk} }
         {{Yorick or Tcl/tk program} {.i .ytk}  }
         {{Yorick Programs} {.i}  }
         {{Tcl/Tk Programs} {.tcl .tk} }
         {{All Files}       {*}   }
      }]

   if {[source_ytk_file $_ytk_fn]} {
      ytk_mr_enqueue $_ytk_fn
   }
}

proc start_yorick {}  {
##
# start_yorick
#  Starts the main Yorick loop. This primarily watches for DOCUMENT strings and
#  will catch them to display in GUI form if configured to do so.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  If configured to spawn documentation for Yorick via Tcl, this will watch
#  Yorick's output and attempt to intercept DOCUMENT statements. Otherwise, it
#  lets everything else pass through as-is.
#
#  In order to avoid hanging, this will only catch DOCUMENT statements that are
#  received within an interval of a single second.
##
   global _ytk interact_out indoc hwin str Y_SITE
   upvar spawn_id spawn_id
   expect ">"
   set n 0
   interact {
      -o
      -nobuffer
      -re "/\\* DOCUMENT.*\n" {
         regsub -all "\r" $interact_out(0,string) "" str
         if { $_ytk(separate_help_win) eq "Yes" } {
            interact {
               -o
               -re ".*\\*/" {
                  regsub -all "\r" $interact_out(0,string) "" str2
                  set str "$str$str2"
                  incr hwin
                  set wintitle [ lindex [ split $str "\n" ] 0 ]
                  toplevel .docwin$hwin
                  set cmd "scrollbar .docwin$hwin.sb -command {.docwin$hwin.doc yview }"
                  eval $cmd

                  ::mixin::text::readonly .docwin$hwin.doc -height 25 \
                     -yscrollcommand [list .docwin$hwin.sb set]
                  .docwin$hwin.doc ins end $str
                  pack .docwin$hwin.doc -side left -fill both -expand 1
                  pack .docwin$hwin.sb -side left -fill y -expand 0
                  wm title .docwin$hwin $wintitle
                  return
               }
               timeout 1 return
            }
         }
      }
   }
}

proc load_and_run {fn} {
##
# load_and_run fn
#  Attempts to load and run the given file $fn. If it fails, the program aborts
#  after notifying the user.
#
#  This is only used when starting Ytk with a command-line file argument.
#
# Arguments:
#  fn: A string indicating the path/filename to try to load.
#
# Returns:
#  Nothing
#
# Side effects:
#  If it fails, the program terminates.
#
#  If it succeeds, almost any side effect could happen since it is sourcing
#  external code. See source_ytk_file for more info on side effects.
##
   if { ![file exists $fn] } {
      tk_messageBox -icon error -message "$fn not found" -type ok
      ytk_exit 1
   }

   if {[catch {source_ytk_file $fn} result]} {
      # Error
      tk_messageBox -icon error -type ok -message "Error parsing $fn:\n$result"
      ytk_exit 1
   } else {
      if {! $result} {
         # Wrong kind of file
         tk_messageBox -icon error -message "Don't know how to handle $fn" -type ok
         ytk_exit 1
      }
   }
}

proc restore_pbd {} {
##
# restore_pbd
#  The user is prompted for a pbd file. If one is provided, it is restored.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Global _ytk_fn is set to the selected file.
#
#  Within Yorick, any variables stored in the pbd are restored in the global
#  scope. Also, _ytk_pbd_f is set to an open filehandle to the pbd file.
##
   global _ytk_fn

   set _ytk_fn [tk_getOpenFile -filetypes {
      {{Yorick PBD file} {.pbd}}
      {{All Files}       {*}   }
   }]

   if { $_ytk_fn ne "" } {
      switch [file extension $_ytk_fn] {
         ".pbd" {
            exp_send "_ytk_pbd_f = openb(\"$_ytk_fn\"); restore, _ytk_pbd_f;\r"
            exp_send "show, _ytk_pbd_f\r"
            toplevel .stby
            exp_send "\r"
            set sz [wm maxsize .]
            label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
            pack .stby.lbl
            set wz "50 50"
            set sx [expr [lindex $sz 0] / 2 - [lindex $wz 0]/2]
            set sy [expr [lindex $sz 1] / 2 - [lindex $wz 1]/2]
            wm geometry .stby "+$sx+$sy"
            update
            expect ">"
            destroy .stby
         }
         default {
            tk_messageBox -type ok -icon error -message "Did not restore $_ytk_fn: not a PBD file."
         }
      }
   }
}

proc launch_gui {} {
##
# launch_gui
#  Sets up the core GUI for Ytk.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
##
   global Y_SITE _ytk yorick_version tk_patchLevel

   wm deiconify .
   wm minsize . 350 1
   . configure -width 350
   menu .mb
   . configure -menu .mb
   menu .mb.file
   menu .mb.edit
   menu .mb.edit.editor
   menu .mb.debug
   menu .mb.tkcon
   menu .mb.help
   .mb add cascade -label File  -underline 0 -menu .mb.file
   .mb add cascade -label Edit  -underline 0 -menu .mb.edit
   .mb add cascade -label Debug -underline 0 -menu .mb.debug
   .mb add cascade -label "Tcl/Tk" -underline 0 -menu .mb.tkcon
   .mb add cascade -label Help  -underline 0 -menu .mb.help

   .mb.edit add command -label "Save Options" -command save_options
   .mb.edit add command -label "Restore Defaults" -command restore_defaults
   .mb.edit add separator
   .mb.edit add command -label "Yorick executable ..." -command {
      set _ytk(yorick_executable) [tk_getOpenFile]
   }
   .mb.edit add checkbutton -label "Use rlterm" -onvalue Yes -offvalue No -variable _ytk(use_rlterm)
   .mb.edit add checkbutton -label "Use rlwrap" -onvalue Yes -offvalue No -variable _ytk(use_rlwrap)


   .mb.debug add command \
      -label "dbauto,0  Enter dbug automatically" -command { exp_send "dbauto,0\r" }
   .mb.debug add command \
      -label "dbauto,1  Enter dbug after hitting <RET>" -command { exp_send "dbauto,1\r" }
   .mb.debug add command -label "dbdis" -command { exp_send "dbdis\r" }
   .mb.debug add command -label "dbexit" -command { exp_send "dbexit\r" }
   .mb.debug add command -label "dbinfo" -command { exp_send "dbinfo\r" }
   .mb.debug add command -label "dbskip" -command { exp_send "dbskip\r" }
   .mb.debug add command -label "dbup" -command { exp_send "dbup\r" }

   .mb.tkcon add command -label "Tkcon" -command {
      exec tkcon &
   }

   .mb.tkcon add checkbutton -label "Tkcmd window"  \
      -onvalue "wm deiconify .tx" \
      -offvalue "wm withdraw .tx" \
      -variable tkcmdvalue  -underline 1 -command {eval $tkcmdvalue}

   .mb.help add checkbutton -label "Help goes in new window" \
      -onvalue Yes -offvalue No -variable _ytk(separate_help_win)

   .mb.file add command -label "Load a Yorick/ytk program file ..." \
      -command { select_ytk_fn $ytkcode_dir }
   .mb.file add command -label "Load Yorick/ytk from ~/Yorick ..." \
      -command { select_ytk_fn "~/Yorick" }
   .mb.file add command -label "Load Yorick/ytk from Y_SITE ..." \
      -command { select_ytk_fn $Y_SITE }

   .mb.file add command -label "Restore PBD Data file..." -command restore_pbd

   .mb.file add separator
   .mb.file add command -label "Most recent loaded" -command most_recent_loaded
   .mb.file add separator
   .mb.file add command -label "Close YTK GUI" -command [list wm withdraw .]
   .mb.file add command -label "Exit YTK" -command [list ytk_exit 0]

   toplevel .tx
   wm withdraw .tx
   button .tx.hide -text "Click to hide this window" \
      -command { .mb.tkcon invoke 2  }
   pack .tx.hide -side top -fill x -expand 1
   scrollbar .tx.sb -command {.tx.doc yview }
   text .tx.doc  -width 80 -height 4 -yscrollcommand {  .tx.sb set }
   pack  .tx.doc .tx.sb -side left -fill y -expand 1

   wm state . normal
}

######## END PROCEDURES ########

trace add variable _ytk write trace__ytk
restore_defaults     ;# begin with the default settings
load_options

############################################################
# Stuff below here doesn't need to be changed if you are
# just porting to another system.
############################################################

############# set _ytk(yorick_executable) junk
yorick_executable
if {[auto_execok yorick] eq ""} {
   puts stderr "No yorick found, aborting..."
   ytk_exit 2
}

initialize_globals
establish_fifos

puts " Tcl [info patchlevel], Tk $tk_patchLevel, Expect [exp_version] ready."
if { [spawn_yorick] } {
   puts "Encountered problem starting yorick... please restart with a different yorick"
   ytk_exit 3
}

expect "Yorick * ready"
set yorick_version [lindex [split $expect_out(0,string)] 1]

set indoc 0
set hwin 0
match_max -i $spawn_id 32768

wm withdraw .
wm protocol . WM_DELETE_WINDOW [list wm withdraw .]
if {$gui_enabled} {
   launch_gui
}

if { $load_on_start != "" } {
   foreach file_to_load $load_on_start {
      load_and_run $file_to_load
   }
}

ybkg funcset initialdir \"$_ytk(initialdir)\"
ybkg funcset _ytk 1
ybkg funcset _pid [pid]

start_yorick

ytk_exit 0
