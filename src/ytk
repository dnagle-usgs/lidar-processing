#!/bin/sh
# \
exec wish "$0" ${1+"$@"}
# vim: set syntax=tcl ts=4 sts=4 sw=4 ai sr et:

# Program to add some limited tcl/Tk GUI capability to Yorick programs.
#
# Original - C. W. Wright wwright@usgs.gov
#
# This program is copyrighted under the terms of
# The GNU GENERAL PUBLIC LICENSE,  Version 2, June 1991.
# A full copy can be found at: http://www.gnu.org/licenses/gpl.txt
#
# The main site for this program is:
#       http://ytk.sourceforge.net
#
# This version of Ytk is a fork from the version found at SourceForge, tailored
# for ALPS. At this point, the two are incompatible.

# Exit codes
# 0 - Program ended normally
# 1 - Problem encountered with one of the files passed to load on the command line
# 2 - No Yorick found
# 3 - Problem encountered while spawning Yorick

# Time that the script started
set _starttime [clock seconds]

proc app_root_dir {} {
    # Copied from http://wiki.tcl.tk/1710
    set originalPath [pwd]
    set scriptPath $::argv0
    set workingPath [file dirname $::argv0]
    while {![catch {file readlink $scriptPath} result]} {
        cd $workingPath
        set scriptPath  [file join [pwd] $result]
        set workingPath [file dirname $scriptPath]
    }
    cd [file dirname $scriptPath]
    set scriptPath [pwd]
    cd $originalPath
    return $scriptPath
}

::tcl::tm::path add [file join [app_root_dir] tcl]
::tcl::tm::path add [file join [app_root_dir] plugins eaarlb tcl]

# Ensures that programs in .../eaarl/bin are detected and take precedence when
# using auto_execok
set bindir [file join [file dirname [file dirname [app_root_dir]]] bin]
set pathsep [expr {$::tcl_platform(platform) eq "windows" ? ";" : ":"}]
set env(PATH) $bindir$pathsep$env(PATH)

package require Tk
package require style
package require BWidget
package require Expect
package require Iwidgets
package require base64
package require fileutil

package require struct::list
package require mixin
package require yorick
package require alpsrc
# alpsrc must come before logger
package require logger

wm withdraw .

set load_on_start ""
if { $argc != 0 } {
    set load_on_start $argv
}

set ycode_dir "."
set ytkcode_dir "."
set Y_SITE ""

################################################################################
#                                             Procedures                                             #
################################################################################

# From http://wiki.tcl.tk/727
proc intgen {{seed 0}} {
    set self [lindex [info level 0] 0]
    proc $self "{seed [incr seed]}" [info body $self]
    set seed
}

proc sleep {{ms 200}} {
    set sleepvar "::__sleep_var_[intgen]__"
    after $ms [list set $sleepvar 0]
    vwait $sleepvar
    unset $sleepvar
}

set __ybkg__wait 0
proc ybkg args {
##
# ybkg args
#   Sends a command to Yorick in the background. This does NOT accept normal
#   Yorick commands!! You must format them in a format acceptable to funcdef. In
#   Yorick, use 'help, funcdef' for more information.
#
#   Some examples:
#
#       ybkg write 1 2 3
#           -- Corresponds to: write, 1, 2, 3
#
#       ybkg write \"Hello, world!\"
#           -- Corresponds to: write, "Hello, world!"
#
#       ybkg write {"Hello, world!"}
#           -- Corresponds to: write, "Hello, world!"
#
#       ybkg {write "Hello, world!"}
#           -- Corresponds to: write, "Hello, world!"
#
#       ybkg funcset foo 10
#           -- Corresponds to: funcset, foo, 10
#               which corresponds to: foo = 10
#
#   Please be aware that you will NOT receive any notifications in the case of
#   errors! They will be silently ignored.
#
#   Also, do not use ystr with this. The input for funcdef does not require as
#   many escapes.
#
#   Also, do not send any input that includes newlines. It just doesn't work
#   yet.
##
    set cmd [eval concat $args]
    set ::__ybkg__wait 1
    fifo_log yor $cmd
    logger trace "Sending background command: $cmd"
    set cmd [base64::encode -wrapchar "" $cmd]
    logger trace "Encoded as: $cmd"
    puts $::tky_fifo "bkg $cmd"
    while {$::__ybkg__wait} {sleep 1}
}

proc yget yvar {
##
# set val [yget yvar]
#   This retrieves the value of a yorick variable yvar.
##
    set wait_var ::__yvar_tmp_[intgen]__
    set cancel [after 1000 [list set $wait_var {}]]
    after 0 [list after idle [list ybkg tksetvar \"$wait_var\" \"$yvar\"]]
    vwait $wait_var
    after cancel $cancel
    set result [set $wait_var]
    unset $wait_var
    return $result
}

proc tky_tie {cmd type tkvar - yvar args} {
##
# Subcommands:
#   tky_tie add broadcast tkvarName to yvarName [-initialize 1]
#   tky_tie add sync tkvarName with yvarName [-initialize 1 -src tcl]
#   tky_tie add read tkvarName from yvarName [-initialize 1]
#   tky_tie remove broadcast tkvarName to yvarName
#   tky_tie remove sync tkvarName with yvarName
#   tky_tie remove read tkvarName from yvarName
#
# This adds or removes a tie between a Tcl variable and a Yorick variable.
# There are two kinds of ties: broadcast and sync.
#
# broadcast
#   With a broadcast tie, the Tcl variable will broadcast its value to Yorick
#   whenever it gets set. However, Yorick will still remain free to change this
#   value at will in between broadcasts. The broadcast only happens when the
#   variable is set. You can force a new broadcast by doing this:
#       set tkVar [set $tkVar]
#
#   The broadcast tie supports one optional setting. If you specify "-initialize
#   1", then Yorick will be initialized with the Tcl variable's current value.
#   Without this option, Yorick doesn't get update until the variable is
#   assigned to next.
#
# sync
#   With a sync tie, Tcl does its best to keep the same value in both Yorick and
#   Tcl. When Tcl sets the variable to a new value, that value is broadcast to
#   Yorick. When Tcl needs to retrieve the variable's value, it asks Yorick what
#   the current value is. Thus, the Tcl variable effectively becomes an alias
#   for the Yorick variable.
#
#   One major caveat: Changing the Yorick variable will not immediately provoke
#   a change in the Tcl variable. For example, if you are using the Tcl variable
#   in a GUI, the GUI will not immediately update. It won't update until Tcl
#   next references that variable explicitly in some fashion.
#
#   You can force a sync by doing this:
#       set tkVar
#
#   The sync tie supports two optional settings. If you specify "-initailize 1",
#   then Yorick will be initialized with the Tcl variable's current value. If
#   you additionally specify -src tcl, then the reverse will happen: Tcl will be
#   initialized with the Yorick variable's current value.
#
# read
#   With a read tie, the Tcl variable will ask Yorick for its value whenever it
#   is acccessed. As with sync, this only occurs when the variable is explicitly
#   checked.
#
#   When a read tie is in effect, it is still technically permissible to set the
#   Tcl variable. However, the changes have no effect so this is not
#   recommended.
#
#   The read tie supports one optional setting. If you specify "-initialize 1",
#   then Tcl will be initialized with the Yorick variable's current value. This
#   is useful if tying to a variable that is used in a GUI.
##
    array set opts [list -initialize 0 -src yor]
    array set opts $args
    if {$cmd ni {add remove append}} {
        error "Unknown command: $cmd"
    }
    if {[regexp {^(.*?)(?:\((.*)\))$} $tkvar - var key]} {
        set tkvar [uplevel [list namespace which -variable $var]]($key)
    } else {
        set tkvar [uplevel [list namespace which -variable $tkvar]]
    }
    switch -- $type {
        broadcast {
            if {$cmd ne "remove" && $opts(-initialize)} {
                __tky_tie_write $tkvar $yvar - - -
            }
            trace $cmd variable $tkvar write [list __tky_tie_write $tkvar $yvar]
        }
        sync {
            if {$cmd ne "remove" && $opts(-initialize)} {
                if {$opts(-src) eq "tcl"} {
                    __tky_tie_write $tkvar $yvar - - -
                } else {
                    __tky_tie_read $tkvar $yvar - - -
                }
            }
            trace $cmd variable $tkvar write [list __tky_tie_write $tkvar $yvar]
            trace $cmd variable $tkvar read [list __tky_tie_read $tkvar $yvar]
        }
        read {
            if {$cmd ne "remove" && $opts(-initialize)} {
                __tky_tie_read $tkvar $yvar - - -
            }
            trace $cmd variable $tkvar read [list __tky_tie_read $tkvar $yvar]
        }
        default {
            error "Unknown type $type"
        }
    }
    return
}

proc __tky_tie_write {tkvar yvar name1 name2 op} {
# Used by tky_tie
    ybkg var_expr_tkupdate \"$yvar\" \"[set $tkvar]\"
}

proc __tky_tie_read {tkvar yvar name1 name2 op} {
# Used by tky_tie
    set $tkvar [yget $yvar]
}

proc tky_set {varName val} {
# Used by ytk.i's tksetval.
    upvar $varName var

    if {[string match {"*"} $val]} {
        # Scalar string, need to eval to unescape newlines and lose quotes
        eval set var $val
    } elseif {[string match {\[*\]} $val]} {
        if {[string match *\"* $val]} {
            # Array of strings... cannot parse safely so we pass through
            set var $val
        } else {
            # Array of non-strings, easy to convert to a list
            set var [lindex [string map [list \[ \{ \] \} , " "] $val] 0]
        }
    } else {
        # Anything else either doesn't require special handling, or requires
        # special handling we cannot provide so we pass it through
        set var $val
    }
}

proc yorick_executable {} {
##
# yorick_executable
#   Attempts to determine the yorick executable file.
#
#   In order of priority, tries to use the following:
#       - value of _ytk(yorick_executable), if set (from .ytkrc)
#       - ../../bin/yorick
#       - ../../yorick/bin/yorick
#       - yorick in path (shell call to "which yorick")
#       - yorick provided by user when prompted for one
#       - empty string (which means Ytk will probably exit)
#
# Arguments:
#   None
#
# Returns:
#   A string representing the path+filename to the Yorick executable. If no
#   executable is available, an empty string is returned.
##
    set flag yes
    while {[auto_execok yorick] eq "" && $flag eq "yes"} {
        set flag [tk_messageBox -icon error -type yesno \
            -message "Ytk cannot locate Yorick, which it needs to function. Would you like to manually locate a Yorick? (If you answer no, Ytk will exit.)"]
        if { $flag eq "yes" } {
            set ::_ytk(yorick_executable) [tk_getOpenFile -initialdir /]
        }
    }
}

proc trace__ytk {name1 name2 op} {
# When entries are added to _ytk in the form NAME_executable, auto_execs is
# updated so that NAME returns the new value placed in _ytk.
    if {[string match "*_executable" $name2]} {
        set cmd [string range $name2 0 end-11]
        set ::auto_execs($cmd) $::_ytk($name2)
    } elseif {$name2 eq "executables_path"} {
        set pathsep [expr {$::tcl_platform(platform) eq "windows" ? ";" : ":"}]
        set path [split $::env(PATH) $pathsep]
        set path [lreplace $path 0 0 $::_ytk($name2)]
        set ::env(PATH) [join $path $pathsep]
    }
}

proc restore_defaults {} {
##
# restore_defaults
#   Restores default values to the _ytk global.
#
# Arguments:
#   None
#
# Returns:
#   Nothing
#
# Side effects:
#   Unsets the global _ytk, the defines it to a set of default values.
##
    global _ytk
    array unset _ytk *
    set _ytk(use_rlterm)                No
    set _ytk(use_rlwrap)                Yes
    set _ytk(separate_help_win) Yes
    set _ytk(ycode_dir)             .
    set _ytk(ytkcode_dir)           /opt/eaarl/lidar-processing/src/
    set _ytk(initialdir)                /data
    set _ytk(rlwrap_nodupes)        1
}

proc load_options {} {
##
# load_options
#   Loads the user's _ytk options from a file previously saved via save_options.
#
# Arguments:
#   None
#
# Returns:
#   Nothing
#
# Side effects:
#   Restores the default values for _ytk (as defined by restore_defaults). Then
#   sources ~/.ytkrc, which presumbly updates some of the _ytk values with the
#   user's preferences. However, the sourcing is not done safely so this could
#   have virtually any side effect.
##
    global _ytk

    # Restore defaults -- in case .ytkrc doesn't specify everything
    restore_defaults

    set ytkrc_paths [list /etc/ytkrc ~/.ytkrc .ytkrc]

    foreach rc $ytkrc_paths {
        if {[file exists $rc]} {
            puts "Loading ytk configuration file: $rc"
            set cnf [interp create -safe]
            if {[catch [list interp invokehidden $cnf source $rc] err]} {
                puts "Error encountered in configuration file: $err"
            } else {
                if {[interp eval $cnf array exists _ytk]} {
                    foreach key [interp eval $cnf array names _ytk] {
                        set _ytk($key) [interp eval $cnf set _ytk($key)]
                    }
                }
            }
            interp delete $cnf
        }
    }
}

proc establish_fifos {} {
##
# establish_fifos
#   Creates and configures the fifos needed for communication between Yorick and
#   Tcl (in both directions).
#
# Arguments:
#   None
#
# Returns:
#   Nothing
#
# Side effects:
#   Establishes the following global variables:
#       ytk_fifo_name: The filename of the Yorick->Tcl fifo.
#       tky_fifo_name: The filename of the Tcl->Yorick fifo.
#       ytk_fifo: The filehandle for the Yorick->Tcl fifo.
#       tky_fifo: The filehandle for the Tcl->Yorick fifo.
#   Also configures ytk_fifo to call ytk_fifo_fileevent for the readable
#   fileevent.
##
    global ytk_fifo_name tky_fifo_name ytk_fifo tky_fifo

    set fifos [::yorick::create_fifos]
    lassign $fifos ytk_fifo ytk_fifo_name tky_fifo tky_fifo_name

    fileevent $ytk_fifo readable ytk_fifo_fileevent
}

proc ytk_fifo_fileevent {} {
##
# ytk_fifo_filevent
#   Processes a command received on the Yorick->Tcl fifo. This is invoked by the
#   fileevent readable on $ytk_fifo.
#
# Arguments:
#   None
#
# Returns:
#   Nothing
#
# Side effects:
#   This will evaluate the first string found on the fifo $ytk_fifo. If .tx.doc
#   exists, it will be updated accordingly. If an error is encountered, the user
#   is notified via expect as well as on .tx.doc.
#
#   If there isn't a complete line available on the fifo, this does nothing.
##
    global ytk_fifo

    set ycmdstr [gets $ytk_fifo]

    # If a full line isn't available, gets will return ""
    if {[string length $ycmdstr]} {
        logger trace "Received background command: $ycmdstr"
        if {[catch {uplevel #0 $ycmdstr} errcode]} {
            logger error "Error in background command: $ycmdstr\n  $errcode"
            fifo_log tcl $ycmdstr $errcode
            send_user "*** Ytk Error in:$ycmdstr\n"
        } else {
            fifo_log tcl $ycmdstr
        }

        update idletasks
    }
}

proc fifo_log {src msg {err NULL}} {
##
# fifo_log
#   Processes a log message from one of the FIFOs.
#
# Arguments:
#   src: One of either 'tcl' or 'yor' indicating which pipe the message is
#       from.
#   msg: The message to log.
#   err: Optional. If present, this is an error that resulted from the invoked
#       command.
#
# Returns:
#   Nothing
#
# Side effects:
#   The message is appended to the contents of text widget in the .tx toplevel
#   window.
##
    global fifo_log_counter
    set text .tx.doc
    if {[winfo exists $text]} {
        incr fifo_log_counter($src)
        set now [clock seconds]
        $text ins end "[clock format $now -format %Y-%m-%d] " [list $src date]
        $text ins end "[clock format $now -format %T] " [list $src time]
        $text ins end "\[$src\] " [list $src src]
        $text ins end [format "%5d: " $fifo_log_counter($src)] [list $src counter]
        $text ins end "$msg\n" $src

        if {$err ne "NULL"} {
            $text ins end "  ERROR: $err\n" [list $src err]
        }

        $text yview moveto 1.0
        if {[$text index end] > 1100} {
            $text del 1.0 "end - 1001 lines"
        }
    }
}

proc spawn_yorick {} {
##
# spawn_yorick
#   Attempts to spawn Yorick. If rlterm or rlwrap are available on the system
#   path, they will be used if the user has enabled them (rlterm takes
#   precedence over rlwrap if both exist and are enabled).
#
# Arguments:
#   None
#
# Returns:
#   0 if the spawn succeeded; 1 if it did not.
#
# Side effects:
#   If successful, then expect does whatever it does when spawn works (including
#   setting various expect-related variables), in the global scope.
##
    global _ytk ytk_fifo_name tky_fifo_name

    set rlterm [expr {$_ytk(use_rlterm) eq "Yes"}]
    set rlwrap [expr {$_ytk(use_rlwrap) eq "Yes"}]
    set result [::yorick::spawn $ytk_fifo_name $tky_fifo_name \
            -rlwrap $rlwrap -rlterm $rlterm]

    if {$result ne ""} {
        # Make this expect session the default
        set ::spawn_id [lindex $result 0]
        array set ::spawn_out [lindex $result 1]

        # Configure with 32 KB buffer
        match_max -i $::spawn_id 32768

        return 0
    } else {
        return 1
    }
}

proc ytk_exit {code} {
##
# ytk_exit code
#   Exits Yorick with the given code after performing cleanup (which consists of
#   closing and deleting the fifos).
#
# Arguments:
#   code: A integer in the range 0-127, which will be returned as the exit code.
#
# Returns:
#   Nothing
#
# Side effects:
#   The fifos are closed and their corresponding files deleted. Then the
#   application terminates with the given exit $code.
##
    global ytk_fifo_name tky_fifo_name ytk_fifo tky_fifo
    foreach session [::yorick::session info instances] {
        $session destroy
    }
    ::yorick::destroy_fifos $ytk_fifo $ytk_fifo_name $tky_fifo $tky_fifo_name
    if {$code} {
        logger warn "Shutting down with code $code"
    } else {
        logger info "Exiting normally"
    }
    exit $code
}

proc source_ytk_file {filename} {
##
# source_ytk_file filename
#   Sources the file defined by $filename -- in Yorick if it's a .i file, in Tcl
#   if it's a .ytk, .tk, or .tcl file.
#
# Arguments:
#   None
#
# Returns:
#   Nothing
#
# Side effects:
#   The file is sourced (in either Yorick or Tcl), which could have any effect
#   depending on the code in question.
#
#   If the file is a .i file, then global ycode_dir is set to its containing
#   directory and both Tcl and Yorick have their working directory updated to
#   match it.
#
#   If the file is not a Yorck or Tcl file, an error will result.
##
    global ycode_dir
    switch [file extension $filename] {
        ".tcl" -
        ".tk" -
        ".ytk" {
            uplevel #0 [list source $filename]
        }
        ".i" {
            set ycode_dir [file dirname $filename]
            cd $ycode_dir
            ybkg cd \"$ycode_dir\"
            exp_send "#include \"$filename\"\r"
            expect "> "
        }
        default {
            logger error "source_ytk_file: don't know how to handle file $filename"
            error "don't know how to handle file"
        }
    }
}

proc select_ytk_fn {} {
##
# select_ytk_fn
#   Prompts the user to select a file to source, then sources it.
#
# Returns:
#   Nothing
#
# Side effects:
#   The file is sourced at the global scope, which could have any effect; see
#   source_ytk_file.
##
    set fn [tk_getOpenFile \
        -filetypes {
            {{Yorick Specfic Tcl/Tk Programs} {.ytk} }
            {{Yorick or Tcl/tk program} {.i .ytk}   }
            {{Yorick Programs} {.i}  }
            {{Tcl/Tk Programs} {.tcl .tk} }
            {{All Files}         {*}     }
        }]

    if {$fn ne ""} {
        source_ytk_file $fn
    }
}

proc start_yorick {}  {
##
# start_yorick
#   Starts the main Yorick loop. This primarily watches for DOCUMENT strings and
#   will catch them to display in GUI form if configured to do so.
#
# Arguments:
#   None
#
# Returns:
#   Nothing
#
# Side effects:
#   If configured to spawn documentation for Yorick via Tcl, this will watch
#   Yorick's output and attempt to intercept DOCUMENT statements. Otherwise, it
#   lets everything else pass through as-is.
#
#   In order to avoid hanging, this will only catch DOCUMENT statements that are
#   received within an interval of a single second.
##
    global _ytk interact_out str Y_SITE
    upvar spawn_id spawn_id
    set hwin 0
    expect ">"
    set ::state 0
    interact {
        -o
        # This should never conflict with the command line because the command
        # line always has the pattern "\n> " at the start. DOCUMENT statements
        # never start with >.
        -re {\n[[:blank:]]*/\*[[:blank:]]*DOCUMENT.*\n} {
            if {$_ytk(separate_help_win) eq "Yes"} {
                set help $interact_out(0,string)
                # If the help is short, the whole thing will already be stored
                # in help - in that case, skip the nested interact.
                if {![show_help $help]} {
                    interact {
                        -o
                        # Try to pick up the "defined at:" line to include in
                        # the help window, if possible
                        -re {.*\*/\s*defined at:[^\n]*\n} {
                            append help $interact_out(0,string)
                            show_help $help
                            return
                        }
                        # If no "defined at:" is present, try to absorb as much
                        # trailing whitespace as possible.
                        -re {.*\*/\s*} {
                            append help $interact_out(0,string)
                            show_help $help
                            return
                        }
                        # If the help is really long (or if it turns out this
                        # isn't actually a valid help block), append the
                        # current chunk to the working help string until we
                        # know what to do with it.
                        -re {.*} {
                            append help $interact_out(0,string)
                        }
                        # If a whole second passes since the opening
                        # "/* DOCUMENT" then assume this isn't a valid help
                        # block so that the user's session does not block.
                        timeout 1 {
                            exp_send_user $help
                            return
                        }
                    }
                }
            } else {
                exp_send_user $interact_out(0,string)
            }
        }
        # Help outputs almost instantly, so abort on any delays.
        timeout 1 {}
    }
}

proc show_help {raw} {
##
# show_help
#   Helper proc for start_yorick. It checks to make sure $raw contains a valid
#   DOCUMENT block and pops open a help window for it if it does. Returns 1 if
#   DOCUMENT found, 0 otherwise.
##
    set doc_pattern {^(.*?)([^\n]*/\*[[:blank:]]*DOCUMENT.*\*/(?:\s*\n)?)(.*)$}
    if {![regexp $doc_pattern $raw - pre help post]} {
        return 0
    }
    exp_send_user $pre

    set def_pattern {^\s*defined at:[^\n]*\n}
    if {[regexp $def_pattern $post def]} {
        append help $def
    }
    exp_send_user $post

    regsub -all \r $help "" help

    set i 0
    while {[winfo exists [set top .docwin$i]]} {incr i}

    toplevel $top -class DOCUMENT
    set wintitle [lindex [split $help "\n"] 0]
    set wintitle [regsub -nocase {^ */\* *DOCU} $wintitle DOCU]
    wm title $top $wintitle

    ttk::scrollbar $top.sb -command [list $top.doc yview]
    ::mixin::text::readonly $top.doc -height 25 \
            -yscrollcommand [list $top.sb set]
    $top.doc ins end $help
    pack $top.doc -side left -fill both -expand 1
    pack $top.sb -side left -fill y -expand 0

    return 1
}

proc launch_gui {} {
##
# launch_gui
#   Sets up the core GUI for Ytk.
#
# Arguments:
#   None
#
# Returns:
#   Nothing
##
    global Y_SITE _ytk yorick_version tk_patchLevel

    toplevel .tx
    wm withdraw .tx
    wm title .tx "Background Command History"
    wm protocol .tx WM_DELETE_WINDOW [list wm withdraw .tx]

    ttk::scrollbar .tx.sb -command [list .tx.doc yview] -orient vertical
    ::mixin::text::readonly .tx.doc -width 100 -height 40 \
            -yscrollcommand [list .tx.sb set] \
            -wrap word

    set f [ttk::frame .tx.f]
    ttk::label $f.display -text "Display:"
    ::mixin::combobox $f.src -text "Tcl + Yor" -width 9 \
            -state readonly \
            -values [list "Tcl + Yor" Tcl Yor] \
            -modifycmd {
                switch -- [%W getvalue] {
                    0 {
                        .tx.doc tag configure yor -elide {}
                        .tx.doc tag configure tcl -elide {}
                        .tx.doc tag configure src -elide {}
                    }
                    1 {
                        .tx.doc tag configure yor -elide 1
                        .tx.doc tag configure tcl -elide {}
                        .tx.doc tag configure src -elide 1
                    }
                    2 {
                        .tx.doc tag configure yor -elide {}
                        .tx.doc tag configure tcl -elide 1
                        .tx.doc tag configure src -elide 1
                    }
                }
            }

    ttk::label $f.wraplbl -text "Wrap:"
    ::mixin::combobox $f.wrap -text "word" -width 5 \
            -state readonly \
            -values [list none char word] \
            -modifycmd {
                switch -- [%W getvalue] {
                    0 {.tx.doc configure -wrap none}
                    1 {.tx.doc configure -wrap char}
                    2 {.tx.doc configure -wrap word}
                }
            }

    set ::fifo_log_conf(date) {}
    set ::fifo_log_conf(time) {}
    set ::fifo_log_conf(counter) {}

    ttk::checkbutton $f.date -text "Date" \
            -variable ::fifo_log_conf(date) \
            -onvalue {} -offvalue 1 \
            -command {
                .tx.doc tag configure date -elide $::fifo_log_conf(date)
            }

    ttk::checkbutton $f.time -text "Time" \
            -variable ::fifo_log_conf(time) \
            -onvalue {} -offvalue 1 \
            -command {
                .tx.doc tag configure time -elide $::fifo_log_conf(time)
            }

    ttk::checkbutton $f.counter -text "Sequence" \
            -variable ::fifo_log_conf(counter) \
            -onvalue {} -offvalue 1 \
            -command {
                .tx.doc tag configure counter -elide $::fifo_log_conf(counter)
            }
    pack $f.display $f.src $f.date $f.time $f.counter \
            -in $f -side left -padx 2 -pady 2
    pack $f.wrap $f.wraplbl \
            -in $f -side right -padx 2 -pady 2

    grid .tx.doc .tx.sb -sticky news
    grid .tx.f - -sticky ew
    grid columnconfigure .tx 0 -weight 1
    grid rowconfigure .tx 0 -weight 1

    .tx.doc tag configure yor -foreground "#00008B" \
            -lmargin2 40
    .tx.doc tag configure tcl -foreground "#006400" \
            -lmargin2 40
    .tx.doc tag configure err -background "#FF0"
}

proc init_hgid {} {
    global HGID
    set hg [auto_execok hg]
    if {$hg ne ""} {
        set HGID [exec {*}$hg identify [file dirname [app_root_dir]]]
    } else {
        set HGID "--"
    }
}

proc bgerror {msg} {
    logger warn "background error: $msg"
}

######## END PROCEDURES ########

logger debug "Started YTK as: $argv0 $argv"
logger debug "info library: [info library]"
logger debug "info nameofexecutable [info nameofexecutable]"
logger debug "info script: [info script]"
logger debug "info patchlevel: [info patchlevel]"

trace add variable _ytk write trace__ytk
restore_defaults        ;# begin with the default settings
load_options
init_hgid

############################################################
# Stuff below here doesn't need to be changed if you are
# just porting to another system.
############################################################

set env(GISTPATH) [file join [pwd] gist]

yorick_executable
if {[auto_execok yorick] eq ""} {
    puts stderr "No yorick found, aborting..."
    ytk_exit 2
}

establish_fifos

puts " Tcl [info patchlevel], Tk $tk_patchLevel, Expect [exp_version] ready."
if {[spawn_yorick]} {
    puts "Encountered problem starting yorick... please restart with a different yorick"
    ytk_exit 3
}

expect "Yorick * ready"
set yorick_version [lindex [split $expect_out(0,string)] 1]

logger debug "Yorick executable: [auto_execok yorick]"
logger debug "Yorick version: $yorick_version"

wm withdraw .
wm protocol . WM_DELETE_WINDOW [list wm withdraw .]
launch_gui

ybkg funcset initialdir \"$_ytk(initialdir)\"
ybkg funcset _ytk 1
ybkg funcset _pid [pid]
ybkg funcset _hgid \"$HGID\"
ybkg funcset _starttime $_starttime
ybkg funcset _user $tcl_platform(user)

set src_path [file dirname [file normalize [info script]]]
ybkg funcset src_path \"$src_path\"

foreach file_to_load $load_on_start {
    logger info "Loading on startup: $file_to_load"
    source_ytk_file $file_to_load
}

start_yorick

ytk_exit 0
