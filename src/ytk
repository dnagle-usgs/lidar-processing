#!/bin/sh
# \
exec wish "$0" ${1+"$@"}

# /* vim: set tabstop=3 softtabstop=3 shiftwidth=3 shiftround autoindent expandtab syntax=tcl: */

# Program to add some limited tcl/Tk GUI capability to Yorick programs.
#
# Original - C. W. Wright wwright@usgs.gov
#
# This program is copyrighted under the terms of
# The GNU GENERAL PUBLIC LICENSE,  Version 2, June 1991.
# A full copy can be found at: http://www.gnu.org/licenses/gpl.txt
#
# The main site for this program is:
#     http://ytk.sourceforge.net
# *** NOTE: The newer version at ytk.sourceforge.net isn't compatible
# with ytk (yet) so don't try using it.
#
# This version of Ytk is a fork from the version found at SourceForge,
# tailored for ALPS.
#
# Revision history
#
# 11/12/2008 - David Nagle
#  * Refactored most of the code into procs
#  * Simplified and reduced repetitive chunks of code
#  * Implemented a -nogui option that suppresses the YTK GUI menubar
#  * Implemented a -gui option that forces the display of the YTK GUI menubar
#    (it shows by default; however, "./ytk -nogui -gui" results in -gui
#    overriding -nogui)
#  * The logic for finding the yorick executable has been cleaned up and improved.
#  * Removed large sections of commented-out code that was obsolete. Also
#    removed some left over code relics that were no longer in use.
#  * Removed a bunch of disabled menu entries that had no functionality
#    supplied under Graph -> Plot. I left a note in the comments indicating
#    what was removed, with a "TODO" note suggesting that they get added back
#    later once code has been written to implement them.
#  * Improved robustness in the spawning process slightly. If spawning via
#    rlterm is requested but fails, it will move on to try using rlwrap (if
#    enabled), and then on to spawning yorick without any wrappers.
#  * Updated the comments up above to indicate that this version of "ytk" has
#    diverged from the version found at Sourceforge.
#
# 06/02/2005 - Amar Nayegandhi
#  Added option to use rlwrap or rlterm with yorick. Default setting uses
#  rlwrap. Download rlwrap from: http://www.maumae.net/yorick/rlwrap-0.18.tar.gz
#
# 5/31/2003 Added runline commands.  Now you can say:  ytk somefile.[ytk,i,tcl,tk]
# 1/3/2002
#  -> Added  extended help for menu items.
#  -> Moved fifos to users home dir and use a unique name so several
#     Ytks can run at once.
#  -) Added "Save Options" button in Edit pulldown.
#  -) Added .ytkrc default file in users home dir.
#  -) Changed many variables to be elements of the _ytk array so
#     they can easily be saved/restored in .ytkrc
#
#   1/2/2002 ww *) Moved fifos to user's home dir and added some "uniqueness"
#                  to the name to avoid problems when two or more ytks are running.
# 12/31/2001 ww *) Minor changes to gracefully fail if ytk can't find Yorick.
#               *) Added code to look for yorick and rlterm and use what it
#                  finds if it can't use what the user provided.
# 12/28/2001 ww Added some simple most recent file selection stuff
# 12/21/2001 ww Added /tmp/ytk fifo for passing data back from yorick
#               to tcl/tk.  Also added /tmp/tky for sending stuff from
#               tcl/tk to Yorick in cases where you want/need to avoid
#               using the exp_send command.

# Exit codes
# 0 - Program ended normally
# 1 - Problem encountered with one of the files passed to load on the command line
# 2 - No Yorick found
# 3 - Problem encountered while spawning Yorick

package require BWidget
package require Expect
package require Iwidgets
package require fileutil
package require log
package require struct::list

################################################################################
#                        Iwidgets Combobox Improvements                        #
################################################################################
# The Iwidgets combobox provides a lot of nice benefits but has a cosmetic and
# usability flaws. This section attempts to address a few of those flaws. It's
# included here because these changes must happen before the combobox is used
# anywhere.

# Create a combobox widget and keep it around permanently for two reasons:
#  * Forces the autoloading of the combobox code, so that we can then overwrite
#    parts of it.
#  * The uparrow/downarrow images are destroyed when all instances of the
#    combobox widget are destroyed. Thus in order to replace the images, we
#    must keep at least one alive at all times.
::iwidgets::combobox .__iwcbo__donotdestroy

# The default arrow images are 16x16. These slimmer versions take up less
# space.
image delete uparrow
image create bitmap uparrow -data {
   #define uparrow_width 10
   #define uparrow_height 16
   static unsigned char uparrow_bits[] = {
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x38, 0x00,
      0x7c, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
}
image delete downarrow
image create bitmap downarrow -data {
   #define downarrow_width 10
   #define downarrow_height 16
   static unsigned char downarrow_bits[] = {
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xfc, 0x01, 0xf8, 0x00, 0x70, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
}

# The default background color for the entry field is a different color than
# everything else. This overrides it to match.
proc ::iwidgets::combobox {pathName args} {
   uplevel ::iwidgets::Combobox $pathName $args
   $pathName component entry configure -readonlybackground \
      [$pathName cget -background]
   return $pathName
}

# Updating the resizing method to reflect the arrows' new sizes.
itcl::body iwidgets::Combobox::_resizeArrow {} {
   # Overriding arrows to display similar to Bwidgets
   set bw [expr {[$itk_component(arrowBtn) cget -borderwidth]+ \
      [$itk_component(arrowBtn) cget -highlightthickness]}]
   set newHeight [expr {[winfo reqheight $itk_component(entry)]-(2*$bw) - 2}]
   set newWidth [expr {int($newHeight * 10 / 16)}]
   $itk_component(arrowBtn) configure -width $newWidth -height $newHeight
   _drawArrow
}

# Adding a binding to the dropdown bindings to allow the user to click on the
# entry to post the list. Sine we always(?) use the combobox dropdown with the
# entry as read-only, this should be safe.
#
# Rather than completely reproduce the body, use introspection to pull it out
# and simply append our one additional binding.
set __tmp__body [.__iwcbo__donotdestroy info body _dropdownBindings]
append __tmp__body {
   # Allow user to click on entry list to pop open list
   bind $itk_component(entry) <ButtonRelease-1> [itcl::code $this _toggleList]
}
itcl::body iwidgets::Combobox::_dropdownBindings {} $__tmp__body
unset __tmp__body
################################################################################

wm withdraw .

set gui_enabled 1
if { ![catch {package require cmdline}] } {
   set ytk_cmdline_options {
      {gui     "force ytk gui to load"}
      {nogui   "disable ytk gui"}
   }
   set usage ": ytk \[options] \[filename]\n:options:"
   array set params [::cmdline::getoptions argv $ytk_cmdline_options $usage]
   if { $params(nogui) } {
      set gui_enabled 0
   }
   if { $params(gui) } {
      set gui_enabled 1
   }
}

set load_on_start ""
if { $argc != 0 } {
  set load_on_start $argv
}

set ycode_dir "."
set ytkcode_dir "."
set Y_SITE ""

################################################################################
#                                  Procedures                                  #
################################################################################

proc docstring {procname} {
# Reports a proc's args and leading comments.
# Multiple documentation lines are allowed.
   set res "{usage: $procname [uplevel 1 [list args $procname]]}"
   foreach line [split [uplevel 1 [list info body $procname]] \n] {
      set line [string trim $line]
      if {$line eq ""} continue
      if {[string index $line 0] ne "#"} break
      lappend res [string trimleft $line "#"]
   }
   join $res \n
}

proc args {procname} {
# Signature of a proc: arguments with defaults
   set res ""
   foreach a [info args $procname] {
      if [info default $procname $a default] {
         lappend a $default
      }
      lappend res $a
   }
   set res
}

proc ystr {val {quoted 1}} {
##
# ystr val [quoted]
#  Sanitizes a string so that it can be safely sent to Yorick. Things like
#  quotes, newlines, and tabs will be escaped.
#
# Arguments:
#  val - The string to sanitize
#  quoted - Optional. By default, the returned string will be surrounded in
#     quotes. Set this to 0 to omit the quotes.
#
# Returns:
#  A sanitized string suitable for Yorick.
#
# Side effects:
#  None
##
   set yval [string map [list \
      \\ \\\\  \
      \" \\\"  \
      \n \\n   \
      \b \\b   \
      \f \\f   \
      \r \\r   \
      \t \\t   \
   ] $val]
   if {$quoted} {
      set yval "\"$yval\""
   }
   return $yval
}

proc string_to_hex input {
# Converts input, which can be any arbitrar string of data, into hexadecimal
# format. This is a simple form of ASCII-armoring and is used by ybkg to
# protect newlines and other potentially troublesome characters.
   join [::struct::list mapfor c [split $input {}] {format %02x [scan $c %c]}] ""
}

# From http://wiki.tcl.tk/727
proc intgen {{seed 0}} {
   set self [lindex [info level 0] 0]
   proc $self "{seed [incr seed]}" [info body $self]
   set seed
}

proc sleep {{ms 200}} {
   set sleepvar "::__sleep_var_[intgen]__"
   after $ms [list set $sleepvar 0]
   vwait $sleepvar
   unset $sleepvar
}

set __ybkg__wait 0
proc ybkg args {
##
# ybkg args
#  Sends a command to Yorick in the background. This does NOT accept normal
#  Yorick commands!! You must format them in a format acceptable to funcdef. In
#  Yorick, use 'help, funcdef' for more information.
#
#  Some examples:
#
#     ybkg write 1 2 3
#        -- Corresponds to: write, 1, 2, 3
#
#     ybkg write \"Hello, world!\"
#        -- Corresponds to: write, "Hello, world!"
#
#     ybkg write {"Hello, world!"}
#        -- Corresponds to: write, "Hello, world!"
#
#     ybkg {write "Hello, world!"}
#        -- Corresponds to: write, "Hello, world!"
#
#     ybkg funcset foo 10
#        -- Corresponds to: funcset, foo, 10
#           which corresponds to: foo = 10
#
#  Please be aware that you will NOT receive any notifications in the case of
#  errors! They will be silently ignored.
#
#  Also, do not use ystr with this. The input for funcdef does not require as
#  many escapes.
#
#  Also, do not send any input that includes newlines. It just doesn't work
#  yet.
##
   set cmd [eval concat $args]
   set ::__ybkg__wait 1
   logger debug "Sending background command to Yorick: $cmd"
   set cmd [string_to_hex $cmd]
   puts $::tky_fifo "bkg $cmd"
   while {$::__ybkg__wait} {sleep 1}
}

proc yget yvar {
##
# set val [yget yvar]
#  This retrieves the value of a yorick variable yvar.
##
   set wait_var ::__yvar_tmp_[intgen]__
   set cancel [after 1000 [list set $wait_var {}]]
   after 0 [list after idle [list ybkg tksetvar \"$wait_var\" \"$yvar\"]]
   vwait $wait_var
   after cancel $cancel
   set result [set $wait_var]
   unset $wait_var
   return $result
}


proc ycmd {command {params {}} {options {}}} {
##
# ycmd command params options
#  Sends a command to Yorick. This is meant to simplify sending straightforward
#  commands to Yorick, rather than having to manually construct the command and
#  send/expect it.
#
# Arguments:
#  command - The command to execute.
#  params - The positional parameters to use. Should be a list. Optional.
#  options - The keyword arguments to use. Should be a dict. Optional.
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   set ycommand $command
   foreach param $params {
      append ycommand ", $param"
   }
   dict for {key val} $options {
      append ycommand ", $key=$val"
   }
   append ycommand ";\r"
   exp_send $ycommand
   expect ">"
}

proc yset {var command {params {}} {options {}}} {
##
# yset var = val
# yset var command params options
#  Sends a command to Yorick that sets a variable. This is meant to simplify
#  sending straightforward assignments to Yorick, rather than having to
#  manually contruct the command and send/expect it.
#
#  The first form is used to set a variable to a known value -- either a
#  constant or another Yorick variable. The equal sign is mandatory.
#
#  The second form is used to set a variable to the result of a function call.
#
# Arguments, first form:
#  var - The Yorick variable that is being assigned.
#  val - The value to assign to the variable.
#
# Arguments, second form:
#  var - The Yorick variable that is being assigned.
#  command - The command to execute.
#  params - The positional parameters to use. Should be a list. Optional.
#  options - The keyword arguments to use. Should be a dict. Optional.
##
   if {$command eq "="} {
      exp_send "$var = $params;\r"
      expect ">"
   } else {
      set ycommand "$var = $command\("
      dict for {key val} $options {
         lappend params "$key=$val"
      }
      append ycommand [join $params ", "]
      append ycommand ");\r"
      exp_send $ycommand
      expect ">"
   }
}

proc tky_tie {cmd type tkvar - yvar args} {
##
# Subcommands:
#     tky_tie add broadcast tkvarName to yvarName [-initialize 1]
#     tky_tie add sync tkvarName with yvarName [-initialize 1 -src tcl]
#     tky_tie add read tkvarName from yvarName [-initialize 1]
#     tky_tie remove broadcast tkvarName to yvarName
#     tky_tie remove sync tkvarName with yvarName
#     tky_tie remove read tkvarName from yvarName
#
# This adds or removes a tie between a Tcl variable and a Yorick variable.
# There are two kinds of ties: broadcast and sync.
#
# broadcast
#  With a broadcast tie, the Tcl variable will broadcast its value to Yorick
#  whenever it gets set. However, Yorick will still remain free to change this
#  value at will in between broadcasts. The broadcast only happens when the
#  variable is set. You can force a new broadcast by doing this:
#     set tkVar [set $tkVar]
#
#  The broadcast tie supports one optional setting. If you specify "-initialize
#  1", then Yorick will be initialized with the Tcl variable's current value.
#  Without this option, Yorick doesn't get update until the variable is
#  assigned to next.
#
# sync
#  With a sync tie, Tcl does its best to keep the same value in both Yorick and
#  Tcl. When Tcl sets the variable to a new value, that value is broadcast to
#  Yorick. When Tcl needs to retrieve the variable's value, it asks Yorick what
#  the current value is. Thus, the Tcl variable effectively becomes an alias
#  for the Yorick variable.
#
#  One major caveat: Changing the Yorick variable will not immediately provoke
#  a change in the Tcl variable. For example, if you are using the Tcl variable
#  in a GUI, the GUI will not immediately update. It won't update until Tcl
#  next references that variable explicitly in some fashion.
#
#  You can force a sync by doing this:
#     set tkVar
#
#  The sync tie supports two optional settings. If you specify "-initailize 1",
#  then Yorick will be initialized with the Tcl variable's current value. If
#  you additionally specify -src tcl, then the reverse will happen: Tcl will be
#  initialized with the Yorick variable's current value.
#
# read
#  With a read tie, the Tcl variable will ask Yorick for its value whenever it
#  is acccessed. As with sync, this only occurs when the variable is explicitly
#  checked.
#
#  When a read tie is in effect, it is still technically permissible to set the
#  Tcl variable. However, the changes have no effect so this is not
#  recommended.
#
#  The read tie supports one optional setting. If you specify "-initialize 1",
#  then Tcl will be initialized with the Yorick variable's current value. This
#  is useful if tying to a variable that is used in a GUI.
##
   array set opts $args
   switch -- $cmd {
      add - remove {}
      append {
         if {![string length [info procs trace_append]]} {
            error "Unknown command: $cmd"
         }
      }
      default {
         error "Unknown command: $cmd"
      }
   }
   if {[regexp {^(.*?)(?:\((.*)\))$} $tkvar - var key]} {
      set tkvar [uplevel [list namespace which -variable $var]]($key)
   } else {
      set tkvar [uplevel [list namespace which -variable $tkvar]]
   }
   switch -- $type {
      broadcast {
         if {$cmd ne "remove" && $opts(-initialize)} {
            __tky_tie_write $tkvar $yvar - - -
         }
         if {$cmd eq "append"} {
            trace_append variable $tkvar write [list __tky_tie_write $tkvar $yvar]
         } else {
            trace $cmd variable $tkvar write [list __tky_tie_write $tkvar $yvar]
         }
      }
      sync {
         if {$cmd ne "remove" && $opts(-initialize)} {
            if {$opts(-src) eq "tcl"} {
               __tky_tie_write $tkvar $yvar - - -
            } else {
               __tky_tie_read $tkvar $yvar - - -
            }
         }
         if {$cmd eq "append"} {
            trace_append variable $tkvar write [list __tky_tie_write $tkvar $yvar]
            trace_append variable $tkvar read [list __tky_tie_read $tkvar $yvar]
         } else {
            trace $cmd variable $tkvar write [list __tky_tie_write $tkvar $yvar]
            trace $cmd variable $tkvar read [list __tky_tie_read $tkvar $yvar]
         }
      }
      read {
         if {$cmd ne "remove" && $opts(-initialize)} {
            __tky_tie_read $tkvar $yvar - - -
         }
         if {$cmd eq "append"} {
            trace_append variable $tkvar read [list __tky_tie_read $tkvar $yvar]
         } else {
            trace $cmd variable $tkvar read [list __tky_tie_read $tkvar $yvar]
         }
      }
      default {
         error "Unknown type $type"
      }
   }
   return
}

proc __tky_tie_write {tkvar yvar name1 name2 op} {
# Used by tky_tie
   ybkg var_expr_tkupdate \"$yvar\" \"[set $tkvar]\"
}

proc __tky_tie_read {tkvar yvar name1 name2 op} {
# Used by tky_tie
   set $tkvar [yget $yvar]
}

proc tky_set {varName val} {
# Used by ytk.i's tksetval.
   upvar $varName var

   if {[string match {"*"} $val]} {
      # Scalar string, need to eval to unescape newlines and lose quotes
      eval set var $val
   } elseif {[string match {\[*\]} $val]} {
      if {[string match *\"* $val]} {
         # Array of strings... cannot parse safely so we pass through
         set var $val
      } else {
         # Array of non-strings, easy to convert to a list
         set var [lindex [string map [list \[ \{ \] \} , " "] $val] 0]
      }
   } else {
      # Anything else either doesn't require special handling, or requires
      # special handling we cannot provide so we pass it through
      set var $val
   }
}

proc y_messageBox {message type title} {
##
# y_messageBox message type title
#  Displays a messagebox, waits for the user to click a button, then returns
#  their response to Yorick. This is used by tk_messageBox in Yorick.
#
#  The primary reason for using this over the native tk_messageBox is to ensure
#  that the dialog is visible to the user. The normal tk_messageBox does not
#  raise above other windows, which means it's often not seen right away.
#
# Arguments:
#  message - A string to show in the box.
#  type - The type of message box, identical to tk_messageBox -type options.
#  title - The title for the message box window.
##
   set dlg [iwidgets::messagedialog .#auto -title $title \
      -modality application -text $message]

   switch -- $type {
      abortretryignore {
         $dlg buttonconfigure 0 \
            -text "Abort" -command [list $dlg deactivate abort]
         $dlg buttonconfigure 1 \
            -text "Retry" -command [list $dlg deactivate retry]
         $dlg buttonconfigure 2 \
            -text "Ignore" -command [list $dlg deactivate ignore]
         $dlg hide 3
      }
      ok {
         $dlg buttonconfigure 0 \
            -text "OK" -command [list $dlg deactivate ok]
         $dlg hide 1
         $dlg hide 2
         $dlg hide 3
      }
      okcancel {
         $dlg buttonconfigure 0 \
            -text "OK" -command [list $dlg deactivate ok]
         $dlg buttonconfigure 1 \
            -text "Cancel" -command [list $dlg deactivate cancel]
         $dlg hide 2
         $dlg hide 3
      }
      retrycancel {
         $dlg buttonconfigure 0 \
            -text "Retry" -command [list $dlg deactivate retry]
         $dlg buttonconfigure 1 \
            -text "Cancel" -command [list $dlg deactivate cancel]
         $dlg hide 2
         $dlg hide 3
      }
      yesno {
         $dlg buttonconfigure 0 \
            -text "Yes" -command [list $dlg deactivate yes]
         $dlg buttonconfigure 1 \
            -text "No" -command [list $dlg deactivate no]
         $dlg hide 2
         $dlg hide 3
      }
      yesnocancel {
         $dlg buttonconfigure 0 \
            -text "Yes" -command [list $dlg deactivate yes]
         $dlg buttonconfigure 1 \
            -text "No" -command [list $dlg deactivate no]
         $dlg buttonconfigure 2 \
            -text "Cancel" -command [list $dlg deactivate cancel]
         $dlg hide 3
      }
   }

   $dlg center
   after 1 raise $dlg
   exp_send "[$dlg activate]\r"
}

proc yorick_executable {} {
##
# yorick_executable
#  Attempts to determine the yorick executable file. It will use the following,
#  in order of priority:
#     1. The value of _ytk(yorick_executable), if it exists and is a file.
#     2. The result of the system call 'which yorick'.
#     3. A user supplied value (acquired through a GUI prompt).
#
# Arguments:
#  None
#
# Returns:
#  A string representing the path+filename to the Yorick executable. If no
#  executable is available, an empty string is returned.
#
# Side effects:
#  None
##
   global _ytk
   set yor_ex ""
   # See if we can determine a Yorick from the system
   catch {set yor_ex [exec which yorick]}
   # See if we have a user-configured Yorick; if so, this takes precedence
   if {
      [info exists _ytk(yorick_executable)]
      && [file isfile $_ytk(yorick_executable)]
   } {
      set yor_ex $_ytk(yorick_executable)
   }
   set flag yes
   # If we do not have a valid Yorick, query the user for one until they give
   # us one or give up.
   while { ![file exists $yor_ex] && $flag eq "yes" } {
      set flag [tk_messageBox -icon error -type yesno \
         -message "Ytk cannot locate Yorick, which it needs to function. Would you like to manually locate a Yorick? (If you answer no, Ytk will exit.)"]
      if { $flag eq "yes" } {
         set $yor_ex [tk_getOpenFile -initialdir /]
      }
   }
   return $yor_ex
}

proc restore_defaults {} {
##
# restore_defaults
#  Restores default values to the _ytk global.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Unsets the global _ytk, the defines it to a set of default values.
##
   global _ytk
   array unset _ytk *
   set _ytk(yorick_executable)   [yorick_executable]
   set _ytk(editor)              vim
   set _ytk(use_rlterm)          No
   set _ytk(use_rlwrap)          Yes
   set _ytk(separate_help_win)   Yes
   set _ytk(plot_dpi)            75
   set _ytk(plot_style)          work
   set _ytk(plot_palette)        earth
   set _ytk(ycode_dir)           .
   set _ytk(ytkcode_dir)         /opt/eaarl/lidar-processing/src/
   set _ytk(plmk_default_color)  black
   set _ytk(plmk_default_msize)  0.2
   set _ytk(plmk_default_width)  0.5
   set _ytk(annoying_help)       No
   set _ytk(log_file)            ""
   set _ytk(log_level)           info
   set _ytk(initialdir)          /data/0
   set _ytk(rlwrap_nodupes)      1
}

proc save_options {} {
##
# save_options
#  Saves the user's _ytk options to a file for later retrieval.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Creates the file ~/.ytkrc and stores the contents of global _ytk to it.
#  Afterwards, the user will receive a GUI messagebox indicating whether it
#  succeeded or not.
##
   global _ytk
   set fn "~/.ytkrc"
   if { [catch {set f [open $fn "w+"]} err] } {
      tk_messageBox -icon error -message $err -type ok
   } else {
      foreach x [array names _ytk] {
         puts $f [format "set %32s    %-32s"  "_ytk($x)" $_ytk($x)]
      }
      close $f
      tk_messageBox -icon info -message "Options saved to: $fn" -type ok
   }
}

proc load_options {} {
##
# load_options
#  Loads the user's _ytk options from a file previously saved via save_options.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Restores the default values for _ytk (as defined by restore_defaults). Then
#  sources ~/.ytkrc, which presumbly updates some of the _ytk values with the
#  user's preferences. However, the sourcing is not done safely so this could
#  have virtually any side effect.
##
   global _ytk

   # Restore defaults -- in case .ytkrc doesn't specify everything
   restore_defaults

   set ytkrc_paths [list /etc/ytkrc ~/.ytkrc .ytkrc]

   foreach rc $ytkrc_paths {
      if {[file exists $rc]} {
         puts "Loading ytk configuration file: $rc"
         set cnf [interp create -safe]
         if {[catch [list interp invokehidden $cnf source $rc] err]} {
            puts "Error encountered in configuration file: $err"
         } else {
            if {[interp eval $cnf array exists _ytk]} {
               foreach key [interp eval $cnf array names _ytk] {
                  set _ytk($key) [interp eval $cnf set _ytk($key)]
               }
            }
         }
         interp delete $cnf
      }
   }
}

proc initialize_globals {} {
##
# initialize_globals
#  Initializes the values of global variables that are not initialized
#  elsewhere:
#     ytk_PLMK_marker: A constant array matching marker names to numbers.
#     markers: A constant list of marker names.
#     _ytk_mrl: The most recently used file list.
#     _ytk_mrl_idx: The current index into _ytk_mrl.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Sets the values for the globals ytk_PLMK_marker and markers.
##
   global ytk_PLMK_marker markers _ytk_mrl_idx _ytk_mrl

   set _markers [list \
      None Square Cross Triangle Circle Diamond Cross45 Inverted-Triangle]
   for {set i 0} {$i < 8} {incr i} {
      set ytk_PLMK_marker([lindex $_markers $i]) $i
   }
   set markers "square cross triangle circle diamond cross45 inverted_triangle"

   set _ytk_mrl_idx 1
   for { set i 1 } { $i <= 8 } { incr i } {
      set _ytk_mrl($i) ""
   }
}

proc establish_fifos {} {
##
# establish_fifos
#  Creates and configures the fifos needed for communication between Yorick and
#  Tcl (in both directions).
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Establishes the following global variables:
#     ytk_fifo_name: The filename of the Yorick->Tcl fifo.
#     tky_fifo_name: The filename of the Tcl->Yorick fifo.
#     ytk_fifo: The filehandle for the Yorick->Tcl fifo.
#     tky_fifo: The filehandle for the Tcl->Yorick fifo.
#     tkcmd_line: Set to 0.
#  Also configures ytk_fifo to call ytk_fifo_fileevent for the readable
#  fileevent.
##
   global ytk_fifo_name tky_fifo_name tkcmd_line ytk_fifo tky_fifo

   set tkcmd_line 0

   # Establish fifo for communications, Yorick ---> tcl/tk
   set ytk_fifo_name "/tmp/ytkfifo.[pid]"
   set ytk_fifo [create_fifo $ytk_fifo_name]

   # Establish fifo for communications, tcl/tk ---> Yorick
   set tky_fifo_name "/tmp/tkyfifo.[pid]"
   set tky_fifo [create_fifo $tky_fifo_name]

   fileevent $ytk_fifo readable ytk_fifo_fileevent
}

proc create_fifo {fifo_file} {
##
# create_fifo fifo_file
#  Creates a fifo using the filename specified, opens it, and returns its
#  filehandle.
#
# Arguments:
#  fifo_file: A string indicating the path and filename to use for the fifo.
#
# Returns:
#  The filehandle for the open fifo.
#
# Side effects:
#  The fifo is created and opened, but otherwise none.
##
   if {![file exists $fifo_file]} {
      exec mkfifo -m uog+rw "$fifo_file"
   }
   set fifo [open $fifo_file "r+"]
   fconfigure $fifo -buffering line -blocking 0
   return $fifo
}

proc ytk_fifo_fileevent {} {
##
# ytk_fifo_filevent
#  Processes a command received on the Yorick->Tcl fifo. This is invoked by the
#  fileevent readable on $ytk_fifo.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  This will evaluate the first string found on the fifo $ytk_fifo. If .tx.doc
#  exists, it will be updated accordingly. If an error is encountered, the user
#  is notified via expect as well as on .tx.doc.
#
#  If there isn't a complete line available on the fifo, this does nothing.
##
   global tkcmd_line ytk_fifo

   set ycmdstr [gets $ytk_fifo]

   # If a full line isn't available, gets will return ""
   if {[string length $ycmdstr]} {
      incr tkcmd_line
      tx_doc "$tkcmd_line:$ycmdstr\n"

      if { [catch { uplevel #0 $ycmdstr } errcode] } {
         send_user "*** Ytk Error in:$ycmdstr\n"
         tx_doc "**ERROR:  $errcode\n"
      }

      # Disabling this update for now, as it shouldn't be necessary and because
      # update is often a source of bugs.
      update idletasks
   }
}

proc tx_doc {message} {
##
# tx_doc message
#  Updates .tx.doc with the given message. If .tx.doc does not exist, this is a
#  no-op.
#
# Arguments:
#  A list that comprises valid arguments to .tx.doc.
#
# Returns:
#  Nothing
#
# Side effects:
#  Inserts $message at the end of .tx.doc; scrolls to the bottom; and deletes
#  all but the last 100 lines.
##
   if {[winfo exists .tx.doc]} {
      .tx.doc insert end $message
      .tx.doc yview moveto 1.0
      .tx.doc delete 1.0 "end - 100 lines"
   }
}

proc spawn_yorick {} {
##
# spawn_yorick
#  Attempts to spawn Yorick. If rlterm or rlwrap are available on the system
#  path, they will be used if the user has enabled them (rlterm takes
#  precedence over rlwrap if both exist and are enabled).
#
# Arguments:
#  None
#
# Returns:
#  0 if the spawn succeeded; 1 if it did not.
#
# Side effects:
#  If successful, then expect does whatever it does when spawn works (including
#  setting various expect-related variables), in the global scope.
##
   global _ytk ytk_fifo_name tky_fifo_name

   # This is 1 until we successfully spawn a Yorick
   set result 1
   set cmd ""
   set yor [list $_ytk(yorick_executable) -i ytk.i $ytk_fifo_name $tky_fifo_name]

   # Attempt to spawn using rlterm
   catch { set rlterm [exec which rlterm] }
   if { $result && [info exists rlterm] && $_ytk(use_rlterm) eq "Yes" } {
      set cmd [concat [list $rlterm] $yor]
      set result [spawner $cmd]
   }

   # Attempt to spawn using rlwrap
   catch { set rlwrap [exec which rlwrap] }
   if { $result && [info exists rlwrap] && $_ytk(use_rlwrap) eq "Yes" } {
      set cmd [concat [list $rlwrap -c -D $_ytk(rlwrap_nodupes) \
         -b "'(){}\[],+=&^%$#@;|\""] $yor]
      set result [spawner $cmd]
   }

   # Attempt to spawn without any wrapper
   if { $result } {
      set cmd $yor
      set result [spawner $cmd]
   }

   logger debug "Spawned yorick: $cmd"

   return $result
}

proc spawner {cmd} {
##
# spawner cmd
#  Executes the given command in the global scope. This is intended to be used
#  solely for spawn commands.
#
#  The global scoping is required because of the various variables expect sets
#  when the spawn command is used. It needs those variables accessible when
#  using other commands, and running the spawn command at the global scope is a
#  sure way to ensure they are not lost at the end of the procedure's scope.
#
# Arguments:
#  A string or list representing the spawn command to evaluate.
#
# Returns:
#  0 if the spawn succeeded; 1 if it did not.
#
# Side effects:
#  If successful, then expect does whatever it does when spawn works (including
#  setting various expect-related variables), in the global scope.
##
   set cmd [concat [list spawn -noecho] $cmd]
   return [catch {uplevel #0 $cmd}]
}

proc ytk_exit {code} {
##
# ytk_exit code
#  Exits Yorick with the given code after performing cleanup (which consists of
#  closing and deleting the fifos).
#
# Arguments:
#  code: A integer in the range 0-127, which will be returned as the exit code.
#
# Returns:
#  Nothing
#
# Side effects:
#  The fifos are closed and their corresponding files deleted. Then the
#  application terminates with the given exit $code.
##
   global ytk_fifo_name tky_fifo_name ytk_fifo tky_fifo

   catch [list close $ytk_fifo]
   catch [list file delete $ytk_fifo_name]

   catch [list close $tky_fifo]
   catch [list file delete $tky_fifo_name]

   logger info "Exiting ytk (exit code: $code)"

   exit $code
}

proc ytk_About {} {
##
# ytk_About
#  Displays an "About" GUI window, creating it if it doesn't already exist.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   global _ytk_splash_img yorick_version about_geo tk_patchLevel

   set w .about
   if {[winfo exists $w]} {
      wm deiconify $w
   } else {
      toplevel $w
      wm title $w "About Ytk"
      button $w.b -text Dismiss -command [list wm withdraw $w]
      label $w.img -image $_ytk_splash_img -relief raised -borderwidth 4
      label $w.text -bd 1 -text \
"Yorick-Tcl-tK (and Expect)\n\
YTK (fork)\n\
Yorick $yorick_version\n\
Tcl [info patchlevel], Tk $tk_patchLevel, Expect [exp_version]"
      pack $w.img -side top
      pack $w.text -fill both -side top -expand 1
      pack $w.b -fill x -side bottom
      wm geometry $w $about_geo
      update
   }
}

proc ytk_kick_off_editor {editor fn} {
##
# ytk_kick_off_editor editor fn
#  Launches the requested editor to edit the specified file. If $fn is an empty
#  string, this is a no-op. If $editor is not recognized, this is a no-op.
#
# Arguments:
#  editor: The name of the editor to use. Should be one of:
#     vim vi kedit kwrite emacs gedit gvim xedit nedit xemacs
#  fn: A string indicating the filename and path to the file to be edited.
#
# Returns:
#  Nothing
#
# Side effects:
#  Launches the given editor with the given file, provided a file is given.
##
   if { $fn != "" } {
      switch $editor {
         vim -
         vi {
            exec xterm -T "$editor $fn" -e $editor $fn &
         }
         kedit  -
         kwrite -
         emacs  -
         gedit  -
         gvim   -
         xedit  -
         nedit  -
         xemacs {
            exec $editor $fn &
         }
      }
   }
}

proc ytk_run_demo {n} {
##
# ytk_run_demo n
#  Instructs Yorick to run the demo named by $n.
#
# Arguments:
#  n: The name of a demo to run.
#
# Returns:
#  Nothing
#
# Side effects:
#  The file "$n.i" will be #included into Yorick, then the command $n will be
#  run in Yorick.
##
   exp_send "#include \"$n.i\"\r"
   expect ">"
   exp_send "$n\r"
}

proc select_for_edit {start_dir} {
##
# select_for_edit start_dir
#  Launches the "Open File" dialog in the given $start_dir directory, then
#  returns the file selected by the user.
#
# Arguments:
#  start_dir: The directory to open up in.
#
# Returns:
#  The filename that was selected.
#
# Side effects:
#  None
##
   return [tk_getOpenFile \
      -initialdir $start_dir \
      -filetypes {
         {{Yorick Programs, files} {.i .gp .gs}  }
         {{Yorick Specfic Tcl/Tk Programs} {.ytk} }
         {{Tcl/Tk Programs} {.tcl .tk} }
         {{All Files}       {*}   }
      }]
}

proc select_then_edit_from {directory} {
##
# select_then_edit_from directory
#  Prompts the user to select a file from $directory, then lets them edit it
#  using the editor defined in $_ytk(editor).
#
# Arguments:
#  directory: The directory from which the user should start browsing from to
#     select their file.
#
# Returns:
#  Nothing
#
# Side effects:
#  Global _ytk_fn is set to the file that is selected.
##
   global _ytk_fn _ytk
   set _ytk_fn [select_for_edit $directory]
   ytk_kick_off_editor $_ytk(editor) $_ytk_fn
}

proc most_recent_loaded {} {
##
# most_recent_loaded
#  Creates a GUI window that lists the most recently loaded files, as defined
#  in _ytk_mrl. Double-clicking an entry will cause it to be sourced via
#  most_recent_lb_dbl_clk.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   global _ytk_mrl

   set w .most_recent

   destroy $w
   toplevel $w
   wm transient $w .

   listbox $w.lb -height 0 -width 0
   button $w.dismiss -text "Dismiss" -command [list destroy $w]
   pack   $w.lb $w.dismiss -side top -fill x
   for { set i 1 } { $i <= 8 } { incr i } {
      if { $_ytk_mrl($i) != "" } {
         $w.lb insert end "$i [file tail $_ytk_mrl($i)]"
      }
   }

   bind $w.lb <Double-Button-1> most_recent_lb_dbl_clk
}

proc most_recent_lb_dbl_clk {} {
##
# most_recent_lb_dbl_clk
#  Used by the binding of <Double-Button-1> on .most_recent (created in
#  most_recent_loaded). This sources the code file represented by that entry in
#  the list box.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Global _ytk_fn is set to the filename represented by the listbox selection.
#  If _ytk_fn ends with .i, then global ycode_dir is set to match _ytk_fn's
#  directory.
#
#  If _ytk_fn ends with .tcl, .tk, or .ytk, it is sourced at the global level
#  and could have any effect. If ytk_fn ends with .i, it is sourced into Yorick
#  and could have any effect; also, Tcl's and Yorick's current directories are
#  changed to ycode_dir.
##
   global _ytk_fn _ytk_mrl

   set idx [lindex [selection get] 0]
   set _ytk_fn $_ytk_mrl($idx)

   source_ytk_file $_ytk_fn
}

proc source_ytk_file {filename} {
##
# source_ytk_file filename
#  Sources the file defined by $filename -- in Yorick if it's a .i file, in Tcl
#  if it's a .ytk, .tk, or .tcl file.
#
# Arguments:
#  None
#
# Returns:
#  1 if the file is one of .i, .ytk, .tk, or .tcl; 0 otherwise.
#
# Side effects:
#  The file is sourced (in either Yorick or Tcl), which could have any effect
#  depending on the code in question.
#
#  If the file is a .i file, then global ycode_dir is set to its containing
#  directory and both Tcl and Yorick have their working directory updated to
#  match it.
##
   global ycode_dir
   switch [file extension $filename] {
      ".tcl" -
      ".tk"  -
      ".ytk" {
         uplevel #0 [list source $filename]
         return 1
      }
      ".i" {
         set ycode_dir [file dirname $filename]
         cd $ycode_dir
         ybkg cd \"$ycode_dir\"
         exp_send "#include \"$filename\"\r"
         expect "> "
         return 1
      }
      default {
         return 0
      }
   }
}

proc ytk_mr_enqueue {f} {
##
# ytk_mr_enqueue filename
#  Addes a file to the "most recently loaded" files list.
#
# Arguments:
#  filename: The name of a file to put in the most recent files list.
#
# Returns:
#  Nothing
#
# Side effects:
#  Stores $filename in global _ytk_mrl in the index specified by global
#  _ytk_mrl_idx, then increments _ytk_mrl_idx (but sets it to 1 if it exceeds
#  8).
##
   global _ytk_mrl _ytk_mrl_idx
   set _ytk_mrl($_ytk_mrl_idx) $f
   incr _ytk_mrl_idx
   if { $_ytk_mrl_idx > 8 } { set _ytk_mrl_idx 1 }
}

proc select_ytk_fn {start_dir} {
##
# select_ytk_fn start_dir
#  Prompts the user to select a file to source (with starting directory
#  $start_dir), the sources it.
#
# Arguments:
#  start_dir: String indicating the directory to start in when prompting for a
#     file.
#
# Returns:
#  Nothing
#
# Side effects:
#  Global _ytk_fn is set to the selected file's name.
#
#  The file is sourced at the global scope, which could have any effect; see
#  source_ytk_file.
#
#  If the file is recognized as a valid kind of file by source_ytk_file, then
#  it's added to the "most recent files" list by way of ytk_mr_enqueue.
##
   global _ytk_fn

   set _ytk_fn [tk_getOpenFile \
      -initialdir $start_dir -filetypes {
         {{Yorick Specfic Tcl/Tk Programs} {.ytk} }
         {{Yorick or Tcl/tk program} {.i .ytk}  }
         {{Yorick Programs} {.i}  }
         {{Tcl/Tk Programs} {.tcl .tk} }
         {{All Files}       {*}   }
      }]

   if {[source_ytk_file $_ytk_fn]} {
      ytk_mr_enqueue $_ytk_fn
   }
}

proc winopen {n} {
##
# winopen n
#  Opens a Yorick plot window, taking these steps:
#  1. Kills the specified window
#  2. Opens the specified window with its dpi set to _ytk(plot_dpi) and its
#     style set to _ytk(plot_style).gs.
#
# Arguments:
#  n: An integer indicating the window to open.
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   global _ytk
   exp_send "winkill,$n;window,$n,dpi=$_ytk(plot_dpi),style=\"$_ytk(plot_style).gs\"\r"
}

proc winkill {n} {
##
# winkill n
#  Kills a Yorick plot window (via the Yorick winkill command).
#
# Arguments:
#  n: An integer indicating the window to kill.
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   exp_send "winkill, $n;\r"
}

proc winsel {n} {
##
# winsel n
#  Selects a Yorick plot window (via the Yorick window command).
#
# Arguments:
#  n: An integer indicating the window to select.
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   exp_send "window, $n;\r"
}

proc pa_winkill {n} {
##
# pa_winkill n
#  Kills a Yorick plot window (via the Yorick winkill command) associated with
#  the plot_array global.
#
# Arguments:
#  n: A string indicating the index into plot_array that represents the
#     window to kill.
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   global plot_array
   winkill $plot_array(window$n)
}

proc pa_fma {n} {
##
# pa_fma n
#  Issues a Yorick frame advance (fma) to a Yorick plot window associated with
#  the plot_array global.
#
# Arguments:
#  n: A string indicating the index into plot_array that represents the
#     window to receive the frame advance.
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   global plot_array
   exp_send "window, $plot_array(window$n); fma;\r"
}

proc pa_limits {n} {
##
# pa_limits n
#  Issues a Yorick limits command to a Yorick plot window associated with the
#  plot_array global.
#
# Arguments:
#  n: A string indicating the index into plot_array that represents the
#     window to receive the limits command.
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   global plot_array
   exp_send "window, $plot_array(window$n); limits;\r"
}

proc setpalette {args} {
##
# setpalette args
#  Issues a Yorick palette command to load the palette defined by
#  _ytk(plot_palette).
#
# Arguments:
#  This can accept any number of arguments, but they are all disregarded. (This
#  makes it useable by variable traces.)
#
# Returns:
#  Nothing
#
# Side effects:
#  None
##
   global _ytk
   exp_send "palette, \"$_ytk(plot_palette).gp\"\r"
}

proc plot_cmd {cmd n} {
##
# plot_cmd cmd n
#  Issues the given command $cmd with index n. Only works when $cmd is plg or
#  plmk. Uses the settings defined in plot_array and the data stored in _ytk_x
#  and _ytk_y (all globals).
#
#  This is used within the GUI created by ytk_plot.
#
# Arguments:
#  cmd: String indicating the command to use. Should be one of: plg plmk
#  n: The index of the command, which should be unique.
#
# Returns:
#  Nothing
#
# Side effects:
#  Globals _ytk_x and _ytk_y are set to the values in pot_array that correspond
#  to the given command/index.
##
   global plot_array markers _ytk_x _ytk_y

   set idx "$cmd$n"
   set win "window($plot_array(window$idx));"
   set fma "$plot_array(fma$idx);"
   if {$fma ne "fma;"} {set fma ""}
   set color  "$plot_array(color$idx)"
   set _ytk_x      "$plot_array(x$idx)"
   set _ytk_y      "$plot_array(y$idx)"
   set lwidth "width=$plot_array(lwidth$idx)"

   switch $cmd {
      plg {
         set marks  "$plot_array(marks$idx)"
         set lwidth "width=$plot_array(lwidth$idx)"
         set type   "$plot_array(type$idx)"

         send_user "($n)$win$fma $cmd,$_ytk_y,$_ytk_x,\
            $marks,type=\"$type\",$lwidth,color=\"$color\"\n"
         exp_send "$win$fma$cmd,$_ytk_y,$_ytk_x,\
            $marks,type=\"$type\",$lwidth,color=\"$color\"\r"
      }
      plmk {
         set marker [expr [lsearch $markers $plot_array(marker$idx)] + 1]
         set msize $plot_array(msize$idx)
         exp_send "$win$fma$cmd,$_ytk_y,$_ytk_x,\
            marker=$marker,$lwidth,msize=$msize,color=\"$color\"\r"
      }
   }
}

proc ytk_plot {plot_type} {
##
# ytk_plot plot_type
#  Creates a GUI to facilitate plotting. This GUI provides the following:
#     * The user can specify which variables to plot, for x and for y (stored
#     in plot_array).
#     * The user can specify a window to plot in, the color to plot with, the
#     marker to use (if relevant), the width to use, line style, and various
#     other settings (all stored in plot_array).
#     * The plot can be executed via a provided button (which uses plot_cmd).
#     * Buttons are provided for fma and limits.
#
# Arguments:
#  plot_type: One of plg or plmk.
#
# Returns:
#  Nothing
#
# Side effects:
#  Sets up the values of global plot_array using a unique index, for later
#  reference.
#
#  Increments global _ytk_plot_num -- or sets to 1 if it does not exist yet.
#
#  Sets the yorick variables _ytk_x and _ytk_y to test data.
##
   global _ytk_plot_num markers expect_out plot_array _ytk_x _ytk_y

   if {[info exists _ytk_plot_num]} {
      incr _ytk_plot_num
   } else {
      set _ytk_plot_num 1
   }

   set fma 1
   set w $plot_type$_ytk_plot_num
   set plot_array(x$w) _ytk_x
   set plot_array(y$w) _ytk_y
   toplevel .$w

   # Determine the present window by asking Yorick with a window() command
   # We'll keep the information and use it to insure we're plotting in the
   # desired window.
   exp_send "window()\r"
   expect "\r*>"
   set win [lindex [split [string trim $expect_out(0,string) "\r\n>"] "\""] 0]
   set plot_array(window$w)  $win

   # send some data for testing.
   exp_send "_ytk_x = span(-6*pi,6*pi, 256); _ytk_y = sin(_ytk_x)/_ytk_x;\r";

   frame .$w.a -relief sunken -borderwidth 3
   button .$w.a.dismiss -text Dismiss -command [list destroy .$w]
   tk_optionMenu .$w.a.window plot_array(window$w)  0 1 2 3 4 5 6 7
   entry .$w.x -width 32 -textvariable plot_array(x$w)
   entry .$w.y -width 32 -textvariable plot_array(y$w)

   button $w.a.kill -text Kill -command [list pa_winkill $w]
   tk_optionMenu .$w.color plot_array(color$w) \
      fg bg black white red green blue cyan magenta yellow
   checkbutton .$w.fma -text {Fma first} \
      -variable plot_array(fma$w) -onvalue fma
   tk_optionMenu .$w.lwidth plot_array(lwidth$w) \
      0.5 1.0 1.5 2.0 2.5 3 5 7 10 15 20 25

   switch $plot_type {
      plg {
         checkbutton .$w.marks -text Marks \
            -variable plot_array(marks$w) \
            -offvalue "marks=0" \
            -onvalue  "marks=1"
         tk_optionMenu .$w.type plot_array(type$w) solid none dash dot dashdot dashdotdot
      }
      plmk {
         eval [list tk_optionMenu .$w.marker plot_array(marker$w)] $markers
         tk_optionMenu .$w.msize plot_array(msize$w) \
            .1 .2 .3 .4 .5 .75 1.0 1.5 2.0 2.5 3 4 5 6 7 10 15 20
      }
   }

   frame .$w.c -relief raised -borderwidth 3
   button .$w.c.plot -text "Execute Plot" -command [list plot_cmd $plot_type $_ytk_plot_num]
   button .$w.c.fma -text Fma -command [list pa_fma $w]
   button .$w.c.limits -text Limits -command [list pa_limits $w]

   pack .$w.c.plot .$w.c.fma .$w.c.limits \
      -side left  -fill x -expand 1
   label .$w.a.winlabel -text "Window:"
   pack .$w.a.dismiss -side right -anchor ne
   pack .$w.a.winlabel .$w.a.window .$w.a.kill -side left -expand 1 -fill x
   pack .$w.a -side top -expand 1 -fill x
   pack .$w.fma -side top
   pack .$w.color -side top
   pack .$w.lwidth -side top
   switch $plot_type {
      plg {
         pack .$w.marks -side top
         pack .$w.type -side top
      }
      plmk {
         pack .$w.marker -side top
         pack .$w.msize -side top
      }
   }
   pack .$w.x .$w.y -side top
   pack .$w.c -side bottom -expand 1 -fill x
}

proc start_yorick {}  {
##
# start_yorick
#  Starts the main Yorick loop. This primarily watches for DOCUMENT strings and
#  will catch them to display in GUI form if configured to do so.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  If configured to spawn documentation for Yorick via Tcl, this will watch
#  Yorick's output and attempt to intercept DOCUMENT statements. Otherwise, it
#  lets everything else pass through as-is.
#
#  In order to avoid hanging, this will only catch DOCUMENT statements that are
#  received within an interval of a single second.
##
   global _ytk interact_out indoc hwin str Y_SITE
   upvar spawn_id spawn_id
   expect ">"
   set n 0
   logger info "Beginning Yorick interact loop."
   interact {
      -o
      -nobuffer
      -re "/\\* DOCUMENT.*\n" {
         regsub -all "\r" $interact_out(0,string) "" str
         if { $_ytk(separate_help_win) eq "Yes" } {
            interact {
               -o
               -re ".*\\*/" {
                  regsub -all "\r" $interact_out(0,string) "" str2
                  set str "$str$str2"
                  incr hwin
                  set wintitle [ lindex [ split $str "\n" ] 0 ]
                  toplevel .docwin$hwin
                  set cmd "scrollbar .docwin$hwin.sb -command {.docwin$hwin.doc yview }"
                  eval $cmd

                  text .docwin$hwin.doc -height 25 \
                     -yscrollcommand [list .docwin$hwin.sb set]
                  .docwin$hwin.doc insert end $str
                  pack .docwin$hwin.doc -side left -fill both -expand 1
                  pack .docwin$hwin.sb -side left -fill y -expand 0
                  wm title .docwin$hwin $wintitle
                  return
               }
               timeout 1 return
            }
         }
      }
   }
   logger info "Yorick interact loop terminated."
}

proc load_and_run {fn} {
##
# load_and_run fn
#  Attempts to load and run the given file $fn. If it fails, the program aborts
#  after notifying the user.
#
#  This is only used when starting Ytk with a command-line file argument.
#
# Arguments:
#  fn: A string indicating the path/filename to try to load.
#
# Returns:
#  Nothing
#
# Side effects:
#  If it fails, the program terminates.
#
#  If it succeeds, almost any side effect could happen since it is sourcing
#  external code. See source_ytk_file for more info on side effects.
##
   logger info "Loading on startup: $fn"
   if { ![file exists $fn] } {
      logger error "File specified to load on start-up not found: $fn"
      tk_messageBox -icon error -message "$fn not found" -type ok
      ytk_exit 1
   }

   if {[catch {source_ytk_file $fn} result]} {
      # Error
      logger error "Error parsing file during startup: $fn\n$result"
      tk_messageBox -icon error -type ok -message "Error parsing $fn:\n$result"
      ytk_exit 1
   } else {
      if {! $result} {
         # Wrong kind of file
         logger error "Unknown file type specified to load at startup: $fn"
         tk_messageBox -icon error -message "Don't know how to handle $fn" -type ok
         ytk_exit 1
      }
   }
}

proc restore_pbd {} {
##
# restore_pbd
#  The user is prompted for a pbd file. If one is provided, it is restored.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Global _ytk_fn is set to the selected file.
#
#  Within Yorick, any variables stored in the pbd are restored in the global
#  scope. Also, _ytk_pbd_f is set to an open filehandle to the pbd file.
##
   global _ytk_fn

   set _ytk_fn [tk_getOpenFile -filetypes {
      {{Yorick PBD file} {.pbd}}
      {{All Files}       {*}   }
   }]

   if { $_ytk_fn ne "" } {
      switch [file extension $_ytk_fn] {
         ".pbd" {
            exp_send "_ytk_pbd_f = openb(\"$_ytk_fn\"); restore, _ytk_pbd_f;\r"
            exp_send "show, _ytk_pbd_f\r"
            toplevel .stby
            exp_send "\r"
            set sz [wm maxsize .]
            label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
            pack .stby.lbl
            set wz "50 50"
            set sx [expr [lindex $sz 0] / 2 - [lindex $wz 0]/2]
            set sy [expr [lindex $sz 1] / 2 - [lindex $wz 1]/2]
            wm geometry .stby "+$sx+$sy"
            update
            expect ">"
            destroy .stby
         }
         default {
            tk_messageBox -type ok -icon error -message "Did not restore $_ytk_fn: not a PBD file."
         }
      }
   }
}

proc show_colorbar {w} {
##
# show_colorbar w
#  Clears the given window $w then draws a colorbar in it for the current
#  palette. Also, the user receives a notice that this has been done.
#
# Argument:
#  w: The window into which the colorbar should be drawn.
#
# Returns:
#  Nothing.
#
# Side effects:
#  Yorick variable _ytk_z is set with the values needed to draw the colorbar.
##
   exp_send "winkill,$w;window,$w;\r"
   exp_send "_ytk_z = char(span(1,240,240)) (,-:1:10);pli,_ytk_z\r"
   expect ">"
   tk_messageBox -message "You should see the color bar in the\
      Yorick window $w.\n\n\
      To see other color bars, Click on <GRAPH> and then the \
      color bar you want to see. "
}

proc launch_gui {} {
##
# launch_gui
#  Sets up the core GUI for Ytk.
#
# Arguments:
#  None
#
# Returns:
#  Nothing
#
# Side effects:
#  Adds a trace on _ytk(plot_palette) that calls setpalette on writes.
##
   global Y_SITE _ytk yorick_version tk_patchLevel

   wm deiconify .
   wm minsize . 350 1
   . configure -width 350
   menu .mb
   . configure -menu .mb
   menu .mb.file
   menu .mb.edit
   menu .mb.edit.editor
   menu .mb.graph
   menu .mb.graph.open
   menu .mb.graph.kill
   menu .mb.graph.select
   menu .mb.graph.gridxy
   menu .mb.graph.plot
   menu .mb.debug
   menu .mb.tkcon
   menu .mb.demo
   menu .mb.help
   .mb add cascade -label File  -underline 0 -menu .mb.file
   .mb add cascade -label Edit  -underline 0 -menu .mb.edit
   .mb add cascade -label Debug -underline 0 -menu .mb.debug
   .mb add cascade -label Graph -underline 0 -menu .mb.graph
   .mb add cascade -label "Tcl/Tk" -underline 0 -menu .mb.tkcon
   .mb add cascade -label Demos -underline 2 -menu .mb.demo
   .mb add cascade -label Help  -underline 0 -menu .mb.help

   .mb.edit add command -label "Y_SITE ..." \
      -command [list select_then_edit_from $Y_SITE]

   .mb.edit add command -label "~/Yorick ..." \
      -command [list select_then_edit_from "~/Yorick/"]

   .mb.edit add command -label "~/lidar-processing ..." \
      -command [list select_then_edit_from "~/lidar-processing/"]

   .mb.edit add separator
   .mb.edit add cascade -label "Editor" -underline 0 -menu .mb.edit.editor

   set editors [list vi vim gvim emacs xemacs kedit nedit kwrite gedit xedit]
   set underlines [list 0 0 2 0 0 2 0 1 0 4]
   foreach editor $editors underline $underlines {
      .mb.edit.editor add radiobutton -label $editor -value $editor \
         -variable _ytk(editor) -underline $underline
   }
   unset editors underlines

   .mb.edit add separator
   .mb.edit add command -label "Save Options" -command save_options
   .mb.edit add command -label "Restore Defaults" -command restore_defaults
   .mb.edit add separator
   .mb.edit add command -label "Yorick executable ..." -command {
      set _ytk(yorick_executable) [ tk_getOpenFile \
         -initialdir [file dirname $_ytk(yorick_executable)] \
         -initialfile [file tail $_ytk(yorick_executable)] ]
   }
   .mb.edit add checkbutton -label "Use rlterm" -onvalue Yes -offvalue No -variable _ytk(use_rlterm)
   .mb.edit add checkbutton -label "Use rlwrap" -onvalue Yes -offvalue No -variable _ytk(use_rlwrap)


   .mb.debug add command \
      -label "dbauto,0  Enter dbug automatically" -command { exp_send "dbauto,0\r" }
   .mb.debug add command \
      -label "dbauto,1  Enter dbug after hitting <RET>" -command { exp_send "dbauto,1\r" }
   .mb.debug add command -label "dbdis" -command { exp_send "dbdis\r" }
   .mb.debug add command -label "dbexit" -command { exp_send "dbexit\r" }
   .mb.debug add command -label "dbinfo" -command { exp_send "dbinfo\r" }
   .mb.debug add command -label "dbskip" -command { exp_send "dbskip\r" }
   .mb.debug add command -label "dbup" -command { exp_send "dbup\r" }

   .mb.tkcon add command -label "Logger" -command [list wm deiconify .ytklogger]
   .mb.tkcon add command -label "Tkcon" -command {
      exec tkcon &
   }

   .mb.tkcon add checkbutton -label "Tkcmd window"  \
      -onvalue "wm deiconify .tx" \
      -offvalue "wm withdraw .tx" \
      -variable tkcmdvalue  -underline 1 -command {eval $tkcmdvalue}

   .mb.demo add command -label "demo 1  sliding sine wave" -command { ytk_run_demo demo1 }
   .mb.demo add command -label "demo 2  drum head simulation" -command { ytk_run_demo demo2 }
   .mb.demo add command -label "demo 3  mechanical arms swinging around" -command { ytk_run_demo demo3 }
   .mb.demo add command -label "demo 4  Air flow around an airfoil section" -command { ytk_run_demo demo4 }
   .mb.demo add command -label "demo 5  3D graphics and 3D slicing" -command { ytk_run_demo demo5 }
   .mb.demo add command -label "testg   Graphics performance test" -command { ytk_run_demo testg }
   .mb.demo add command -label "testlp  Test linear algebra functions" -command { ytk_run_demo testlp }
   .mb.demo add command -label "testm   Test Fft, LU, QR, and SVD" -command { ytk_run_demo testm }
   .mb.demo add command -label "test1" -command { ytk_run_demo test1 }
   .mb.demo add command -label "test2" -command { ytk_run_demo test2 }
   .mb.demo add command -label "test3" -command { ytk_run_demo test3 }
   .mb.demo add command -label "testb   Test I/O stuff" -command { ytk_run_demo testb }
   .mb.demo add command -label "testfull Runs a complete test of Yorick" -command { ytk_run_demo testfull }

   .mb.help add checkbutton -label "Help goes in new window" \
      -onvalue Yes -offvalue No -variable _ytk(separate_help_win)
   .mb.help add checkbutton -label "Help PopUp" \
      -onvalue Yes -offvalue No -variable _ytk(annoying_help) \
      -command {
         if { $_ytk(annoying_help) eq "Yes" } {
            wm state .ytk_dynamic_help normal
         }  else {
            wm state .ytk_dynamic_help withdrawn
         }
      }
   .mb.help add separator
   .mb.help add command -label "About Ytk" -command { ytk_About }
   .mb.help add command -label "Y_SITE: $Y_SITE"
   .mb.help add command -label "Yorick Version: $yorick_version"
   .mb.help add command -label "Yorick location: $_ytk(yorick_executable)"
   .mb.help add command -label "Tcl [info patchlevel], Tk $tk_patchLevel, Expect [exp_version]"
   .mb.help add command -label "Yorick" -command { exp_send "help\r" }
   .mb.help add separator

   set help_commands [list \
      array animate fft fma grow help hardcopy indgen interp limits numberof \
      plg plmk plsys print sort span where where2 write window viewport \
      get_dir get_openfn get_savefn tk_messageBox]

   foreach help_command $help_commands {
      .mb.help add command -label $help_command \
         -command [list exp_send "help, $help_command\r"]
   }
   unset help_command help_commands

   .mb.file add command -label "Load a Yorick/ytk program file ..." \
      -command { select_ytk_fn $ytkcode_dir }
   .mb.file add command -label "Load Yorick/ytk from ~/Yorick ..." \
      -command { select_ytk_fn "~/Yorick" }
   .mb.file add command -label "Load Yorick/ytk from Y_SITE ..." \
      -command { select_ytk_fn $Y_SITE }

   .mb.file add command -label "Restore PBD Data file..." -command restore_pbd

   .mb.file add separator
   .mb.file add command -label "Most recent loaded" -command most_recent_loaded
   .mb.file add separator
   .mb.file add command -label Exit -command [list ytk_exit 0]

   toplevel .ytk_dynamic_help
   set varinfo "This is the Dynamic help window.
      Many of the menu items will be described here
      when you place the mouse cursor over each item."
   label .ytk_dynamic_help.lhelp \
      -textvariable varinfo \
      -bg yellow -fg black -borderwidth 7
   button .ytk_dynamic_help.dismiss \
      -fg black \
      -bg orange \
      -activebackground red \
      -activeforeground white \
      -text "Turn dynamic help OFF" \
      -command {
         wm state .ytk_dynamic_help withdrawn
         set _ytk(annoying_help) No
      }
   pack .ytk_dynamic_help.lhelp .ytk_dynamic_help.dismiss \
      -side top -expand 1 -fill both

   if { $_ytk(annoying_help) eq "No" } {
      wm state .ytk_dynamic_help withdrawn
   }

   ####################### File menu
   DynamicHelp::register .mb.file menu varinfo
   DynamicHelp::register .mb.file menuentry 0 \
   "Click the dashed-line to convert this menu
   into a separate window which will persist."
   DynamicHelp::register .mb.file menuentry 1 \
   "Load Ytk program into the Tcl/Tk portion of
   Ytk, or load Yorick .i file into Yorick."

   DynamicHelp::register .mb.file menuentry 2 \
   "Load Ytk program or a
   Yorick .i file from
   your personal Yorick
   directory."

   DynamicHelp::register .mb.file menuentry 3 \
   "Load Ytk program or a Yorick .i
   file from the Y_SITE directory.
   (Y_SITE on your system is: $Y_SITE)"

   DynamicHelp::register .mb.file menuentry 4 \
   "Load a Yorick PBD (Portable Binary Data)
   file into Yorick and display the variable
   names stored in it."

   DynamicHelp::register .mb.file menuentry 6 \
   "Use this to quickly re-load a file that
   you have previously loaded.  This saves
   having to locate the file with the file
   dialog window."

   DynamicHelp::register .mb.file menuentry 8 \
   "This terminates Ytk and Yorick. If you
   would like to keep any setting changes
   you've made, be sure and save them by
   clicking Edit, then \"Save Options\"
   before exiting."

   ####################### Edit menu
   DynamicHelp::register .mb.edit menu varinfo
   DynamicHelp::register .mb.edit menuentry 0 \
   "Click the dashed-line to convert this menu
   into a separate window which will persist."
   DynamicHelp::register .mb.edit menuentry 1 \
   "Select, then edit a file from Y_SITE
   ($Y_SITE on your system)
   with the selected editor."

   DynamicHelp::register .mb.edit menuentry 2 \
   "Select, then edit a file from
   your personal Yorick subdirectory
   with the selected editor."

   DynamicHelp::register .mb.edit menuentry 3 \
   "Select, then edit a file from
   the lidar-processing subdirectory
   with the selected editor.  This is
   specific to my project, edit ytk
   and change it if you want."

   DynamicHelp::register .mb.edit menuentry 5 \
   "Select your favorite editor below.  Whichever
   editor is selected is the one that will be
   used by the above menus.  The editors need
   to be present on your system and in a location
   described in your path statement."

   DynamicHelp::register .mb.edit menuentry 16 \
   "Save all the ytk settings to .ytkrc in your
   home directory."

   DynamicHelp::register .mb.edit menuentry 17 \
   "Restore ytk to the default settings.  If you
   want the defaults to be loaded the next time
   you run ytk, be sure and click \"Save Options\"
   above to write them to .ytkrc."

   ####################### Graph menu
   DynamicHelp::register .mb.graph menu varinfo
   DynamicHelp::register .mb.graph menuentry 0 \
   "Click the dashed-line to convert this menu
   into a separate window which will persist."

   DynamicHelp::register .mb.graph menuentry 1 \
   "Open a Yorick graphics window. **BEFORE**
   you open the window, be sure and select the
   size (Dpi 75 or 100) and also the style.  You
   can't change dpi or style without killing, and
   then reopening the graphics window.
   Up to 8 windows can be opened at once. Be
   careful to always kill a window with the winkill
   command or the \"Window Kill\" menu selection. If
   you use the little \"X\". Yorick won't know
   the window was killed."

   DynamicHelp::register .mb.graph menuentry 2 \
   "Get rid of a Yorick graphics window."

   DynamicHelp::register .mb.graph menuentry 3 \
   "Select a Yorick window for use.  After selecting
   a window, all Yorick plotting commands will
   use it."

   DynamicHelp::register .mb.graph menuentry 4 \
   "Draw various grids over the current
   Yorick graphics window."

   DynamicHelp::register .mb.graph menuentry 5 \
   "This menu contains all the Yorick plotting
   commands and basic menus to select many of the
   specific options."

   DynamicHelp::register .mb.graph menuentry 7 \
   "The next \"Open Window..\" will create a
   75 Dpi (450x450 pixel) graphics window."

   DynamicHelp::register .mb.graph menuentry 8 \
   "The next \"Open Window..\" will create a
   100 Dpi (600x600 pixel) graphics window."

   DynamicHelp::register .mb.graph menuentry 10 \
   "Axes: Has coordinate axes with ticks running through
   the middle of the viewport, similar to the style
   of many elementary math textbooks."

   DynamicHelp::register .mb.graph menuentry 11 \
   "Boxed: Many people prefer the 'Boxed' style,
   which looks more like other graphics packages."

   DynamicHelp::register .mb.graph menuentry 12 \
   "Boxed2: Variant of Boxed. Allows you to put
   a second set of tick marks and labels on the
   right hand side of the plot, independent of
   the ones on the left side."

   DynamicHelp::register .mb.graph menuentry 13 \
   "L_nobox: Allow you to put a second set of
   tick marks and labels on the right hand side
   of the plot, independent of the ones on the
   left side."

   DynamicHelp::register .mb.graph menuentry 14 \
   "Nobox: has no tick marks, labels, or other
   distractions; use it for drawing geometrical
   figures or imitating photographs."

   DynamicHelp::register .mb.graph menuentry 15 \
   "Vgbox: Viewgraph graphics style in a box."

   DynamicHelp::register .mb.graph menuentry 16 \
   "Vg: Viewgraph graphics style'', which the
   High Priest of Yorick, David Munro, recommends
   as the starting point for high quality graphics."

   DynamicHelp::register .mb.graph menuentry 17 \
   "Work: the default style and David Munro's
   own preference."

   DynamicHelp::register .mb.graph menuentry 18 \
   "Work2: allow you to put a second set of tick
   marks and labels on the right hand side of the
   plot, independent of the ones on the left side."

   DynamicHelp::register .mb.graph menuentry 20 \
   "Pops up Yorick graphics window-0 and fills it
   with the selected color bar.  After the window
   is up, you can select other color bars and the
   display update and show you what they look like."

   ####################### Tcl/Tk menu
   DynamicHelp::register .mb.tkcon menu varinfo
   DynamicHelp::register .mb.tkcon menuentry 0 \
   "Click the dashed-line to convert this menu
   into a separate window which will persist."

   DynamicHelp::register .mb.tkcon menuentry 1 \
   "Run Tkcon.  You can use Tkcon to help debug
   Ytk and Tcl/Tk programs.  You can attach Tkcon
   to Ytk by clicking:

   Console->Attach to->Interpreter->ytk.

   You will be able to send Tcl/Tk commands to Ytk
   and examine variables etc. etc.  See the Tkcon
   website: http://tkcon.sourceforge.net. for more
   documentation.  Tkcon is part of the Activetcl
   package."


   DynamicHelp::register .mb.tkcon menuentry 2 \
   "Open a window to view Tcl/Tk commands sent to ytk
   for execution.  If you call ytk functions from
   your Yorick programs, you can see what ytk actually
   received and executed in this window."


   ####################### Tcl/Tk menu
   DynamicHelp::register .mb.help menu varinfo
   DynamicHelp::register .mb.help menuentry 0 \
   "Click the dashed-line to convert this menu
   into a separate window which will persist."

   DynamicHelp::register .mb.help menuentry 1 \
   "Redirects the Yorick help results to a separate
   window."

   DynamicHelp::register .mb.help menuentry 2 \
   "Enable or disable the annoying dynamic help display
   which is displaying this message right now."

   ####################### plg submenu
   DynamicHelp::register .mb.graph.plot menu varinfo
   DynamicHelp::register .mb.graph.plot menuentry 0 \
   "Plg: This command plots with lines connecting
   the points. It is much faster then plmk if you
   have much data."

   trace variable _ytk(plot_palette) w setpalette

   .mb.graph add cascade -label "Open window..." -underline 1 -menu .mb.graph.open
   .mb.graph add cascade -label "Kill window..." -underline 1 -menu .mb.graph.kill
   .mb.graph add cascade -label "Select window..." -underline 1 -menu .mb.graph.select
   .mb.graph add cascade -label "Grid Settings..." -underline 1 -menu .mb.graph.gridxy
   .mb.graph add cascade -label "Plot ..." -underline 2 -menu .mb.graph.plot
   .mb.graph add separator
   .mb.graph add radiobutton \
      -label "75 Dpi (450x450)" -value "75" -variable _ytk(plot_dpi) -underline 1
   .mb.graph add radiobutton \
      -label "100 Dpi (600x600)" -value "100" -variable _ytk(plot_dpi) -underline 1
   .mb.graph add separator

   set plot_styles [list axes boxed boxed2 l_nobox nobox vgbox vg work work2]
   foreach plot_style $plot_styles {
      .mb.graph add radiobutton -label $plot_style -value $plot_style \
         -variable _ytk(plot_style) -underline 1
   }
   unset plot_style plot_styles

   .mb.graph add separator
   .mb.graph add command -label "Show color bar in window 0" \
      -command [list show_colorbar 0]

   set plot_palettes [list earth stern rainbow yarg heat gray]
   foreach plot_palette $plot_palettes {
      .mb.graph add radiobutton -label $plot_palette -value $plot_palette \
         -variable _ytk(plot_palette) -underline 1
   }
   unset plot_palette plot_palettes

   for {set w 0} {$w < 8} {incr w} {
      .mb.graph.open add command -label "Window $w" -command [list winopen $w]
      .mb.graph.kill add command -label "Winkill $w" -command [list winkill $w]
      .mb.graph.select add command -label "Window $w" -command [list winsel $w]
   }

   .mb.graph.gridxy add command -label "No grid lines" \
      -command { exp_send "gridxy,0,0\r"  }
   .mb.graph.gridxy add command -label "Y axis only" \
      -command { exp_send "gridxy,0,1\r"  }
   .mb.graph.gridxy add command -label "X axis only" \
      -command { exp_send "gridxy,1,0\r"  }
   .mb.graph.gridxy add command -label "Grid X and Y" \
      -command { exp_send "gridxy,1,1\r"  }
   .mb.graph.gridxy add separator
   .mb.graph.gridxy add command -label "Y origin only" \
      -command { exp_send "gridxy,,2\r"  }
   .mb.graph.gridxy add command -label "X origin only" \
      -command { exp_send "gridxy,2,0\r"  }
   .mb.graph.gridxy add command -label "X and Y origins only" \
      -command { exp_send "gridxy,2,2\r"  }

   # TODO: implement and add options for: plc pldj plf plfp pli plm plt plv
   .mb.graph.plot add command -label "Plg  ..." -underline 2 \
      -command [list ytk_plot plg]
   .mb.graph.plot add command -label "Plmk ..." -underline 2 \
      -command [list ytk_plot plmk]

   toplevel .tx
   wm withdraw .tx
   button .tx.hide -text "Click to hide this window" \
      -command { .mb.tkcon invoke 2  }
   pack .tx.hide -side top -fill x -expand 1
   scrollbar .tx.sb -command {.tx.doc yview }
   text .tx.doc  -width 80 -height 4 -yscrollcommand {  .tx.sb set }
   pack  .tx.doc .tx.sb -side left -fill y -expand 1

   wm state . normal
}

######## END PROCEDURES ########

############ LOGGER ############

proc ytk_logger_window {} {
# Creates the logger window and initializes logging.
   toplevel .ytklogger
   wm protocol .ytklogger WM_DELETE_WINDOW [list wm withdraw .ytklogger]
   wm withdraw .ytklogger

   set mb .ytklogger.mb
   iwidgets::messagebox $mb -maxlines 10000
   pack $mb -fill both -expand true

   foreach type [log::levels] {
      $mb type add $type -background [log::lv2color $type] -font {Courier 8}
   }

   log::lvCmdForall ytk_logger_log

   set menu [$mb component itemMenu]
   $menu add separator

   foreach level [lsort -decreasing -command log::lvCompare [log::levels]] {
      $menu add radiobutton -value $level -variable _ytk(log_level) \
         -command ytk_logger_level_set \
         -label $level
   }

   ytk_logger_level_set

   logger info "Logger initialized."
}

proc ytk_logger_level_set {} {
# Updates the suppressions for various log levels against _ytk(log_level).
   foreach level [log::levels] {
      log::lvSuppress $level [expr {[log::lvCompare $::_ytk(log_level) $level] > 0}]
   }
}

proc ytk_logger_log {level message} {
# Logging command to use to put something in the logging window. Used by log::log.
   global _ytk
   set level [log::lv2longform $level]
   .ytklogger.mb issue $message [log::lv2longform $level]
   if {$_ytk(log_file) ne ""} {
      ::fileutil::appendToFile $_ytk(log_file) "\[[pid]\] $message\n"
   }
}

proc logger {level message} {
# Use this to send a logging message to the logger window in your code. For example:
#   logger error "Something bad happened."
#   logger debug "foo = $foo"
   __logger $level $message Tcl
}

set ::_ytk_logger_id -2
proc logger_id {} {
# Returns a unique identifier that can be used within logging output to
# identify, for example, which procedure you're in. Always returns an even
# number in parentheses as a string.
#
# For example, in a procedure named "foo", you might do this:
#
# set log_id [logger_id]
# logger debug "$log_id Entering foo()"
# ...
# logger debug "$log_id i=$i"
# ...
# logger debug "$log_id Leaving foo"
#
# This lets you keep track of which function call is generating which output,
# which is useful when you have debug output mixed together from a function
# that calls a function that calls a function...
   return "([incr ::_ytk_logger_id 2])"
}

proc ylogger {level message} {
# Used by Yorick's logger command.
   __logger $level $message Yor
}

proc __logger {level message type} {
# Implementation for both logger and ylogger.
   set tstamp [clock format [clock seconds] -format %T]
   log::log $level "\[$type $tstamp\] $level$log::fill($level) : $message"
}

########## END LOGGER ##########

restore_defaults     ;# begin with the default settings
load_options
ytk_logger_window

############################################################
# Stuff below here doesn't need to be changed if you are
# just porting to another system.
############################################################

logger debug "Started as: $argv0 $argv"
logger debug "info library: [info library]"
logger debug "info nameofexecutable: [info nameofexecutable]"
logger debug "info script: [info script]"
logger debug "info patchlevel: [info patchlevel]"

############# set _ytk(yorick_executable) junk
if { ![file exists $_ytk(yorick_executable)] } {
   set _ytk(yorick_executable) [yorick_executable]
   if { ![file exists $_ytk(yorick_executable)] } {
      puts stderr "No yorick found, aborting..."
      ytk_exit 2
   }
}

logger debug "Yorick executable: $_ytk(yorick_executable)"

initialize_globals
establish_fifos

if { [spawn_yorick] } {
   puts "Encountered problem starting yorick... please restart with a different yorick"
   ytk_exit 3
}

expect "Yorick * ready"
set yorick_version [lindex [split $expect_out(0,string)] 1]
logger debug "Yorick version: $yorick_version"

set indoc 0
set hwin 0
logger debug "Spawn id: $spawn_id"
match_max -i $spawn_id 32768

wm withdraw .
if {$gui_enabled} {
   launch_gui
}

if { $load_on_start != "" } {
   foreach file_to_load $load_on_start {
      load_and_run $file_to_load
   }
}

ybkg funcset initialdir \"$_ytk(initialdir)\"
ybkg funcset _ytk 1

start_yorick

ytk_exit 0
