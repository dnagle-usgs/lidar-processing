// vim: set ts=2 sts=2 sw=2 ai sr et:

extern _transect_history;
/* DOCUMENT _transect_history

  A stack of recent transect lines generated by calls to "mtransect."
  These can be recalled repeatly with the transact command.

  For example, to recall the last mouse_transect with transect you would:

    transect( fs_all, _transect_history(,0), ..... )

  To recall the one before last, use:

    transect( fs_all, _transect_history(,-1), ..... )
*/

func mtransect(fs, iwin=, owin=, w=, connect=, recall=, color=, xfma=,
rcf_parms=, rtn=, show=, msize=, expect=, marker=) {
/* DOCUMENT mtransect(fs, iwin=, owin=, w=, connect=, recall=, color=, xfma=,
   rcf_parms=, rtn=, show=, msize=, expect=, marker=)

  Mouse selected transect. mtransect allows you to "drag out" a line within an
  ALPS topo display window and then create a new graph of all of the points
  near the line.

  To recall a transect line, call mtransect with the recall= parameter and set
  it to:
    0 for the most recent line
    -1 for the previous line
    -2 for the one before that, etc.

  Input:
  fs         :  Variable to process
  owin=      :  Desired Yorick output graph window.       Default is 3
  iwin=      :  Source window for transect.               Default is 5
  w=         :  Search distance from line in centimeters. Default is 150cm
  connect=   :  Set to 1 to connect the points.
  recall=    :  Used to recall a previously generated transact line.
  color=     :  The starting color 1:7, use negative to use only 1 color
  xfma=      :  Set to 1 to auto fma.
  rtn=       :  Select return type where:
          0  first return
          1  veg last return
          2  submerged topo
  show=      :  Set to 1 to plot the transect in window, win.
  rcf_parms= :  Filter output with [W, P], where
          W = filter width
          P = # points on either side to use as jury pool
  msize=     :  set msize value (same as plcm, etc.), default = .1
  marker=    :  set marker value (same as plcm, etc.), default = 1

  Examples:

  g = mtransect(fs_all, connect=1, rcf_parms=[1.0, 5], xfma=1)

    - use fs_all as data source
    - connect the dots in the output plot
    - rcf filter the output with a 1.0 meter filter width and use 5 points on
      either side of each point as the jury pool
    - auto fma
    - returns the index of the selected points in g
    - this example expects you to generate the line segment with the mouse

  g = mtransect(fs_all, connect=1, rcf_parms=[1.0, 5], xfma=1, recall=0)

  This example is the same as above, except:
  - the transect line is taken from the global transect_history array

  SEE ALSO: transect, _transect_history
*/
  extern _transect_history, transect_line;

  wbkp = current_window();

  default, rtn, 0;  // first return
  default, w, 150;
  default, connect, 0;
  default, owin, 3;
  default, iwin, 5;
  default, msize, 0.1;
  default, xfma, 0;
  default, color, 2;  // start at red, not black

  window,owin;
  lmts = limits();
  window,iwin;
  if(is_void(recall)) {
    // get the line coords with the mouse and convert to cm
    transect_line = mouse(1, 2, "")(1:4)*100.0;
    l = transect_line;   // just to keep the equations short;
    if(show)
      plg, [l(2),l(4)]/100., [l(1),l(3)]/100., width=2.0, color="red";
    grow, _transect_history, [l]
  } else {
    if(numberof(_transect_history) == 0) {
      write, "No transect lines in _transect_history";
      window_select, wbkp;
      return;
    }
    if(recall > 0) recall = -recall;
    l = _transect_history(, recall);
  }

  glst = transect(fs, l, connect=connect, color=color, xfma=xfma,
    rcf_parms=rcf_parms, rtn=rtn, owin=owin, lw=w, msize=msize, marker=marker);
  // plot the actual points selected onto the input window
  if (show == 2 ) {
    data2xyz, unref(fs(glst)), x, y, z, mode=["be","ba","fs"](rtn);
    window, iwin;
    plmk, unref(y), unref(x), msize=msize, marker=marker, color="black",
      width=10;
  }
  if(show == 3) {   // this only redraws the last transect selected.
    window, iwin;
    plg, [transect_line(2),transect_line(4)]/100.,
      [transect_line(1),transect_line(3)]/100., width=2.0, color="red";
  }
  window, owin;
  if(is_void(recall)) {
    limits;
  } else {
    limits, lmts(1),lmts(2), lmts(3), lmts(4);
  }
  if(!is_void(expect))
    write, format="%s\n", "END mtransect:";

  window_select, wbkp;
  return glst;
}

func transect(fs, l, lw=, connect=, xtime=, msize=, xfma=, owin=, color=,
rcf_parms=, rtn=, marker=) {
/* DOCUMENT transect(fs, l, lw=, connect=, xtime=, msize=, xfma=, owin=,
   color=, rcf_parms=, rtn=, marker=)

  Input:
  fs         :  Data where you drew the line
  l          :  Line (as given by mouse())
  lw=        :  Search distance either side of the line in centimeters
  xtime=     :  Set to 1 to plot against time (sod)
  xfma=      :  Set to 1 to clear screen
  owin=      :  Set output window
  color=     :  Select starting color, 1-7, use negative to use only 1 color
  rcf_parms= :  [fw,np]  RCF the data where:
            fw is the width of the filter
            np is the number of points on either side of the index
             to use as a jury.
  rtn=       :  Select return type where:
            0  first return
            1  veg last return
            2  submerged topo from bathy algo

  msize      :  set msize value (same as plcm, etc.), default = .1
  marker     :  set marker value (same as plcm, etc.), default = 1

  SEE ALSO: mtransact, _transect_history
*/
  extern rx, elevation, glst, llst, segs;

  wbkp = current_window();

  default, rtn, 0;    // first return
  default, lw, 150;   // search width, cm
  default, color, 1;  // 1 is first color
  default, owin, 3;
  default, msize, 0.1;
  default, marker, 1;

  window, wait=1;
  window, owin;
  if(xfma) fma;

  // determine the bounding box n,s,e,w coords
  n = l(2:4:2)(max);
  s = l(2:4:2)(min);
  w = l(1:3:2)(min);
  e = l(1:3:2)(max);

  // compute the rotation angle needed to make the selected line
  // run east west
  dnom = l(1)-l(3);
  if(dnom != 0.0)
    angle = atan((l(2)-l(4)) / dnom) ;
  else angle = pi/2.0;
  //  angle ;
  //  [n,s,e,w]

  // clean and sort fs
  fs = test_and_clean(fs);
  // sort by soe only if soe values are not the same. This is necessary because
  // some times a data set is brought in that does not have any soe value
  if(is_array(where(fs.soe(dif))))
    fs = fs(sort(fs.soe))

  // build a matrix to select only the data withing the bounding box

  glst = data_box(fs.east, fs.north, w, e, s, n);
  // rotation:  x' = xcos - ysin
  //            y' = ycos + xsin

  // Steps:
  //    1 translate data and line to 0,0
  //    2 rotate data and line
  //    3 select desired data

  if(numberof(glst) == 0) {
    write, "No points found along specified line";
    window_select, wbkp;
    return;
  }

  // XYZZY - this is the last place we see fs being used for x
  y = fs.north(*)(glst) - l(2);
  x = fs.east(*)(glst)  - l(1);

  ca = cos(-angle);
  sa = sin(-angle);

  // XYZZY - rx is used to plot x
  // XYZZY - would the rx element give us the glst element to use?
  rx = x*ca - y*sa;
  ry = y*ca + x*sa;

  // XYZZY - y is computed from elevation
  // XYZZY - lw is the search width
  llst = where(abs(ry) < lw);
  if(rtn == 0)
    elevation = fs.elevation(*);
  else if(rtn == 1)
    elevation = fs.lelv(*);
  else if(rtn == 2)
    elevation = fs.elevation(*) + fs.depth(*);

  //     1        2      3       4        5          6         7
  clr = ["black", "red", "blue", "green", "magenta", "yellow", "cyan" ];

  window, owin;
  window, wait=1;
  segs = where(abs(fs.soe(glst(llst))(dif)) > 5.0);
  nsegs = numberof(segs)+1;
  if(nsegs > 1) {
   // 20060425:  setting ss to [0] causes bizarre behavior where lines appear
   // to get merged.
   ss = [];
   grow, ss, segs,[0];
   segs = ss;

   segs = segs(where(abs(segs(dif)) > 1.0));
   nsegs = numberof(segs)+1;
  }

  ss = [0];
  if(nsegs > 1) {
    grow, ss, segs, [0];
    c = color;
    msum = 0;
    for(i = 1; i < numberof(ss); i++) {
      if(c >= 0)
        c = ((color+(i-1))%7);
      soeb = fs.soe(*)(glst(llst)(ss(i)+1));
      t = soe2time( soeb );
      tb = fs.soe(*)(glst(llst)(ss(i)+1))%86400;
      te = fs.soe(*)(glst(llst)(ss(i+1)))%86400;
      td = abs(te - tb);
      hms = sod2hms(tb);

      // This grabs the heading from the tans data nearest the end point.  This
      // really only works when looking at "just processed" data and not batch
      // processed data.
      hd = 0.0;
      if(is_array(tans)) {
        foo = where(abs(tans.somd-te) < .010);
        if(numberof(foo) > 0)
          hd = tans.heading(foo(1));
      }

      write, format="%d:%d sod = %6.2f:%-10.2f(%10.4f) utc=%2d:%02d:%02d %5.1f %s\n",
        t(1),t(2), tb, te, td, hms(1), hms(2), hms(3), hd, clr(abs(c));

      if(xtime) {
        plmk, elevation(*)(glst(llst)(ss(i)+1:ss(i+1)))/100.0,
          fs.soe(*)(llst)(ss(i)+1:ss(i+1))/100.0,color=clr(abs(c)),
          msize=msize, width=10, marker=marker;
        if(connect)
          plg, elevation(*)(glst(llst)(ss(i)+1:ss(i+1)))/100.0,
            fs.soe(*)(llst)(ss(i)+1:ss(i+1))/100.0, color=clr(abs(c));
      } else {
        xx = rx(llst)(ss(i)+1:ss(i+1))/100.0;
        si = sort(xx);
        yy = elevation(glst(llst)(ss(i)+1:ss(i+1)))/100.0;
        if(!is_void(rcf_parms))
          si = si(moving_rcf(yy(si), rcf_parms(1), int(rcf_parms(2))));
        // XYZZY - this is where the points get plotted
        plmk, yy(si), xx(si),color=clr(abs(c)), msize=msize, width=10,
          marker=marker;
        if(connect) plg, yy(si), xx(si),color=clr(abs(c));
      }
    }
  } else {
    xx = rx(llst)/100.0;
    yy = elevation(glst(llst))/100.0;
    si = sort(xx);
    if(!is_void(rcf_parms))
      si = si(moving_rcf(yy(si), rcf_parms(1), int(rcf_parms(2))));
    plmk, yy(si),xx(si), color=clr(color), msize=msize, marker=marker, width=10;
    if(connect)
      plg, yy(si), xx(si),color=clr(color);

    c = (color+0)&7;
    soeb = fs.soe(*)(glst(llst)(1));
    t = soe2time(soeb);
    tb = fs.soe(*)(glst(llst)(1))%86400;
    te = fs.soe(*)(glst(llst)(0))%86400;
    td = abs(te - tb);
    hms = sod2hms(tb);
    if(is_array(tans)) {
      hd = tans.heading(*)(int(te));
    } else {
      hd = 0.0;
    }
    write, format="%d:%d sod = %6.2f:%-10.2f(%10.4f) utc=%2d:%02d:%02d %5.1f %s\n",
      t(1),t(2), tb, te, td, hms(1), hms(2), hms(3), hd, clr(c);
  }
  window_select, wbkp;
  return glst(llst);
}
