// vim: set ts=2 sts=2 sw=2 ai sr et:

extern _transect_history;
/* DOCUMENT _transect_history

  A stack of recent transect lines generated by calls to "mtransect."
  These can be recalled repeatly with the transact command.

  For example, to recall the last mouse_transect with transect you would:

    transect( fs_all, _transect_history(,0), ..... )

  To recall the one before last, use:

    transect( fs_all, _transect_history(,-1), ..... )
*/

func transect_recall(idx) {
/* DOCUMENT transect_recall(idx)
  Retrieve a line from the transect history. IDX should be an integer. It may
  be positive or negative, but only its absolute magnitude matters.
    idx=0 will return the most recently created transect
    idx=1 or idx=-1 will return the second most recent transect
    idx=2 or idx=-2 will return the third most recent transect
    etc.
  If the given IDX does not exist in the history, then EXIT will be called to
  abort out of all current functions.
*/
  extern _transect_history;
  // Force IDX to be a non-positive number
  idx = -abs(idx);
  if(is_void(_transect_history)) {
    write, "No lines in _transect_history";
    exit;
  }
  if(abs(idx) >= dimsof(_transect_history)(3)) {
    write, "Requested line exceeds history in _transect_history";
    exit;
  }
  return _transect_history(,idx);
}

func transect_plot_line(line, win=, recall=) {
/* DOCUMENT transect_plot_line, line, win=, recall=
  Plots a transect line. The line will be red. The start point will be given a
  blue dot and the end point will be given a red dot.
*/
  extern _transect_history;
  wbkp = current_window();
  if(!is_void(win)) window, win;
  if(!is_void(recall)) line = transect_recall(recall);
  plg, line([2,4]), line([1,3]), width=2., color="red";
  plmk, line(2), line(1), marker=4, msize=.2, color="blue";
  plmk, line(4), line(3), marker=4, msize=.2, color="red";
  window_select, wbkp;
}

func transect_plot_points(line, data, how=, win=, msize=, marker=, connect=) {
/* DOCUMENT transect_plot_points, line, data, how=, win=, msize=, marker=,
   connect=

  Plots the points from DATA as they appear along the transect LINE. Points
  will be broken up into segments (based on HOW).

  Parameters:
    line: A 4-element array [x0,y0,x1,y1]
    data: The points along LINE (as determined by transect)

  Options:
    how= A string or array of strings containing any of "flight", "line",
      "channel", or "digitizer". This specifies how DATA will be broken up into
      segments. Each segment gets its own color.
        how="line"                Break data into flight lines (default)
        how="channel"             Break data up by channel
        how=["line","channel"]    Break data up by lines and by channels
    win= Window to plot in.
    msize= Size to use for plotted points.
    marker= Marker to use for plotted points.
    connect= Set to connect=1 to draw a polyline in addition to the points.
*/
  // Break the data up into segments
  segs = split_data(data, how);

  colors = ["black", "red", "blue", "green", "magenta", "yellow", "cyan"];
  ncolors = numberof(colors);

  wbkp = current_window();
  if(!is_void(win)) window, win;
  if(xfma) fma;

  local x, y, z, rx, ry;
  for(i = 1; i <= segs(*); i++) {
    color = colors(i % ncolors);
    seg = segs(noop(i));
    data2xyz, seg, x, y, z, mode=mode;
    project_points_to_line, line, x, y, rx, ry;

    date = soe2date(seg.soe(1));
    sodmin = soe2somd(seg.soe(1));
    sodmax = soe2somd(seg.soe(0));
    soddif = sodmax-sodmin;
    hms = sod2hms(soe2sod(seg.soe(1)), str=1);

    // If tans data is available, grab the heading
    heading = 0.;
    if(!is_void(tans)) {
      tansdif = abs(tans.somd - sodmin);
      w = tansdif(mnx);
      if(tansdif(w) < 0.01)
        heading = tans(w).heading;
    }

    write, format="%s sod = %8.2f:%8.2f (%7.3f) utc=%s %5.1f %s\n"
      date, sodmin, sodmax, soddif, hms, heading, color;

    if(connect)
      plg, z, rx, color=color;
    plmk, z, rx, color=color, msize=msize, width=10, marker=marker;
  }

  window_select, wbkp;
}

func mtransect(data, iwin=, owin=, w=, connect=, recall=, color=, xfma=,
mode=, show=, msize=, expect=, marker=) {
/* DOCUMENT mtransect(data, iwin=, owin=, w=, connect=, recall=, color=, xfma=,
   mode=, show=, msize=, expect=, marker=)

  Mouse selected transect. mtransect allows you to "drag out" a line within an
  ALPS topo display window and then create a new graph of all of the points
  near the line.

  To recall a transect line, call mtransect with the recall= parameter and set
  it to:
    0 for the most recent line
    -1 for the previous line
    -2 for the one before that, etc.

  Input:
  data       :  Variable to process
  owin=      :  Desired Yorick output graph window.       Default is 3
  iwin=      :  Source window for transect.               Default is 5
  w=         :  Search distance from line in centimeters. Default is 150cm
  connect=   :  Set to 1 to connect the points.
  recall=    :  Used to recall a previously generated transact line.
  color=     :  The starting color 1:7, use negative to use only 1 color
  xfma=      :  Set to 1 to auto fma.
  mode=      :  Data mode:
          mode="fs"  first surface
          mode="be"  bare earth
          mode="ba"  bathy
  show=      :  Set to 1 to plot the transect in window, win.
  msize=     :  set msize value (same as plcm, etc.), default = .1
  marker=    :  set marker value (same as plcm, etc.), default = 1

  Examples:

  g = mtransect(fs_all, connect=1, xfma=1)

    - use fs_all as data source
    - connect the dots in the output plot
    - rcf filter the output with a 1.0 meter filter width and use 5 points on
      either side of each point as the jury pool
    - auto fma
    - returns the index of the selected points in g
    - this example expects you to generate the line segment with the mouse

  g = mtransect(fs_all, connect=1, xfma=1, recall=0)

  This example is the same as above, except:
  - the transect line is taken from the global transect_history array

  SEE ALSO: transect, _transect_history
*/
  extern _transect_history, transect_line;

  default, mode, "fs";
  default, w, 150;
  default, connect, 0;
  default, owin, 3;
  default, iwin, 5;
  default, msize, 0.1;
  default, xfma, 0;
  default, color, 2;  // start at red, not black

  wbkp = current_window();

  if(is_void(recall)) {
    window, iwin;
    line = transect_line = mouse(1, 2, "")(1:4);
    if(show)
      transect_plot_line, line, win=iwin;
    window_select, wbkp;

    grow, _transect_history, [list];
  } else {
    line = transect_line = transect_recall(recall);
  }

  if(recall) {
    window, owin;
    lims = limits();
  }
  data = transect(data, line, connect=connect, color=color, xfma=xfma,
    mode=mode, owin=owin, lw=w, msize=msize, marker=marker);

  // plot the actual points selected onto the input window
  if(show == 2) {
    local x, y;
    data2xyz, data, x, y, mode=mode;
    window, iwin;
    plmk, y, x, msize=msize, marker=marker, color="black",
      width=10;
  }
  // this only redraws the last transect selected.
  if(show == 3) {
    transect_plot_line, line, win=iwin;
  }

  window, owin;
  if(recall) {
    limits, lims(1),lims(2), lims(3), lims(4);
  } else {
    limits;
  }
  window_select, wbkp;
  if(!is_void(expect))
    write, format="%s\n", "END mtransect:";

  return data;
}

func transect(data, line, lw=, connect=, msize=, xfma=, owin=, color=,
mode=, marker=) {
/* DOCUMENT transect(data, line, lw=, connect=, msize=, xfma=, owin=,
   color=, mode=, marker=)

  Input:
  data       :  Data where you drew the line
  line       :  Coordinates for transect in meters as [x1,y1,x2,y2]
  lw=        :  Search distance either side of the line in centimeters
  xfma=      :  Set to 1 to clear screen
  owin=      :  Set output window
  color=     :  Select starting color, 1-7, use negative to use only 1 color
  mode=      :  Data mode:
          mode="fs"  first surface
          mode="be"  bare earth
          mode="ba"  bathy
  msize      :  set msize value (same as plcm, etc.), default = .1
  marker     :  set marker value (same as plcm, etc.), default = 1

  SEE ALSO: mtransact, _transect_history
*/
  default, mode, "fs";
  default, rtn, 0;    // first return
  default, lw, 150;   // search width, cm
  default, owin, 3;
  default, msize, 0.1;
  default, marker, 1;

  // lw is the transect width. Except it's actually only half the transect
  // width, and it's in cm. So double, then convert to m.
  lw = (lw*2)/100.;

  // Clean up data
  data = test_and_clean(data);

  if(!numberof(data)) {
    write, "No points remain after test_and_clean";
    return;
  }

  // Reduce data to just the portion within the transect
  ply = line_to_poly(line(1), line(2), line(3), line(4), width=lw/100.);
  data = data_in_poly(data, ply, mode=mode);

  if(!numberof(data)) {
    write, "No points along specified transect line";
    return;
  }

  transect_plot_points, line, data, how="line", win=owin, msize=msize,
    marker=marker, connect=connect;

  window_select, wbkp;
  return data;
}

func transect_pixelwf_interactive(vname, line, win=) {
/* DOCUMENT transect_pixelwf_interactive, vname, line, win=
  Enters an interactive query mode similar to pixelwf_interactive, except that
  it queries a transect plot. VNAME should be the name of the variable
  containing the points plotted, LINE should be the transect they're plotted
  with respect to, and WIN should be the window they're plotted in.
*/
  if(is_void(win)) win = window();
  data = var_expr_get(vname);

  // Pull out data coordinates
  local x, y, z, rx, ry;
  data2xyz, data, x, y, z, mode=mode;
  project_points_to_line, line, x, y, rx, ry;

  // The window we're clicking in has RX along its X axis and Z along its Y
  // axis.

  wbkp = current_window();

  continue_interactive = 1;
  while(continue_interactive) {
   write, format="\nWindow %d: Left-click to examine a point. Anything else aborts.\n", win;

    window, win;
    spot = mouse(1, 1, "");

    if(mouse_click_is("left", spot)) {
      write, format="\n-----\n\n%s", "";
      nearest = transect_pixelwf_find_point(spot, data, rx, z);
      if(is_void(nearest.point)) {
        write, format="Location clicked: %9.2f %10.2f\n", spot(1), spot(2);
        write, format="No point found within search radius (%.2fm).\n",
          pixelwfvars.selection.radius;
      } else {
        pixelwf_set_point, nearest.point;
        plmk, nearest.y, nearest.x, msize=0.004, color="red",
          marker=[[0,1,0,1,0,-1,0,-1,0],[0,1,0,-1,0,-1,0,1,0]];
        tkcmd, "::misc::idle {ybkg pixelwf_plot}";
        pixelwf_selected_info, nearest, vname=vname;
      }
    } else {
      continue_interactive = 0;
    }
  }

  window_select, wbkp;
}

func transect_pixelwf_find_point(spot, data, x, y) {
/* DOCUMENT transect_pixelwf_find_point(spot, data, x, y)
  Utility function for transect_pixelwf_interactive. Given SPOT (a mouse click
  result), DATA (a point cloud), and X,Y (the coordiantes in the plot that
  correspond to the points in DATA), this returns a various info about the
  closest point to SPOT.
*/
  extern pixelwfvars;
  vars = pixelwfvars.selection;
  radius = vars.radius;

  bbox = spot([1,1,2,2]) * radius * [-1,1,-1,1];
  w = data_box(x, y, bbox);

  distance = index = point = [];
  if(numberof(w)) {
    d = sqrt((x-spot(1))^2 + (y-spot(2))^2);
    if(d(min) <= radius) {
      distance = d(min);
      index = w(d(mnx));
      point = data(index);
      nx = x(d(mnx));
      ny = y(d(mnx));
    }
  }

  return save(point, index, distance, spot, x=nx, y=ny);
}
