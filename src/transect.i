// vim: set ts=2 sts=2 sw=2 ai sr et:

extern _transect_history;
/* DOCUMENT _transect_history

  A stack of recent transect lines generated by calls to "mtransect."
  These can be recalled repeatly with the transact command.

  For example, to recall the last mouse_transect with transect you would:

    transect( fs_all, _transect_history(,0), ..... )

  To recall the one before last, use:

    transect( fs_all, _transect_history(,-1), ..... )
*/

func mtransect(data, iwin=, owin=, w=, connect=, recall=, color=, xfma=,
mode=, rtn=, show=, msize=, expect=, marker=) {
/* DOCUMENT mtransect(data, iwin=, owin=, w=, connect=, recall=, color=, xfma=,
   mode=, rtn=, show=, msize=, expect=, marker=)

  Mouse selected transect. mtransect allows you to "drag out" a line within an
  ALPS topo display window and then create a new graph of all of the points
  near the line.

  To recall a transect line, call mtransect with the recall= parameter and set
  it to:
    0 for the most recent line
    -1 for the previous line
    -2 for the one before that, etc.

  Input:
  data       :  Variable to process
  owin=      :  Desired Yorick output graph window.       Default is 3
  iwin=      :  Source window for transect.               Default is 5
  w=         :  Search distance from line in centimeters. Default is 150cm
  connect=   :  Set to 1 to connect the points.
  recall=    :  Used to recall a previously generated transact line.
  color=     :  The starting color 1:7, use negative to use only 1 color
  xfma=      :  Set to 1 to auto fma.
  mode=      :  Data mode:
          mode="fs"  first surface
          mode="be"  bare earth
          mode="ba"  bathy
  rtn=       :  Deprecated; use mode= instead. This is ignored if mode= is
    present. Select return type where:
          0  first return
          1  veg last return
          2  submerged topo
  show=      :  Set to 1 to plot the transect in window, win.
  msize=     :  set msize value (same as plcm, etc.), default = .1
  marker=    :  set marker value (same as plcm, etc.), default = 1

  Examples:

  g = mtransect(fs_all, connect=1, xfma=1)

    - use fs_all as data source
    - connect the dots in the output plot
    - rcf filter the output with a 1.0 meter filter width and use 5 points on
      either side of each point as the jury pool
    - auto fma
    - returns the index of the selected points in g
    - this example expects you to generate the line segment with the mouse

  g = mtransect(fs_all, connect=1, xfma=1, recall=0)

  This example is the same as above, except:
  - the transect line is taken from the global transect_history array

  SEE ALSO: transect, _transect_history
*/
  extern _transect_history, transect_line;

  default, w, 150;
  default, connect, 0;
  default, owin, 3;
  default, iwin, 5;
  default, msize, 0.1;
  default, xfma, 0;
  default, color, 2;  // start at red, not black

  // Handle the complexities of having a deprecated rtn= option and a
  // non-deprecated mode= option.
  if(is_void(mode)) {
    if(!is_void(rtn)) {
      if(logger(warn))
        logger, warn, "call to transect using deprecated option rtn=";
    } else {
      rtn = 0;
    }
    mode = ["fs","be","ba"](rtn+1);
  }

  wbkp = current_window();

  if(is_void(recall)) {
    window, iwin;
    line = transect_line = mouse(1, 2, "")(1:4);
    if(show)
      plg, [line(2),line(4)], [line(1),line(3)], width=2.0, color="red";
    window_select, wbkp;

    grow, _transect_history, [list];
  } else {
    // Make sure recall is negative
    recall = -abs(recall);
    if(is_void(_transect_history)) {
      write, "No lines in _transect_history";
      return;
    }
    if(abs(recall) >= dimsof(_transect_history)(3)) {
      write, "Requested line exceeds history in _transect_history";
      return;
    }
    line = transect_line = _transect_history(,recall);
  }

  if(recall) {
    window, owin;
    lims = limits();
  }
  data = transect(data, line, connect=connect, color=color, xfma=xfma,
    mode=mode, owin=owin, lw=w, msize=msize, marker=marker);

  // plot the actual points selected onto the input window
  if(show == 2) {
    local x, y;
    data2xyz, data, x, y, mode=mode;
    window, iwin;
    plmk, y, x, msize=msize, marker=marker, color="black",
      width=10;
  }
  // this only redraws the last transect selected.
  if(show == 3) {
    window, iwin;
    plg, [line(2),line(4)], [line(1),line(3)], width=2.0, color="red";
  }

  window, owin;
  if(recall) {
    limits, lims(1),lims(2), lims(3), lims(4);
  } else {
    limits;
  }
  window_select, wbkp;
  if(!is_void(expect))
    write, format="%s\n", "END mtransect:";

  return data;
}

func transect(data, line, lw=, connect=, msize=, xfma=, owin=, color=,
mode=, rtn=, marker=) {
/* DOCUMENT transect(data, line, lw=, connect=, msize=, xfma=, owin=,
   color=, mode=, rtn=, marker=)

  Input:
  data       :  Data where you drew the line
  line       :  Coordinates for transect in meters as [x1,y1,x2,y2]
  lw=        :  Search distance either side of the line in centimeters
  xfma=      :  Set to 1 to clear screen
  owin=      :  Set output window
  color=     :  Select starting color, 1-7, use negative to use only 1 color
  mode=      :  Data mode:
          mode="fs"  first surface
          mode="be"  bare earth
          mode="ba"  bathy
  rtn=       :  Deprecated; use mode= instead. This is ignored if mode= is
    present. Select return type where:
          0  first return
          1  veg last return
          2  submerged topo
  msize      :  set msize value (same as plcm, etc.), default = .1
  marker     :  set marker value (same as plcm, etc.), default = 1

  SEE ALSO: mtransact, _transect_history
*/
  extern rx, elevation, glst, llst, segs;

  default, rtn, 0;    // first return
  default, lw, 150;   // search width, cm
  default, owin, 3;
  default, msize, 0.1;
  default, marker, 1;

  // Handle the complexities of having a deprecated rtn= option and a
  // non-deprecated mode= option.
  if(is_void(mode)) {
    if(!is_void(rtn)) {
      if(logger(warn))
        logger, warn, "call to transect using deprecated option rtn=";
    } else {
      rtn = 0;
    }
    mode = ["fs","be","ba"](rtn+1);
  }

  // lw is the transect width. Except it's actually only half the transect
  // width, and it's in cm. So double, then convert to m.
  lw = (lw*2)/100.;

  // Clean up data
  data = test_and_clean(data);

  if(!numberof(data)) {
    write, "No points remain after test_and_clean";
    return;
  }

  // Reduce data to just the portion within the transect
  ply = line_to_poly(line(1), line(2), line(3), line(4), width=lw/100.);
  data = data_in_poly(data, ply, mode=mode);

  if(!numberof(data)) {
    write, "No points along specified transect line";
    return;
  }

  // Compute the angle needed to rotate the data to run east-to-west
  angle = atan(line(2)-line(4), line(1)-line(3));
  ca = cos(-angle);
  sa = sin(-angle);

  // Break the data up into segments
  segs = split_data(data, "line");

  colors = ["black", "red", "blue", "green", "magenta", "yellow", "cyan"];
  // Convert string to number
  if(is_string(color))
    color = where(color == colors)(1);
  if(is_integer(color)) {
    // Put the selected color first in the list
    colors = roll(colors, 1-abs(color));
    // If color is negative, then use ONLY that color
    if(color < 0)
      colors = colors(:1);
  }
  ncolors = numberof(colors);
  // Blank out color, we'll be re-using it for something else later
  color = [];

  wbkp = current_window();
  window, owin, wait=1;
  if(xfma) fma;

  local x, y, z;
  for(i = 1; i <= segs(*); i++) {
    color = colors(i % ncolors);
    seg = segs(noop(i));
    data2xyz, seg, x, y, z, mode=mode;

    // Project line to run along X axis, east to west
    x -= line(1);
    y -= line(2);
    rx = x*ca + y*sa;
    ry = x*sa + y*ca;

    date = soe2date(seg.soe(1));
    sodmin = soe2somd(seg.soe(1));
    sodmax = soe2somd(seg.soe(0));
    soddif = sodmax-sodmin;
    hms = sod2hms(soe2sod(seg.soe(1)), str=1);

    // If tans data is available, grab the heading
    heading = 0.;
    if(!is_void(tans)) {
      tansdif = abs(tans.somd - sodmin);
      w = tansdif(mnx);
      if(tansdif(w) < 0.01)
        heading = tans(w).heading;
    }

    write, format="%s sod = %8.2f:%8.2f (%7.3f) utc=%s %5.1f %s\n"
      date, sodmin, sodmax, soddif, hms, heading, color;

    plmk, z, rx, color=color, msize=msize, width=10, marker=marker;
    if(connect)
      plg, z, rx, color=color;
  }

  window_select, wbkp;
  return data;
}

func transrch(data, m, llst, _rx=, _el=, spot=, iwin=, mode=, disp_type=) {
/* DOCUMENT transrch(data, m, llst, _rx=, _el=, spot=, iwin=, mode=, disp_type=)
  Searches for the point in the transect plot window iwin (default 3) nearest
  to where the user clicks.

  The selected point is highlighted red in the transect window and as a blue
  circle on the topo (5) window.

  Windows showing the raster and pixel waveform are displayed.

  Text is displayed in the console window showing details on the point
  selected.

  Input:
    data        : Variable to process, must be of type FS.
                  use fs=test_and_clean(fs_all) to create
    m           : is the result from a call to mtransect()
    llst        : internal variable created from mtransect()

  To use, first generate a transect with these steps:

    cln_fs = test_and_clean(fs)
    m = mtransect(cln_fs, show=1);

    transrch, cln_fs, fs, llst;
*/
  //     1        2      3       4        5          6         7
  clr = ["black", "red", "blue", "green", "magenta", "yellow", "cyan" ];

  wbkp = current_window();

  extern mindata;
  extern _last_transrch;
  if(!is_void(_rx)) rx = _rx;
  if(!is_void(_el)) elevation = _el;
  default, _last_transrch, [0.0, 0.0, 0.0, 0.0];
  default, iwin, 3;

  if(is_void(mode)) {
    if(!is_void(disp_type)) {
      if(logger(warn))
        logger, warn, "call to transect using deprecated option disp_type=";
    } else {
      disp_type = 0;
    }
    mode = ["fs","be","ba"](disp_type+1);
  }

  // xyzzy - this assumes the default iwin for transect
  window, iwin;
  // m is the result from mtransect()
  // llst is an extern from transect()
  xx = rx(llst) / 100.;
  yy = elevation(m) / 100.;
  if(is_void(spot)) spot = mouse();
  write, format="mouse :       : %f %f\n", spot(1), spot(2);

  if(1) {   // the yorick way - rwm
    lims = limits();

    dx = spot(1)-xx;
    // need to normalize the x and y values
    dx = dx / (lims(2) - lims(1));
    dx = dx^2;
    dy = spot(2)-yy;
    dy = dy / (lims(4) - lims(3));
    dy = dy^2;
    dd = dx+dy;
    dd = sqrt(dd);
    minindx = dd(mnx);

  } else {  // non-yorick way
    // copied from raspulsrch(), useful for debugging
    qy = where(yy     > spot(2) -   2.5 & yy     < spot(2) +   2.5);
    qx = where(xx(qy) > spot(1) - 500.0 & xx(qy) < spot(1) + 500.0);

    // Does this really differ from qx?
    indx = qy(qx);
    write, format="searching %d points\n", numberof(indx);

    if(is_array(indx)) {
      mindist = 999999;
      for(i = 1; i < numberof(indx); i++) {
        dist = sqrt(((spot(1) - xx(indx(i)))^2) + ((spot(2) - yy(indx(i)))^2));
        x = [xx(i), xx(i)];
        y = [yy(i), yy(i)];
        plg, y, x, width=8.0, color="green";
        if(dist < mindist) {
          mindist = dist;
          minindx = indx(i);
          x = [xx(minindx), xx(minindx)];
          y = [yy(minindx), yy(minindx)];
          plg, y, x, width=9.0, color="blue";
        }
      }
    }
  } // end of the non-yorick way

  // Now we have the x/y values of the nearest transect point.
  // From here we need to find the original data value
  write, format="Result: %6d: %f %f\n", minindx, xx(minindx), yy(minindx);
  x = [xx(minindx), xx(minindx)];
  y = [yy(minindx), yy(minindx)];

  // We want to determine which segment a point is from so that we can redraw
  // it in that color.

  // Made segs extern in transect.i
  // 2008-11-25: wonder why i did that. must be computed here so we can
  // have multiple transects - rwm
  segs = where(abs(data.soe(m)(dif)) > 5.0);
  // there must be a better way.
  for(i = 1, col = 0; i <= numberof(segs); i++) {
    if(segs(i) < minindx)
      col = i;
  }

  // just is.
  col += 2;
  col = col % 7;
  write, format="color=%s\n", clr(col);
  // highlight selected point in iwin
  plg, y, x, width=10.0, color=clr(col);

  mindata = data(m(minindx));
  pixelwf_set_point, mindata;
  rasterno = mindata.rn&0xFFFFFF;
  pulseno = mindata.rn/0xFFFFFF
  hms = sod2hms(soe2sod(mindata.soe));
  write, format="Indx  : %6d HMS: %02d%02d%02d  Raster/Pulse: %d/%d FS UTM: %7.1f, %7.1f\n",
    minindx, hms(1), hms(2), hms(3), rasterno, pulseno, mindata.north/100.0,
    mindata.east/100.0;
  show_track, mindata, utm=1, skip=0, color=clr(col), win=5, msize=.5;
  window, 1, wait=1;
  fma;
  rr = decode_raster(rn=rasterno);
  write, format="soe: %d  rn: %d  dgtz: %d  np: %d\n",
    rr.soe, rr.rasternbr, rr.digitizer, rr.npixels;

  // Now lets display the waveform
  show_wf, rasterno, pulseno, win=0, cb=7;
  limits;

  mindata_dump_info, edb, mindata, minindx, last=_last_transrch,
    ref=_transrch_reference;

  _last_transrch = data2xyz(mindata, mode=mode);

  window_select, wbkp;
}

func mtransrch(data, m, llst, _rx=, _el=, spot=, iwin=, mode=, disp_type=,
ptype=, fset=) {
/* DOCUMENT mtransrch(data, m, llst, _rx=, _el=, spot=, iwin=, mode=,
   disp_type=, ptype=, fset=)
  Call transrch repeatedly until the user clicks the right mouse button.
  Should work similar to Pixel Waveform.

  To use, first generate a transect with these steps:

    cln_fs = test_and_clean(fs_all)
    m = mtransect(cln_fs, show=1);
    mtransrch, cln_fs, fs, llst;
*/
  wbkp = current_window();

  extern _last_transrch, _transrch_reference;

  default, _last_transrch, [0.0, 0.0, 0.0];
  default, _last_soe, 0;
  default, iwin, 3;
  default, ptype, 0;      // fs topo
  default, msize, 1.0;
  default, fset, 0;
  default, buf, 1000;     // 10 meters

  if(is_void(mode)) {
    if(!is_void(disp_type)) {
      if(logger(warn))
        logger, warn, "call to transect using deprecated option disp_type=";
    } else {
      disp_type = 0;
    }
    mode = ["fs","be","ba"](disp_type+1);
  }

  if(is_pointer(data)) data = *data(1);

  // the data must be clean coming in, otherwise the index do not match the
  // data.
  data = test_and_clean(data);

  rtn_data = [];
  nsaved = 0;

  do {
    write, format="Window: %d. Left: examine point, Center: set reference, Right: quit\n", iwin;
    window, iwin;

    spot = mouse(1,1, "");
    if(mouse_click_is("right", spot)) break;

    if(mouse_click_is("ctrl+left", spot)) {
      grow, finaldata, mindata;
      write, format="\007Point appended to finaldata.  Total saved = %d\n",
        ++nsaved;
    }

    transrch, data, m, llst, _rx=_rx, _el=_el, spot=spot, iwin=iwin;

    if(mouse_click_is(["middle", "shift+left"], spot)) {
      _transrch_reference = data2xyz(mindata, mode=mode);
    }

    mdata = data2xyz(mindata, mode=mode);

    if(is_void(_transrch_reference)) {
      write, "No Reference Point Set";
    } else {
      delta = mdata - _transrch_reference;
      dist = sqrt((mdata(1:2)^2)(sum));
      write, format="   Ref. Dist: %.2fm  Elev diff: %.2fm\n", dist, delta(3);
    }
  } while(!mouse_click_is("right", spot));

  window_select, wbkp;
}

func mindata_dump_info(edb, mindata, minindx, last=, ref=) {
/* DOCUMENT mindata_dump_info, edb, mindata, minindx, last=, ref=

  NEEDS DOCUMENTATION
*/
  if(is_void(ref)) last = [0.0, 0.0, 0.0, 0.0];
  if(!is_array(edb)) {
    write, "edb is not set, try again";
    return;
  }

  rasterno = mindata.rn&0xffffff;
  pulseno = mindata.rn>>24;
  _last_soe = edb(mindata.rn&0xffffff).seconds;

  somd = edb(mindata.rn&0xffffff).seconds % 86400;
  rast = decode_raster(get_erast(rn=rasterno));

  fsecs = rast.offset_time - edb(mindata.rn&0xffffff).seconds;
  ztime = soe2time(somd);
  zdt = soe2time(abs(edb(mindata.rn&0xffffff).seconds - _last_soe));

  if(is_array(tans) && is_array(pnav)) {
    pnav_idx = abs(pnav.sod - somd)(mnx);
    tans_idx = abs(tans.somd - somd)(mnx);
    knots = lldist(pnav(pnav_idx).lat, pnav(pnav_idx).lon,
      pnav(pnav_idx+1).lat, pnav(pnav_idx+1).lon) *
      3600.0/abs(pnav(pnav_idx+1).sod - pnav(pnav_idx).sod);
  }

  write, "\n=============================================================";
  write, format="                  Raster/Pulse: %d/%d UTM: %7.1f, %7.1f\n",
    mindata.rn&0xffffff, pulseno, mindata.north/100.0, mindata.east/100.0;

  if(is_array(edb)) {
    write, format="        Time: %7.4f (%02d:%02d:%02d) Delta:%d:%02d:%02d \n",
      double(somd)+fsecs(pulseno), ztime(4), ztime(5), ztime(6), zdt(4),
      zdt(5), zdt(6);
  }
  if(is_array(tans) && is_array(pnav)) {
    write, format="    GPS Pdop: %8.2f  Svs:%2d  Rms:%6.3f Flag:%d\n",
      pnav(pnav_idx).pdop, pnav(pnav_idx).sv, pnav(pnav_idx).xrms,
      pnav(pnav_idx).flag;
    write, format="     Heading:  %8.3f Pitch: %5.3f Roll: %5.3f %5.1fm/s %4.1fkts\n",
      tans(tans_idx).heading, tans(tans_idx).pitch, tans(tans_idx).roll,
      knots * 1852.0/3600.0, knots;
  }

  hy = sqrt(double(mindata.melevation - mindata.elevation)^2 +
      double(mindata.meast - mindata.east)^2 +
      double(mindata.mnorth - mindata.north)^2);

  if((mindata.melevation > mindata.elevation) && (mindata.elevation > -100000))
    aoi = acos((mindata.melevation - mindata.elevation) / hy) * RAD2DEG;
  else
    aoi = -9999.999;
  write, format="Scanner Elev: %8.2fm   Aoi:%6.3f Slant rng:%6.3f\n",
    mindata.melevation/100.0, aoi, hy/100.0;

  write, format="First Surface elev: %8.2fm Delta: %7.2fm\n",
    mindata.elevation/100.0, mindata.elevation/100.0 - last(3);

  if(structeq(structof(mindata(1)), FS)) {
    fs_chn_used = eaarl_intensity_channel(mindata.intensity);
    write, format="First Surface channel / intensity: %d / %3d\n",
      fs_chn_used, mindata.intensity;
  }

  if(structeq(structof(mindata(1)), VEG__)) {
    fs_chn_used = eaarl_intensity_channel(mindata.fint);
    be_chn_used = eaarl_intensity_channel(mindata.lint);

    write, format="Last return elev: %8.2fm Delta: %7.2fm\n",
      mindata.lelv/100., mindata.lelv/100.-last(4);
    write, format="First/Last return elv DIFF: %8.2fm\n",
      (mindata.elevation-mindata.lelv)/100.;
    write, format="First Surface channel-intensity: %d-%3d\n",
      fs_chn_used, mindata.fint;
    write, format="Last Surface channel-intensity: %d-%3d\n",
      be_chn_used, mindata.lint;
  }

  if(structeq(structof(mindata(1)), GEO)) {
    fs_chn_used = eaarl_intensity_channel(mindata.first_peak);
    be_chn_used = eaarl_intensity_channel(mindata.bottom_peak);

    write, format="Bottom elev: %8.2fm Delta: %7.2fm\n",
      (mindata.elevation+mindata.depth)/100.,
      (mindata.elevation+mindata.depth)/100.-last(4);
    write, format="First/Bottom return elv DIFF: %8.2fm", mindata.depth/100.;
    write, format="Surface channel-intensity: %d-%3d\n", fs_chn_used,
      mindata.first_peak;
    write, format="Bottom channel / intensity: %d-%3d\n", be_chn_used,
      mindata.bottom_peak;
  }

  write, "=============================================================\n";
}
