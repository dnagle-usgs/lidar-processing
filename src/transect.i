// vim: set ts=2 sts=2 sw=2 ai sr et:

extern _transect_history;
/* DOCUMENT _transect_history

  A stack of recent transect lines generated by calls to "mtransect."
  These can be recalled repeatly with the transact command.

  For example, to recall the last mouse_transect with transect you would:

    transect( fs_all, _transect_history(,0), ..... )

  To recall the one before last, use:

    transect( fs_all, _transect_history(,-1), ..... )
*/

func mtransect(data, iwin=, owin=, w=, connect=, recall=, color=, xfma=,
mode=, rtn=, show=, msize=, expect=, marker=) {
/* DOCUMENT mtransect(data, iwin=, owin=, w=, connect=, recall=, color=, xfma=,
   mode=, rtn=, show=, msize=, expect=, marker=)

  Mouse selected transect. mtransect allows you to "drag out" a line within an
  ALPS topo display window and then create a new graph of all of the points
  near the line.

  To recall a transect line, call mtransect with the recall= parameter and set
  it to:
    0 for the most recent line
    -1 for the previous line
    -2 for the one before that, etc.

  Input:
  data       :  Variable to process
  owin=      :  Desired Yorick output graph window.       Default is 3
  iwin=      :  Source window for transect.               Default is 5
  w=         :  Search distance from line in centimeters. Default is 150cm
  connect=   :  Set to 1 to connect the points.
  recall=    :  Used to recall a previously generated transact line.
  color=     :  The starting color 1:7, use negative to use only 1 color
  xfma=      :  Set to 1 to auto fma.
  mode=      :  Data mode:
          mode="fs"  first surface
          mode="be"  bare earth
          mode="ba"  bathy
  rtn=       :  Deprecated; use mode= instead. This is ignored if mode= is
    present. Select return type where:
          0  first return
          1  veg last return
          2  submerged topo
  show=      :  Set to 1 to plot the transect in window, win.
  msize=     :  set msize value (same as plcm, etc.), default = .1
  marker=    :  set marker value (same as plcm, etc.), default = 1

  Examples:

  g = mtransect(fs_all, connect=1, xfma=1)

    - use fs_all as data source
    - connect the dots in the output plot
    - rcf filter the output with a 1.0 meter filter width and use 5 points on
      either side of each point as the jury pool
    - auto fma
    - returns the index of the selected points in g
    - this example expects you to generate the line segment with the mouse

  g = mtransect(fs_all, connect=1, xfma=1, recall=0)

  This example is the same as above, except:
  - the transect line is taken from the global transect_history array

  SEE ALSO: transect, _transect_history
*/
  extern _transect_history, transect_line;

  default, w, 150;
  default, connect, 0;
  default, owin, 3;
  default, iwin, 5;
  default, msize, 0.1;
  default, xfma, 0;
  default, color, 2;  // start at red, not black

  // Handle the complexities of having a deprecated rtn= option and a
  // non-deprecated mode= option.
  if(is_void(mode)) {
    if(!is_void(rtn)) {
      if(logger(warn))
        logger, warn, "call to transect using deprecated option rtn=";
    } else {
      rtn = 0;
    }
    mode = ["fs","be","ba"](rtn+1);
  }

  wbkp = current_window();

  if(is_void(recall)) {
    window, iwin;
    line = transect_line = mouse(1, 2, "")(1:4);
    if(show)
      plg, [line(2),line(4)], [line(1),line(3)], width=2.0, color="red";
    window_select, wbkp;

    grow, _transect_history, [list];
  } else {
    // Make sure recall is negative
    recall = -abs(recall);
    if(is_void(_transect_history)) {
      write, "No lines in _transect_history";
      return;
    }
    if(abs(recall) >= dimsof(_transect_history)(3)) {
      write, "Requested line exceeds history in _transect_history";
      return;
    }
    line = transect_line = _transect_history(,recall);
  }

  if(recall) {
    window, owin;
    lims = limits();
  }
  data = transect(data, line, connect=connect, color=color, xfma=xfma,
    mode=mode, owin=owin, lw=w, msize=msize, marker=marker);

  // plot the actual points selected onto the input window
  if(show == 2) {
    local x, y;
    data2xyz, data, x, y, mode=mode;
    window, iwin;
    plmk, y, x, msize=msize, marker=marker, color="black",
      width=10;
  }
  // this only redraws the last transect selected.
  if(show == 3) {
    window, iwin;
    plg, [line(2),line(4)], [line(1),line(3)], width=2.0, color="red";
  }

  window, owin;
  if(recall) {
    limits, lims(1),lims(2), lims(3), lims(4);
  } else {
    limits;
  }
  window_select, wbkp;
  if(!is_void(expect))
    write, format="%s\n", "END mtransect:";

  return data;
}

func transect(data, line, lw=, connect=, msize=, xfma=, owin=, color=,
mode=, rtn=, marker=) {
/* DOCUMENT transect(data, line, lw=, connect=, msize=, xfma=, owin=,
   color=, mode=, rtn=, marker=)

  Input:
  data       :  Data where you drew the line
  line       :  Coordinates for transect in meters as [x1,y1,x2,y2]
  lw=        :  Search distance either side of the line in centimeters
  xfma=      :  Set to 1 to clear screen
  owin=      :  Set output window
  color=     :  Select starting color, 1-7, use negative to use only 1 color
  mode=      :  Data mode:
          mode="fs"  first surface
          mode="be"  bare earth
          mode="ba"  bathy
  rtn=       :  Deprecated; use mode= instead. This is ignored if mode= is
    present. Select return type where:
          0  first return
          1  veg last return
          2  submerged topo
  msize      :  set msize value (same as plcm, etc.), default = .1
  marker     :  set marker value (same as plcm, etc.), default = 1

  SEE ALSO: mtransact, _transect_history
*/
  extern rx, elevation, glst, llst, segs;

  default, rtn, 0;    // first return
  default, lw, 150;   // search width, cm
  default, owin, 3;
  default, msize, 0.1;
  default, marker, 1;

  // Handle the complexities of having a deprecated rtn= option and a
  // non-deprecated mode= option.
  if(is_void(mode)) {
    if(!is_void(rtn)) {
      if(logger(warn))
        logger, warn, "call to transect using deprecated option rtn=";
    } else {
      rtn = 0;
    }
    mode = ["fs","be","ba"](rtn+1);
  }

  // lw is the transect width. Except it's actually only half the transect
  // width, and it's in cm. So double, then convert to m.
  lw = (lw*2)/100.;

  // Clean up data
  data = test_and_clean(data);

  if(!numberof(data)) {
    write, "No points remain after test_and_clean";
    return;
  }

  // Reduce data to just the portion within the transect
  ply = line_to_poly(line(1), line(2), line(3), line(4), width=lw/100.);
  data = data_in_poly(data, ply, mode=mode);

  if(!numberof(data)) {
    write, "No points along specified transect line";
    return;
  }

  // Compute the angle needed to rotate the data to run east-to-west
  angle = atan(line(2)-line(4), line(1)-line(3));
  ca = cos(-angle);
  sa = sin(-angle);

  // Break the data up into segments
  segs = split_data(data, "line");

  colors = ["black", "red", "blue", "green", "magenta", "yellow", "cyan"];
  // Convert string to number
  if(is_string(color))
    color = where(color == colors)(1);
  if(is_integer(color)) {
    // Put the selected color first in the list
    colors = roll(colors, 1-abs(color));
    // If color is negative, then use ONLY that color
    if(color < 0)
      colors = colors(:1);
  }
  ncolors = numberof(colors);
  // Blank out color, we'll be re-using it for something else later
  color = [];

  wbkp = current_window();
  window, owin, wait=1;
  if(xfma) fma;

  local x, y, z;
  for(i = 1; i <= segs(*); i++) {
    color = colors(i % ncolors);
    seg = segs(noop(i));
    data2xyz, seg, x, y, z, mode=mode;

    // Project line to run along X axis, east to west
    x -= line(1);
    y -= line(2);
    rx = x*ca + y*sa;
    ry = x*sa + y*ca;

    date = soe2date(seg.soe(1));
    sodmin = soe2somd(seg.soe(1));
    sodmax = soe2somd(seg.soe(0));
    soddif = sodmax-sodmin;
    hms = sod2hms(soe2sod(seg.soe(1)), str=1);

    // If tans data is available, grab the heading
    heading = 0.;
    if(!is_void(tans)) {
      tansdif = abs(tans.somd - sodmin);
      w = tansdif(mnx);
      if(tansdif(w) < 0.01)
        heading = tans(w).heading;
    }

    write, format="%s sod = %8.2f:%8.2f (%7.3f) utc=%s %5.1f %s\n"
      date, sodmin, sodmax, soddif, hms, heading, color;

    plmk, z, rx, color=color, msize=msize, width=10, marker=marker;
    if(connect)
      plg, z, rx, color=color;
  }

  window_select, wbkp;
  return data;
}

func transect_pixelwf_interactive(vname, line) {
  data = var_expr_get(vname);

  // Compute the angle needed to rotate the data to run east-to-west
  angle = atan(line(2)-line(4), line(1)-line(3));
  ca = cos(-angle);
  sa = sin(-angle);

  // Pull out data coordinates
  local x, y, z;
  data2xyz, data, x, y, z, mode=mode;

  // Project line to run along X axis, east to west
  xt = x - line(1);
  yt = y - line(2);
  rx = xt*ca + yt*sa;
  ry = xt*sa + yt*ca;
  xt = yt = [];

  // The window we're clicking in has RX along its X axis and Z along its Y
  // axis.

  wbkp = current_window();

  continue_interactive = 1;
  while(continue_interactive) {
   write, format="\nWindow %d: Left-click to examine a point. Anything else aborts.\n", win;

    window, win;
    spot = mouse(1, 1, "");

    if(mouse_click_is("left", spot)) {
      write, format="\n-----\n\n%s", "";
      nearest = transect_pixelwf_find_point(spot, data, rx, z);
      if(is_void(nearest.point)) {
        write, format="Location clicked: %9.2f %10.2f\n", spot(1), spot(2);
        write, format="No point found within search radius (%.2fm).\n",
          pixelwfvars.selection.radius;
      } else {
        pixelwf_set_point, nearest.point;
        plmk, nearest.y, nearest.x, msize=0.004, color="red",
          marker=[[0,1,0,1,0,-1,0,-1,0],[0,1,0,-1,0,-1,0,1,0]];
        tkcmd, "::misc::idle {ybkg pixelwf_plot}";
        pixelwf_selected_info, nearest, vname=vname;
      }
    } else {
      continue_interactive = 0;
    }
  }

  window_select, wbkp;
}

func transect_pixelwf_find_point(spot, data, x, y) {
  extern pixelwfvars;
  vars = pixelwfvars.selection;
  radius = vars.radius;

  bbox = spot([1,1,2,2]) * radius * [-1,1,-1,1];
  w = data_box(x, y, bbox);

  distance = index = point = [];
  if(numberof(w)) {
    d = sqrt((x-spot(1))^2 + (y-spot(2))^2);
    if(d(min) <= radius) {
      distance = d(min);
      index = w(d(mnx));
      point = data(index);
      nx = x(d(mnx));
      ny = y(d(mnx));
    }
  }

  return save(point, index, distance, spot, x=nx, y=ny);
}
