/**********************************************************************

  $Id$
   Transect.i
   Original W. Wright 9/21/2003

  Contains:

    mtransect
     transect


*********************************************************************/

require, "rcf.i"

write, "$Id$"

extern _transect_history;
/* DOCUMENT _transect_history

  A stack of recent transect lines generated by calls to "mtransect."  These
can be recalled repeatly with the transact command. For example, to recall the 
last mouse_transect with transect you would:

  transect( fs_all, _transect_history(,0), ..... )

to recall the one before last, use:

 transect( fs_all, _transect_history(,-1), ..... )

*/

func mtransect( fs, iwin=,owin=, w=, connect=, recall=, color=, xfma=, rcf_parms=, rtn=, show= ) {
/* DOCUMENT mtransect( fs, iwin=,owin=, w=, connect=, recall=, color=, xfma= )

  mtransect allows you to "drag out" a line wihin an ALPS topo display
window and then create a new grah of all of the points near the line. 
The w= option lets you set the "search distance in meters" from the line.
The win= option is used to designate the window (default=5), and the 
connect= option specifies drawing lines to connect the points (default is
off).

To recall a transect line, just call mtransect with the recall= parameter
and set it to 0 for the most recent line, -1 for the previous line, -2 for
the one before that, etc. etc.


   Mouse selected transect. 
   fs       fs_all structure. 
  owin=     desired Yorick output graph window. Default 3.
  iwin=     Source window for transect Default 5.
   w=       search distance from line in centimeters. Default 150cm.
  connect=  set to 1 to connect the points.
  recall=    Used to recall a previously generated transact line.
  color=    The starting color 0:7
   xfma=    Do an fma.
   rtn=     Select return type where:
            0 first return
            1 veg last return
	    2 submerged topo
  show=     set to 1 if you want to plot the transect in window, win.

Examples:

  Use fs_all as data source, connect the dots in the output plot,
 rcf filter the output with a 1.0 meter filter width and use 5
 points on either side of each point as the jury pool, do an 
 fma. Also returns the index of the selected points in g. This
 example expects you to generate the line segment with the 
 mouse.

   g = mtransect(fs_all, connect=1, rcf_parms=[1.0, 5],xfma=1 )


 This example is the same as above, except the transect line is
 taken from the global transect_history array. 

g = mtransect(fs_all, connect=1, rcf_parms=[1.0, 5],xfma=1, recall=0 )

See also: transect, _transect_history

*/

 extern _transect_history;


 if ( is_void(rtn)   )    rtn = 0;		// default is first return
 if ( is_void(w))             w = 150;
 if ( is_void(connect)) connect = 0;
 if ( is_void(owin))       owin = 3;
 if ( is_void(iwin))       iwin = 5;
 if ( is_void(msize))     msize = 0.1;
 if ( is_void(xfma))        xfma= 0;
 if ( is_void(color))      color= 1;
 if ( is_void(rcf_parms))   rcf_parms = [];

 window,owin;
 lmts = limits();
 window,iwin; 
 if ( is_void(recall) ) {
// get the line coords with the mouse and convert to cm
  l = mouse(1, 2, "")(1:4)*100.0;
  if (show)
    plg, [l(2),l(4)]/100., [l(1),l(3)]/100., width=2.0, color="red";
  grow, _transect_history, [l]
 } else {
  if ( numberof(_transect_history) == 0 ) {
    write, "No transect lines in _transect_history";
    return;
  }
  if ( recall > 0 ) recall = -recall;
  l = _transect_history(, recall);
 }
  glst = transect( fs, l, connect=connect, color=color,xfma=xfma, rcf_parms=rcf_parms,rtn=rtn, owin=owin, lw=w );
  if ( is_void(recall) ) {
        limits
	limits,,, cbar.cmin, cbar.cmax
  } else 
	limits(lmts(1),lmts(2), lmts(3), lmts(4)); 
  return glst;
}

func transect( fs, l, lw=, connect=, xtime=, msize=, xfma=, owin=, color=, rcf_parms=,rtn= ) {
/* DOCUMENT transect( fs, l, lw=, connect=, xtime=, msize=, xfma=, owin=, color=,rtn= )

   fs       fs_all structure where you drew the line.
   l        the line (as given by mouse()).
   lw=      search distance either side of the line in centimeters.
   xtime=   1 to plot against time (sod)
   xfma=    set to clear screen
   owin=     output window
   color=   0-7 
  rcf_parms[fw,np] = wherefw is the width of the filter, and np is the number
            of points on either side of the index to use as a jury.
   rtn=     Select return type where:
            0 first return
            1 veg last return
	    2 submerged topo from bathy algo

 See also: mtransact, _transect_history

*/


 if ( is_void(rtn)   )    rtn = 0;		// default is first return
 if ( is_void(lw)    )    lw = 150;		// search width, cm
 if ( is_void(color) ) color = 0;		// 0 is first color
 if ( is_void(owin)   )   owin = 3;
 window,wait=1;
 window, owin;
 if ( !is_void(xfma) ) { 
   if ( xfma)  fma; 
 }


// determine the bounding box n,s,e,w coords
  n = l(2:4:2)(max);
  s = l(2:4:2)(min);
  w = l(1:3:2)(min);
  e = l(1:3:2)(max);

// compute the rotation angle needed to make the selected line
// run east west
  dnom = l(1)-l(3);
  if ( dnom != 0.0 ) 
    angle = atan( (l(2)-l(4)) / dnom ) ;
  else angle = pi/2.0;
//  angle ;
//  [n,s,e,w]


// build a matrix to select only the data withing the bounding box
  good = (fs.north(*) < n)  & ( fs.north(*) > s ) & (fs.east(*) < e ) & ( fs.east(*) > w );

// rotation:  x' = xcos - ysin
//            y' = ycos + xsin

/* Steps:
        1 translate data and line to 0,0
        2 rotate data and line 
        3 select desired data
*/

  glst = where(good);
  if ( numberof(glst) == 0 ) {
    write, "No points found along specified line";
    return ;
  }
    

  y = fs.north(*)(glst) - l(2);
  x = fs.east(*)(glst)  - l(1);

  ca = cos(-angle); sa = sin(-angle);

  rx = x*ca - y*sa
  ry = y*ca + x*sa

  llst = where( abs(ry) < lw );
  if ( rtn == 0 ) 
	  elevation = fs.elevation(*);
  else if ( rtn == 1 ) 
	  elevation = fs.lelv(*);
  else if ( rtn == 2 ) 
	  elevation = fs.elevation(*) + fs.depth(*);

//            1      2       3        4          5         6       7
  clr = ["black", "red", "blue", "green", "magenta", "yellow", "cyan" ];

  window,owin
  window,wait=1;
///  fma
  segs = where( abs(fs.soe(glst(llst))(dif)) > 5.0 );
  nsegs = numberof(segs)+1;
  if ( nsegs > 1 ) {
    ss = [];
    grow, ss,segs,[0];
    segs = ss;

    segs = segs(where( abs(segs(dif)) > 1.0 ));
    nsegs = numberof(segs)+1;
  }

 ss = [0];
 if ( nsegs > 1 ) { 
   grow, ss,segs

// "ss";ss
// "nsegs";nsegs
   for (i=1; i<numberof(ss); i++ ) {
      c = (color+i)&7;
   soeb = fs.soe(*)(glst(llst)(ss(i)+1));
      t = soe2time( soeb );
     tb = fs.soe(*)(glst(llst)(ss(i)+1))%86400;
     te = fs.soe(*)(glst(llst)(ss(i+1)))%86400;
     td = abs(te - tb);
     hms = sod2hms( tb );
     write, format="%d:%d sod = %6.2f:%-10.2f(%8.4f) utc=%2d:%02d:%02d %s\n",
                    t(1),t(2), tb, te, td, hms(1,), hms(2,), hms(3,), clr(c);

     if ( xtime ) {
     plmk, elevation(*)(glst(llst)(ss(i)+1:ss(i+1)))/100.0, 
           fs.soe(*)(llst)(ss(i)+1:ss(i+1))/100.0,color=clr(c), msize=msize
       if ( connect ) plg, elevation(*)(glst(llst)(ss(i)+1:ss(i+1)))/100.0, 
                fs.soe(*)(llst)(ss(i)+1:ss(i+1))/100.0,color=clr(c)
     } else {
     xx = rx(llst)(ss(i)+1:ss(i+1))/100.0;
     si = sort(xx);
     yy = elevation(glst(llst)(ss(i)+1:ss(i+1)))/100.0;
     if ( !is_void(rcf_parms) ) 
         si = si(moving_rcf(yy(si), rcf_parms(1), int(rcf_parms(2) ))); 
     plmk, yy(si), xx(si),color=clr(c), msize=msize
       if ( connect ) plg, yy(si), xx(si),color=clr(c)
    }
   }
 } else {
   xx = rx(llst)/100.0;
   yy = elevation(glst(llst))/100.0;
   si = sort(xx);
   if ( !is_void(rcf_parms) ) 
         si = si(moving_rcf(yy(si), rcf_parms(1), int(rcf_parms(2) ))); 
  plmk, yy(si),xx(si), color=clr(color), msize=msize, marker=1
  if ( connect ) plg, yy(si), xx(si),color=clr(color)
 }
// limits
// limits,,, cbar.cmin, cbar.cmax
 return glst(llst);
}

