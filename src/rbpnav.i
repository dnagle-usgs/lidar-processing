// vim: set ts=2 sts=2 sw=2 ai sr et:
/*
History:
   9/20/02  -ww Fixed problem where data_path was being overwritten
         when the pnav file was not located in "gps".
   1/21/02  Added automatic correction for gps time.
  11/17/01  Added raeggnav function to read precision gps
         data files generated by John Sonntag and Chreston.
  11/13/01  Modified to check/correct midnight rollover. -WW

  This program reads a binary file of precision GPS data generated by
  the pnav2ybin.c program.  The input data file begines with a single
  32 bit integer which contains the number of pnav sample points following
  it in the file.  The points which follow are binary values in the
  following structure:

 struct PNAV {
  short sv;
  short flag;
  float sod;
  float pdop;
  float alt;
  float xrms;
  float veast;
  float vnorth;
  float vup;
  double lat;
  double lon;
};


*/

struct PNAV {
  short sv;
  short flag;
  float sod;
  float pdop;
  //float hdop;		// egg data only
  float alt;
  float xrms;
  float veast;
  float vnorth;
  float vup;
  double lat;
  double lon;
};

struct EGGNAV {
  short yr;
  short day;
  float sod;
  double lat;
  double lon;
  float alt;
  float pdop;
  float hdop;
}

func raeggnav (junk) {
/* DOCUMENT raeggnav
  Read ASCII EGG precision navigation file.  This reads nav trajectories
  produced by John Sonntag or Chreston Martin.

  The data are returned as an array of structures of the form:

  struct EGGNAV {
    short yr;
    short day;
    float sod;
    double lat;
    double lon;
    float alt;
    float pdop;
    float hdop;
  }
*/
  extern data_path;
  if (is_void(data_path)) {
    data_path = rdline(prompt="Enter data path:");
  }

  path = data_path +"/gps/";
  ifn = select_file(path, pattern="\\.egg$");

  n = int(0);
  idf = open(ifn);

  // an array big enough to hold 24 hours at 10hz (76mb)
  // ncol = 11;
  ncol = 14;
  tmp = array( double, ncol, 864000);
  write,"Reading.........";
  s = rdline(idf);
  n = read(idf,format="%f", tmp) / ncol;
  egg = array( EGGNAV, n);
  egg.yr  = tmp(1,:n);
  egg.day = tmp(2,:n);
  egg.sod = tmp(3,:n);
  egg.lat = tmp(4,:n);
  egg.lon = tmp(5,:n) - 360.0;
  egg.alt = tmp(6,:n);
  egg.pdop = tmp(7,:n);
  egg.hdop = tmp(8,:n);
  write,format="\n\n    File:%s\n", ifn;
  write,format="Contains:%d points\n", dimsof(egg)(2);
  write,format="%s", "               Min          Max\n";
  write, format="  SOD:%14.3f %14.3f %6.2f hrs\n", egg.sod(min), egg.sod(max),
    (egg.sod(max) -egg.sod(min))/ 3600.0;
  write, format=" Pdop:%14.3f %14.3f\n", egg.pdop(min), egg.pdop(max);
  write, format="  Lat:%14.3f %14.3f\n", egg.lat(min), egg.lat(max);
  write, format="  Lon:%14.3f %14.3f\n", egg.lon(min), egg.lon(max);
  write, format="  Alt:%14.3f %14.3f\n", egg.alt(min), egg.alt(max);

  close,idf;
  return egg;
}

func precision_warning(verbose) {
  extern silence_precision_warning;
  default, verbose, 1;
  if(!silence_precision_warning && verbose && _ytk) {
    tkcmd, "tk_messageBox -icon warning -message { \
      The pnav file you have selected does not appear to be a precision \
      trajectory.  It should not be used in the production of final data \
      products or to assess accuracy of the system. \
    }";
  }
}

func load_pnav_ybin(fn, verbose=) {
  extern gps_time_correction;

  n = int(0);
  idf = open(fn, "rb");
  i86_primitives, idf;
  add_member, idf, "PNAV", -1, "sv", short;
  add_member, idf, "PNAV", -1, "flag", short;
  add_member, idf, "PNAV", -1, "sod", float;
  add_member, idf, "PNAV", -1, "pdop", float;
  add_member, idf, "PNAV", -1, "alt", float;
  add_member, idf, "PNAV", -1, "xrms", float;
  add_member, idf, "PNAV", -1, "veast", float;
  add_member, idf, "PNAV", -1, "vnorth", float;
  add_member, idf, "PNAV", -1, "vup", float;
  add_member, idf, "PNAV", -1, "lat", double;
  add_member, idf, "PNAV", -1, "lon", double;
  install_struct, idf, "PNAV";

  // get the integer number of records
  _read, idf,  0, n;

  ///  pnav = array( double, 12, n);
  pn   = array( PNAV, n);
  _read, idf, 4, pn;

  // check for time roll-over, and correct it
  q = where(pn.sod(dif) < 0);
  if(numberof(q)) {
    rng = q(1)+1:dimsof(pn.sod)(2);
    pn.sod(rng) += 86400;
  }

  if(is_void(gps_time_correction))
    determine_gps_time_correction, fn;
  pn.sod += gps_time_correction;

  if(verbose) {
    write,format="Applied GPS time correction of %f\n", gps_time_correction;
  }
  return pn;
}

func load_pnav_h5(fn) {
  if(is_void(py)) error, "python support not available";
  py, "import alps.load";
  data = py("alps.load.h5_gps_yo", fn)
  pn = array(PNAV, numberof(data.sv));
  for(i = 1; i <= data(*); i++) {
    set_member, pn, data(*,i), data(noop(i));
  }
  return pn;
}

func load_pnav(fn, verbose=) {
/* DOCUMENT load_pnav(fn, verbose=)

  Loads a GPS ("precision navigation") data file.

  Typically this is a .ybin file as written by pnav2ybin. However, this also
  accepts an HDF5 .h5 file as written using the Python alps.convert library.

  Returns an array with struct PNAV.
*/
  extern gps_time_correction;
  default, verbose, 1;

  if(!strmatch(fn,"-p-")) {
    precision_warning, verbose;
  }

  if(is_void(gps_time_correction))
    determine_gps_time_correction, fn;

  if(file_extension(fn) == ".h5") {
    pn = load_pnav_h5(fn);
  } else {
    pn = load_pnav_ybin(fn, verbose=verbose);
  }

  if(verbose) {
    write,format="%s", "               Min          Max\n";
    write, format="  SOW:%14.3f %14.3f %6.2f hrs\n", pn.sod(min), pn.sod(max),
      (pn.sod(max)-pn.sod(min))/ 3600.0;
    write, format=" Pdop:%14.3f %14.3f\n", pn.pdop(min), pn.pdop(max);
    write, format="  Lat:%14.3f %14.3f\n", pn.lat(min), pn.lat(max);
    write, format="  Lon:%14.3f %14.3f\n", pn.lon(min), pn.lon(max);
    write, format="  Alt:%14.3f %14.3f\n", pn.alt(min), pn.alt(max);
    write, format="  Rms:%14.3f %14.3f\n", pn.xrms(min), pn.xrms(max);
  }
  return pn;
}

func rbpnav(fn, verbose=) {
/* DOCUMENT rbpnav, "<fn>", verbose=
  Load PNAV data into the pnav and gga variables and sets pnav_filename.

  This is a wrapper around load_pnav that is intended to be used when loading
  the pnav for processing.
*/
  extern gga, pnav, pnav_filename, edb, soe_day_start;
  gga = pnav = load_pnav(fn, verbose=verbose);
  pnav_filename = fn;

  // correct soe_day_start if the tlds dont start until after midnight
  if(!is_void(edb) && !is_void(soe_day_start)) {
    if((edb.seconds(0) - soe_day_start(1)) < pnav.sod(1)) {
      soe_day_start -= 86400;
      write, format="Correcting soe_day_start to %d\n", soe_day_start;
    }
  }

  return pnav;
}

func load_pnav2FS(junk, ifn=) {
  extern gt_pnav;

  gt_pnav = load_pnav(ifn);

  date = get_date(file_tail(ifn));
  soe = date2soe(date, gt_pnav.sod);
  fs = pnav2fs(gt_pnav, soe=soe);

  return fs;
}

func pnav2fs(pn, soe=) {
/* DOCUMENT pnav2fs(pn, soe=)
  Converts data in PNAV format to FS format. If provided, SOE is used for
  timestamps instead of PN.SOD.
*/
  extern curzone;
  local x, y;
  if(!curzone) {
    write, "Please define curzone. Aborting.";
    return;
  }
  default, soe, pn.sod;
  ll2utm, pn.lat, pn.lon, y, x, force_zone=curzone;
  fs = array(FS, dimsof(pn));
  fs.east = x * 100;
  fs.north = y * 100;
  fs.elevation = pn.alt * 100;
  fs.soe = soe;
  return fs;
}

func data2pnav(data, mode=, zone=) {
/* DOCUMENT data2pnav(data, mode=, zone=)
  Casts point data to PNAV struct.

  Options:
    mode= Lets you specify a custom mode.
    zone= Lets you specify a custom zone. Uses curzone by default.
*/
  default, zone, curzone;
  if(!zone) {
    write, "Please provide zone= or define curzone. Aborting.";
    exit;
  }

  local x, y, z;
  data2xyz, data, x, y, z, mode=mode;
  pn = array(PNAV, dimsof(data));
  utm2ll, y, x, zone, x, y;
  pn.lon = x;
  pn.lat = y;
  pn.alt = z;

  if(!has_member(data, "soe")) return pn;

  tmp = soe2time(data.soe(min));
  tmp(3:) = 0;
  offset = time2soe(tmp);
  pn.sod = data.soe - time2soe(tmp);
  pn = pn(sort(pn.sod));
  return pn;
}
fs2pnav = data2pnav;

func iex2pnav(iex) {
/* DOCUMENT iex2pnav(iex)
   Convert an iex_nav (IEX_ATTITUDE) variable to pnav and subsample it
   to the normal pnav side to make it more managable.
*/
  if ( structeq(structof(iex), IEX_ATTITUDE)) {
    sample=long(0.5/iex.somd(dif)(avg)+0.5);

    sample;
    if ( sample > 1 ) {
      idx = (iex.somd - long(iex.somd))(mnx) % sample;
      iex = iex(idx::sample);
    }

    pn = struct_cast(iex, PNAV);
    pn(1:20).sod;

    day_start = long(pn.sod(1)/86400) * 86400;
    pn.sod = pn.sod - day_start;
    if (anyof(pn.sod < 0 )) {
      w = where(pn.sod < 0 );
      pn.sod(w) += 86400;
    }

    if ( pn.sod(min) > 86400)
      pn.sod = soe2somd(pn.sod);
  }

  return(pn);
}


func pnav_diff_alt(pn1, pn2, xfma=, swin=, woff=, title=, kill=) {
/* DOCUMENT pnav_diff_alt(pn1, pn2, xfma=, swin=, woff=, title=, kill=)
   Given two trajectories produced for the same flight,
   compute the altitude difference for each identical point
   in time.

  Use: var=load_pnav()   to manually load a pnav file.

   xfma=[0|1]
   swin=N : specify the starting window number for each plot.
            This function only produces one plot window, but this keeps
            it consistent with the other pnav_diff_ functions that generate
            multiple plot windows. default is 26.
   woff=N : used to compute an offset to swin when comparing
            more than one pair of trajectories.
   title="TITLE"
   kill=[0|1] : set to 1 to kill all windows generated by a previous
                run and exit.

*/
  default, title, " ";
  default, swin, 26;
  default, woff, 0;
  nwin=1;   // Number of windows created by this routine.

  if ( kill ) {
    winkill, swin+(woff*nwin);   // Plot track in UTM
    return;
  }

  extern p1, p2;

  if ( ! structeq(structof(pn1), PNAV)) {
    write, "first argument is not a PNAV";
    return;
  }

  if ( ! structeq(structof(pn2), PNAV)) {
    write, "second argument is not a PNAV";
    return;
  }

  window, swin+(woff*nwin);   // Plot track in UTM
  if(xfma) fma;

  w1 = set_intersection(pn1.sod, pn2.sod, idx=1);
  w2 = set_intersection(pn2.sod, pn1.sod, idx=1);
  pn1=pn1(w1);
  pn2=pn2(w2);

  pn1.alt = pn1.alt - pn2.alt;

  p1 = pn1;
  p2 = pn2;

  legend, reset;
  legend, add, "red", "delta Altitude";
  legend, show;
  plg, pn1.alt, pn1.sod/3600.0, color="red";
  xytitles, "Hours of day", "Meters", [-0.005, -0.01];

  grow, title, "Trajectory Altitude Difference";
  title = strjoin( title, "\n");
  pltitle, title;

  return pn1;
}


func pnav_diff_latlon(pn1, pn2, xfma=, swin=, woff=, title=, kill=) {
/* DOCUMENT pnav_diff_latlon(pn1, pn2, xfma=, swin=, woff=, title=, kill=)
   Given two trajectories produced for the same flight,
   compute the lat/lon positional difference for each identical point
   in time.

  Use: var=load_pnav()   to manually load a pnav file.

   xfma=[0|1]
   swin=N : specify the starting window number for each plot.
            This function produces 4 plot windows. default is 30.
   woff=N : used to compute an offset to swin when comparing
            more than one pair of trajectories.
   title="TITLE"
   kill=[0|1] : set to 1 to kill all windows generated by a previous
                run and exit.

   4 plots are generated:
   Plot 1 shows both trajectories overlayed.
   Plot 2 shows the differences between UTM east and north,
          individually, vs hours-of-day.
   Plot 3 shows delta range between both trajectories vs
          hours-of-day.
   Plot 4 shows a histogram of the delta values.
*/
  extern u1, u2, ur, p1, p2;
  default, title, " ";
  default, swin, 30;
  default, woff, 0;
  nwin=4;   // Number of windows created by this routine.

  if ( ! structeq(structof(pn1), PNAV)) {
    write, "first argument is not a PNAV";
    return;
  }

  if ( ! structeq(structof(pn2), PNAV)) {
    write, "second argument is not a PNAV";
    return;
  }

  w1 = set_intersection(pn1.sod, pn2.sod, idx=1);
  w2 = set_intersection(pn2.sod, pn1.sod, idx=1);
  pn1=pn1(w1);
  pn2=pn2(w2);

  p1 = pn1;
  p2 = pn2;

  if ( kill ) {
    winkill, swin+(woff*nwin); ++swin;    // Plot track in UTM
    winkill, swin+(woff*nwin); ++swin;    // UTM differences
    winkill, swin+(woff*nwin); ++swin;    // Trajectory Horizontal Difference differences
    winkill, swin+(woff*nwin); ++swin;    // hist_data_plot
    return;
  }

  // Compute distance using lat/lon
  llr = lldist(pn1.lat, pn1.lon, pn2.lat, pn2.lon);
  llr *= 1852.0;

  // now do it again using utm
  u1 = ll2utm(pn1.lat, pn1.lon, force_zone=curzone);
  u2 = ll2utm(pn2.lat, pn2.lon, force_zone=curzone);

  window, swin+(woff*nwin); ++swin;    // Plot track in UTM
  if(xfma) fma;

  // plot the intersection of each pnav
  legend, reset;
  legend, add, "red",  "pnav1";
  legend, add, "blue", "pnav2";

  // plot in UTM instead of lat/lon
  plmk, u1(1,), u1(2,), color="red";
  plmk, u2(1,), u2(2,), color="blue" ;

  ttitle = title;
  grow, ttitle, "Intersection Map";
  ttitle = strjoin( ttitle, "\n");
  pltitle, ttitle;

  legend, show;

  t1 = u2(1,) - u1(1,);
  t2 = u2(2,) - u1(2,);
  window, swin+(woff*nwin); ++swin;    // UTM differences
  if(xfma) fma;
  legend, add, "red",  "EAST";       // XYZZY - which is which??
  legend, add, "blue", "NORTH";
  plmk, t1, pn1.sod/3600.0, color="red";
  plmk, t2, pn1.sod/3600.0, color="blue";
  legend, show;
  t1 = t1^2;
  t2 = t2^2;
  ur = (t1+t2) ^ .5;
  ttitle = title;
  grow, ttitle, "UTM differences";
  ttitle = strjoin( ttitle, "\n");
  pltitle, ttitle;
  xytitles, "Hours of day", "Meters", [-0.005, -0.01];

  window, swin+(woff*nwin); ++swin;       // Trajectory Horizontal Difference
  if(xfma) fma;
  legend, add, "red", "latlon range";
  plmk, llr, pn1.sod/3600.0, color="red";
  legend, add, "blue", "utm range";
  plmk, ur,  pn1.sod/3600.0, color="blue";
  legend, show;
  xytitles, "Hours of day", "Meters", [-0.005, -0.01];

  ttitle = title;
  grow, ttitle, "Trajectory Horizontal Difference";
  ttitle = strjoin( ttitle, "\n");
  pltitle, ttitle;

  hist_data_plot, llr, win=swin+(woff*nwin),
    title="Delta Range Histogram",
    xtitle="Range",
    ytitle="Counts",
    dofma=1,
    binsize=.001;

  return llr;
}


func pnav_diff_base_latlon(pn1, pn2, lat, lon, xfma=, swin=, woff=, title=, kill=) {
/* DOCUMENT pnav_diff_base_latlon(pn1, pn2, lat, lon, xfma=, swin=, woff=, title=, kill=)
   Given two trajectories produced for the same flight and the lat/lon values
   for the base station, compute the lat/lon positional difference for each
   identical point in time and then plots that value relative to the range
   from the base station.

  Use: var=load_pnav()   to manually load a pnav file.

   xfma=[0|1]
   swin=N : specify the starting window number for each plot.
            This function produces 4 plot windows. default is 47.
   woff=N : used to compute an offset to swin when comparing
            more than one pair of trajectories.
   title="TITLE"
   kill=[0|1] : set to 1 to kill all windows generated by a previous
                run and exit.

   4 plots are generated:
   Plot 1 shows both trajectories overlayed and the base station.
   Plot 2 shows delta altitude vs time.
   Plot 3 shows detla altitude vs range from base.
   plot 4 shows histogram of delta altitude.
*/
  extern u1, u2, ur, p1, p2;
  default, title, " ";
  default, swin, 47;
  default, woff, 0;
  nwin=4;   // Number of windows created by this routine.

  if ( ! structeq(structof(pn1), PNAV)) {
    write, "first argument is not a PNAV";
    return;
  }

  if ( ! structeq(structof(pn2), PNAV)) {
    write, "second argument is not a PNAV";
    return;
  }

  if ( ! is_real(lat) ) {
    write, "third argument is not a double";
    return;
  }

  if ( ! is_real(lon) ) {
    write, "fourth argument is not a double";
    return;
  }

  w1 = set_intersection(pn1.sod, pn2.sod, idx=1);
  w2 = set_intersection(pn2.sod, pn1.sod, idx=1);
  pn1=pn1(w1);
  pn2=pn2(w2);

  p1 = pn1;
  p2 = pn2;

  if ( kill ) {
    winkill, swin+(woff*nwin); ++swin;    // Plot track in UTM
    winkill, swin+(woff*nwin); ++swin;    // Delta altitude vs time
    winkill, swin+(woff*nwin); ++swin;    // Altitude vs Time
    winkill, swin+(woff*nwin); ++swin;    // hist_data_plot
    return;
  }
  // lat/lon range  or delta ll
  llr = lldist(pn1.lat, pn1.lon, pn2.lat, pn2.lon);
  llr *= 1852.0;

  // lat/base range
  lbr = lldist(pn1.lat, pn1.lon, lat, lon);
  lbr *= 1.8520;

  // delta altitude
  pn1.alt = pn1.alt - pn2.alt;

  window, swin+(woff*nwin); ++swin;    // Plot track in UTM
  if(xfma) fma;

// now do it again using utm
  u1 = ll2utm(pn1.lat, pn1.lon, force_zone=curzone);
  u2 = ll2utm(pn2.lat, pn2.lon, force_zone=curzone);
  u0 = ll2utm(lat, lon, force_zone=curzone);

  // plot the intersection of each pnav
  legend, reset;
  legend, add, "red",  "pnav1";
  legend, add, "blue", "pnav2";
  legend, add, "green","Base";

  // plot in UTM in km setting 0,0 to the base station
  m1 = u0(1,);
  m2 = u0(2,);
  plmk, (u1(1,)-m1)/1000., (u1(2,)-m2)/1000., color="red";
  plmk, (u2(1,)-m1)/1000., (u2(2,)-m2)/1000., color="blue";
  plmk, (u0(1,)-m1)/1000., (u0(2,)-m2)/1000., msize=.5, color="green", width=5;

  ttitle = title;
  grow, ttitle, "Intersection Map";
  ttitle = strjoin( ttitle, "\n");
  pltitle, ttitle;

  legend, show;

  window, swin+(woff*nwin); ++swin;  // Delta altitude vs time
  if(xfma) fma;

  legend, reset;
  legend, add, "red",  "altitude";

  plmk, pn1.alt, pn1.sod/3600.0, color="black", msize=.1;
  plg,  pn1.alt, pn1.sod/3600.0, color="red";
  legend, show;
  xytitles, "Hours of day", "Meters", [ 0.505, -0.01];
  range, -.05, .05;

  ttitle = title;
  grow, ttitle, "Altitude / Time Difference";
  ttitle = strjoin( ttitle, "\n");
  pltitle, ttitle;

  window, swin+(woff*nwin); ++swin;  // Altitude vs Time
  if(xfma) fma;

  // Plot delta altitude vs range from base lat/lon
  legend, add, "red", "Range";
  legend, show;

  plmk, pn1.alt, lbr, color="red";
  xytitles, "Range from Base(km)", "Meters", [0.505, -0.01];
  range, -.05, .05;

  ttitle = title;
  grow, ttitle, "Altitude / Range Difference";
  ttitle = strjoin( ttitle, "\n");
  pltitle, ttitle;

  hist_data_plot, pn1.alt, win=swin+(woff*nwin),   // histogram
    title="Altitude",
    xtitle="Difference",
    ytitle="Counts",
    dofma=1,
    normalize=0,
    binsize=.001;

  return lbr;
}
