
/*
     $Id$

  Orginal: 8/17/2002 C. Wayne Wright  wright@lidar.wff.nasa.gov
  
  Compute approximate elevation data for quick and dirty uses
  such as feeding rcf, or geo-refed waveforms.

  qde		A function to do a "quick and dirty" estimation
                of the surface. It takes an XRTRS structure for
                input.
 
*/

write, "$Id$"
 
 
// The line interpolating heading needs to be done using x/y from a
// unit circle to work for norther headings.

 
   Hcvt = 2115.0;	// keys
   Hcvt = 2140.0;	// tbay
 
func qde( r ) {
/* DOCUMENT qde(  r, scan= )

  "qde" is Quick Dirty Elevation.

   r		Input array of EAARL XRTRS values generated by
		irg.


  animate,1;
  for (i=1; i<200; i++) {
    fma;
    plmk, w(,i,1), w(,i,2), marker=4;
  }
  animate,0;

*/
   rb = roll_bias * d2r;
   a = r.sa / Hcvt * pi + rb;
   e = -r.irange * cos(a + r.rroll ) * NS2MAIR;
   ea = [ e + r.alt, a ];
   return ea;
}

func lsq(y,x) {
/* DOCUMENT lsq(y,x)
   Compute linear least squares on x and y giving the
   "a" and "b" terms in a return array.  A detailed 
   description of the method can be found at:

   http://www.efunda.com/math/leastsquares/lstsqr1dcurve.cfm

   The return value is an array [a,b] where the fitted line
   can be generated by:   y  = bx+a. 
   
*/
  sy  = y(sum);
  sx  = x(sum);
  sx2 = (x^2)(sum);
  sxy = (x*y)(sum);
  n = float(numberof(x));
  d = n * sx2 - sx^2;
  a = ( sy * sx2 - sx*sxy) / d;
  b = ( n*sxy - sx*sy) / d;
  return [ a, b ];
}

func d(a,b, wn=) {
  if ( is_void(wn) )
	wn = 2.0;
 
  xx = [-.5, .5];
  animate,1;
  for (i=1; i<200; i++) {
    s = *rcf( w(,i,1), wn, mode=2)(1);		// Find surface values.
    ns = indgen(1:120); 			// Find rejects.
    ns(s) = 0;					// Zero out good indexes.
    nsi = where(ns);
    fma;
    plmk, w(nsi,i,1), w(nsi,i,2), marker=3, color="black", msize=.2;
    plmk, w(s,i,1), w(s,i,2), marker=4, color="red";
    si = s(sort( s )) ;
    plg, w(si,i,1), w(si,i,2), marks=0, color="red";
    a = lsq( w(s, i, 1), w(s,i,2) );
    b = a(2); a=a(1);
    write,format="%f %f %f\n", w(s,i,1)(rms), a, b;
    plg, xx*b+a, xx, marks=0, color="blue"
  }
  animate,0;
}



