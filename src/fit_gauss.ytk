# vim: set ts=3 sts=3 sw=3 ai sr et:

################################################################################
#                                Initialization                                #
################################################################################
if {![namespace exists ::fit_gauss]} {
   ybkg require \"fit_gauss.i\"
   namespace eval ::fit_gauss {
      # Constants
      namespace eval c {
         variable win .fitgauss        ;# Toplevel window for GUI

         variable raster_min 1         ;# Minimum value for raster
         variable raster_max 100000000 ;# Maximum value for raster
         variable pixel_min 1          ;# Minimum value for pixel
         variable pixel_max 120        ;# Maximum value for pixel
         variable add_peak_min 0       ;# Minimum value for add_peak=
         variable add_peak_max 5       ;# Maximum value for add_peak=
         variable limrange_min 0       ;# Minimum value for lims= range
         variable limrange_max 100     ;# Maximum value for lims= range
      }
      # GUI variables
      namespace eval g {
         variable result_var "p"       ;# Destination for result of fit_gauss()
         variable raster 1             ;# Corresponds to fit_gauss(raster, ?)
         variable pixel 1              ;# Corresponds to fit_gauss(?, pixel)
         variable add_peak 0           ;# Corresponds to fit_gauss(?,?,add_peak=)
         variable graph 1              ;# Corresponds to fit_gauss(?,?,graph=)
         variable verbose 0            ;# Corresponds to fit_gauss(?,?,verbose=)
         variable lims 0               ;# Specifies whether to provide lims=
         variable lims_x1 1            ;# Corresponds to fit_gauss(?,?,lims=[x1,?])
         variable lims_x2 2            ;# Corresponds to fit_gauss(?,?,lims=[?,x2])

         variable mouse_mode 0         ;# Are we in mouse mode?
      }
   }
}

################################################################################
#                               Variable Traces                                #
################################################################################

namespace eval ::fit_gauss {
   # Traces are applied in the order created, most recent first. Thus, we have
   # to create them in reverse of the order we want them applied.

   # Keep Yorick updated
   tky_tie add broadcast g::raster to tky_fit_gauss_vars.raster -initialize 1
   tky_tie add broadcast g::pixel to tky_fit_gauss_vars.pixel -initialize 1
   tky_tie add broadcast g::add_peak to tky_fit_gauss_vars.add_peak -initialize 1
   tky_tie add broadcast g::graph to tky_fit_gauss_vars.graph -initialize 1
   tky_tie add broadcast g::verbose to tky_fit_gauss_vars.verbose -initialize 1
   tky_tie add broadcast g::lims to tky_fit_gauss_vars.lims -initialize 1
   tky_tie add broadcast g::lims_x1 to tky_fit_gauss_vars.lims_x1 -initialize 1
   tky_tie add broadcast g::lims_x2 to tky_fit_gauss_vars.lims_x2 -initialize 1
   tky_tie add broadcast g::result_var to tky_fit_gauss_vars.result_var -initialize 1

   # Make sure that x1 <= x2 remains true
   validation_trace add g::lims_x1 \
      {expr {{%V} eq "" || {%V} < $::fit_gauss::g::lims_x2}} \
      -invalidcmd [list set ::fit_gauss::g::lims_x2 {%V}]
   validation_trace add g::lims_x2 \
      {expr {{%V} eq "" || {%V} > $::fit_gauss::g::lims_x1}} \
      -invalidcmd [list set ::fit_gauss::g::lims_x1 {%V}]

   # Enforce valid ranges
   validation_trace add g::raster {expr {{%V} eq ""}} \
      -invalidcmd [list constrain %v between $c::raster_min and $c::raster_max]
   validation_trace add g::pixel {expr {{%V} eq ""}} \
      -invalidcmd [list constrain %v between $c::pixel_min and $c::pixel_max]
   validation_trace add g::add_peak {expr {{%V} eq ""}} \
      -invalidcmd [list constrain %v between $c::add_peak_min and $c::add_peak_max]

   validation_trace add g::lims_x1 {expr {{%V} eq ""}} \
      -invalidcmd [list constrain %v between $c::limrange_min and $c::limrange_max]
   validation_trace add g::lims_x2 {expr {{%V} eq ""}} \
      -invalidcmd [list constrain %v between $c::limrange_min and $c::limrange_max]

   # Enforce valid types
   validation_trace add g::result_var {regexp {^(?:(?:)|[[:alpha:]_][[:alnum:]_]*)$} {%V}}
   validation_trace add g::raster {string is integer {%V}}
   validation_trace add g::pixel {string is integer {%V}}
   validation_trace add g::add_peak {string is integer {%V}}
   validation_trace add g::lims_x1 {string is integer {%V}}
   validation_trace add g::lims_x2 {string is integer {%V}}
}

proc ::fit_gauss::trace_lims_gui {name1 name2 op} {
   if {[winfo exists $c::win]} {
      set lim_vars [list]
      foreach var [list g::lims_x1 g::lims_x2] {
         lappend lim_vars [namespace which -variable $var]
      }

      set state [lindex [list disabled normal] $g::lims]
      foreach widget [winfo_children_all $c::win] {
         if {[lsearch -glob [$widget configure] -textvariable\ *] > -1} {
            set var [namespace which -variable [$widget cget -textvariable]]
            if {[lsearch $lim_vars $var] > -1} {
               $widget configure -state $state
            }
         }
      }
   }
}

trace add variable ::fit_gauss::g::lims write ::fit_gauss::trace_lims_gui

################################################################################
#                               Core Procedures                                #
################################################################################

proc ::fit_gauss::create_gui {} {
   set w $c::win

   destroy $w
   toplevel $w -padx 2 -pady 2
   wm title $w "Fit Gauss"

   # Raster #
   # Pixel #
   # graph= 1/0
   # add_peak= 0,1,2,3...
   # verbose= 1/0
   # lims= [a,b] -- a=0,1,2,3... b=0,1,2,3... a <= b

   set f $w.lfrSelection
   labelframe $f -text "Pixel Selection"

   label $f.lblRaster -text "Raster:"
   spinbox $f.spnRaster \
      -from $c::raster_min -to $c::raster_max -increment 1 \
      -textvariable ::fit_gauss::g::raster

   label $f.lblPixel -text "Pixel:"
   spinbox $f.spnPixel \
      -from $c::pixel_min -to $c::pixel_max -increment 1 \
      -textvariable ::fit_gauss::g::pixel

   button $f.btnEnterMouse -text "Mouse Mode" \
      -command ::fit_gauss::enter_mouse_mode

   grid $f.lblRaster $f.spnRaster $f.btnEnterMouse
   grid $f.lblPixel $f.spnPixel ^

   grid $f
   grid columnconfigure $f 1 -weight 1

   set f $w.lfrOptions
   labelframe $f -text "Options"

   label $f.lblAddPeak -text "Add Peaks:"
   spinbox $f.spnAddPeak -from $c::add_peak_min -to $c::add_peak_max -increment 1 \
      -textvariable ::fit_gauss::g::add_peak

   grid $f.lblAddPeak $f.spnAddPeak - -

   checkbutton $f.chkLims -variable ::fit_gauss::g::lims -text "Constrain Lims from"

   spinbox $f.spnLimsX1 \
      -from $c::limrange_min -to $c::limrange_max -increment 1 \
      -textvariable ::fit_gauss::g::lims_x1

   label $f.lblLimsX2 -text "to"
   spinbox $f.spnLimsX2 \
      -from $c::limrange_min -to $c::limrange_max -increment 1 \
      -textvariable ::fit_gauss::g::lims_x2

   grid $f.chkLims $f.spnLimsX1 $f.lblLimsX2 $f.spnLimsX2

   grid $f
   grid columnconfigure $f {1 3} -weight 1

   set f $w.lfrOutput
   labelframe $f -text "Output"

   label $f.lblResultVar -text "Result variable:"
   entry $f.entResultVar -textvariable ::fit_gauss::g::result_var

   grid $f.lblResultVar $f.entResultVar

   checkbutton $f.chkGraph -text "Graph" -variable ::fit_gauss::g::graph
   checkbutton $f.chkVerbose -text "Verbose" -variable ::fit_gauss::g::verbose
   button $f.btnFitGauss -text "Fit Gauss" -command ::fit_gauss::cmd_fit_gauss

   grid $f.chkGraph $f.btnFitGauss
   grid $f.chkVerbose ^

   grid $f
   grid columnconfigure $f 1 -weight 1

   grid columnconfigure $w 0 -weight 1

   foreach child [winfo_children_all $w] {
      switch -- [string range [winfo name $child] 0 2] {
         btn {
            #grid configure $child -sticky news
         }
         chk {
            grid configure $child -sticky w
         }
         ent {
            grid configure $child -sticky ew
         }
         lbl {
            grid configure $child -sticky e
         }
         lfr {
            $child configure -pady 2 -padx 2
            grid configure $child -sticky ew
         }
         spn {
            $child configure -width 5
            grid configure $child -sticky ew
         }
      }
   }

   # This triggers any traces on each GUI variable. Useful for ensuring that
   # any necessary GUI updating is done.
   foreach var [info vars g::*] {
      set $var [set $var]
   }
}

proc ::fit_gauss::cmd_fit_gauss {} {
   if {$g::mouse_mode} {
      ybkg tky_fit_gauss_exec
   } else {
      set var $g::result_var
      set params "$g::raster, $g::pixel"
      ::misc::appendif params {
         $g::graph      ", graph=1"
         $g::add_peak   ", add_peak=1"
         $g::verbose    ", verbose=1"
         {$g::add_peak == 1 && $g::lims}  ", lims=\[\[$g::lims_x1, $g::lims_x2\]\]"
      }
      if {[string length $var]} {
         exp_send "$var = fit_gauss($params)\r"
      } else {
         exp_send "fit_gauss, $params\r"
      }
   }
}

proc ::fit_gauss::enter_mouse_mode {} {
   set g::mouse_mode 1
   exp_send "tky_fit_gauss_interactive, $::pro_var, $::win_no;\r"
}

proc ::fit_gauss::leave_mouse_mode {} {
   set g::mouse_mode 0
}
