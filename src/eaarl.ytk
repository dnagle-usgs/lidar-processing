#
#  eaarl.ytk 
#
# To Do
#  Default and option settings.
#
#  1/4/2002  
#  WW Added "Edit notes.txt" option in file.  Use this for quick access
#  to the mission notes with your favorit editor. It uses the editor selected
#  in the Ytk Edit menu.
#
#
#

package require sf

package require comm
set sf_a_id -1
set cir_id -1

proc send_sf { args } {
# Send a message to sf_a.tcl safely
    global sf_a_id
    if { $sf_a_id != -1 } {
        if { [catch { eval ::comm::comm send $sf_a_id $args }] } {
            set sf_a_id -1
        }
    }
}

proc send_cir { args } {
# Send a message to cir.tcl safely
    global cir_id
    if { $cir_id != -1 } {
        if { [catch { eval ::comm::comm send $cir_id $args }] } {
            set cir_id -1
        }
    }
}

proc sf_exists { } {
# See if sf_a exists
    global sf_a_id
    return [expr {$sf_a_id != -1}]
}

proc cir_exists { } {
# See if cir exists
	global cir_id
	return [expr {$cir_id != -1}]
}

proc center_win { win } {
# Center a window.
 set lx [ expr [winfo screenwidth  $win]/2 - [winfo width  $win]/2 ]
 set ly [ expr [winfo screenheight $win]/2 - [winfo height $win]/2 ]
 wm geometry $win "+$lx+$ly"
 wm deiconify $win
 update
}

proc display_mission_constants { l } {
  global w1
  array set ary $l
  set w1 .$ary(VarName)
  destroy $w1
  toplevel $w1
  set row 0
  foreach {lbl x} $l {
    label $w1.l$lbl -text "$lbl:" -relief sunken -anchor e -padx 5
    label $w1.v$lbl{v}    -text  $x -relief sunken -padx 5
    grid  $w1.l$lbl -column 0  -row $row -sticky ew
    grid  $w1.v$lbl{v}    -column 1  -row $row -sticky ew
    incr row
  }
  button $w1.dismiss -text "Dismiss" -command {
       destroy $w1 }

  button $w1.set     -text "Use these" -command "eval { 
     exp_send ops_conf=$ary(VarName)\\r; 
     destroy $w1 }" 
  grid  $w1.dismiss -row $row -column 0
  grid  $w1.set -row $row -column 1 -sticky ew
  center_win $w1
}

proc load_dmars {} { 
  global data_path
      if { [ info exists data_path ] } {
       set tpath "$data_path/trajectories/";
       if { [ expr ![ file isdirectory $tpath ]] } {
         set tpath $data_path;
       }
    } else {
       set tpath "";
    }

  set _ytk_fn [ tk_getOpenFile \
	-initialdir $tpath \
	-filetypes \
        {
           {{Yorick PBD file} {.pbd}  }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".pbd" {
	     exp_send "load_iexpbd,\"$_ytk_fn\"";
#            exp_send "_ytk_pbd_f = openb(\"$_ytk_fn\"); restore, _ytk_pbd_f;\r"
#            exp_send "show, _ytk_pbd_f\r"
#            exp_send "iex2tans;\r"
               toplevel .stby
            exp_send "\r\n"
   set sz [ wm maxsize . ]
               label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
               pack .stby.lbl
   set wz "50 50"
   set sx [ expr [ lindex $sz 0 ] / 2  - [lindex $wz 0]/2 ]
   set sy [ expr [ lindex $sz 1 ] / 2  - [lindex $wz 1]/2 ]
   wm geometry .stby "+$sx+$sy"
               update
            expect ">"
               destroy .stby
           }
    }
  }
}


proc load_ops_conf {} { 
  global data_path
      if { [ info exists data_path ] } {
       set tpath "$data_path/";
       if { [ expr ![ file isdirectory $tpath ]] } {
         set tpath $data_path;
       }
    } else {
       set tpath "";
    }

  set _ytk_fn [ tk_getOpenFile \
	-initialdir $tpath \
	-filetypes \
        {
           {{Yorick .i files} {.i}  }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".i" {
	     exp_send "#include \"$_ytk_fn\"";
            toplevel .stby
            exp_send "\r\n"
   set sz [ wm maxsize . ]
               label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
               pack .stby.lbl
   set wz "50 50"
   set sx [ expr [ lindex $sz 0 ] / 2  - [lindex $wz 0]/2 ]
   set sy [ expr [ lindex $sz 1 ] / 2  - [lindex $wz 1]/2 ]
   wm geometry .stby "+$sx+$sy"
               update
            expect ">"
               destroy .stby
         }
    }
  }
}

proc send_sod_to_sf { somd } {
  catch {
   send_sf set timern sod
   send_sf set hsr $somd
   send_sf gotoImage
  }
  ybkg sf_mediator_broadcast_somd $somd
}

proc send_tans_to_sf {somd p r h} {
   catch {
    send_sf set pitch $p
    send_sf set roll $r
    send_sf set head $h
    send_sf gotoImage
   }
}


proc path_exists { path } {
# Test if a path exists, and pop up warning if not.
  if { [ file isdirectory $path ]  == 0 } {
    tk_messageBox \
	-icon warning \
	-type ok \
	-message "$path doesn't exist."
  }
}

proc scap { } {
# DOCUMENT scap
# Do a screen capture of a mouse selected window.
#
# Capture a mouse selected window to an image file.  This proc
# uses the xwd command to capture a selected window to an 
# /tmp/*.xwd file and then uses the convert command to covert
# that file to any number of different formats.  Once the image
# has been stored in the desired format, the /tmp/*.xwd file
# is deleted.
#  global capture_path data_path capture_name _ytk
 global capture_path data_path capture_name
  if { [ info exists capture_path ] == 0 } {
    if { [ info exists data_path ] } {
       set capture_path $data_path
    } else {
       set capture_path "";
    }
  }
  if { [info exists capture_name ] == 0 } {
    set capture_name "";
  }
  tk_messageBox -type ok \
	-message {Raise the window you want to capture, \
click OK, and then click on the desired window.}
  update
  exec xwd -out /tmp/junk.xwd;
  set fn [tk_getSaveFile  -initialdir $capture_path \
	-defaultextension .png \
	-initialfile $capture_name \
 	 ]
  if { $fn != "" } {
    set capture_name [ file tail $fn ]
    set ext [ file extension $fn ]
    set n [ lsearch ".jpg .gif .png .bmp .pnm .tif .tiff" $ext ]
    set capture_path [ file dirname $fn ]
    if { $n == -1 } {
      set fn "[ file rootname $fn ].png"
    }
    update
    # Require the user to get their unix path right.
    exec convert /tmp/junk.xwd $fn
    # exec $_ytk(convert) /tmp/junk.xwd $fn
    file delete -force /tmp/junk.xwd
  }
}

proc load_cmd { start_dir } {
 global _ytk_fn y_codedir ytk_codedir _ytk_mrl _ytk_mrl_idx
  set _ytk_fn [ tk_getOpenFile \
        -initialdir $start_dir \
        -filetypes \
        {
           {{Yorick Programs} {.i}  }
           {{Yorick or Tcl/tk program} {.i .ytk}  }
           {{Yorick Specfic Tcl/Tk Programs} {.ytk} }
           {{Tcl/Tk Programs} {.tcl .tk} }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".tcl" -
    ".tk"  -
    ".ytk" {
            uplevel { source $_ytk_fn }
           }
    ".i"   {
            set ycode_dir [ file dirname $_ytk_fn ]
            cd $ycode_dir;
            exp_send "cd, \"$ycode_dir\"\r"
            exp_send "#include \"$_ytk_fn\"\r"
            exp_send "cd, src_path\r"
           }

    }
  }
}

proc init_sf {} {
 global data_path
    send_sf set dir $data_path
}

proc init_cir {} {
 global data_path
    send_cir cirdir "$data_path/cir"
}

proc edb_loaded { } {
 global edb 
 if { [ info exists edb ] == 0 } {
   tk_messageBox -type ok \
        -icon warning \
        -message { edb_loaded: No EDB (EAARL Data Base) is loaded }
  set rv 0;
 } else { 
   set rv  1;
 } 
 return $rv;
}

proc edb_status { } {
 global edb;
 destroy .edb
 if { [ edb_loaded ] == 0 } {
   return;
 }
 
 toplevel .edb
 set v " \
        Year                            year \
        {Day of Year}                   day \
         Path                           path \
        {Index File}                    idx_file \
        {Total Data (GB)}               gb \
        {Number of Files}               number_of_files \
        {Total Rasters}                 nbr_rasters \
        {First Good Raster}             data_begins \
        {Last Good Raster}              data_ends \
        {Mission Duration (Hours)}      mission_duration \
        {Seconds of the Epoch at day start}          soe \
        {eaarl_time_offset}          	eaarl_time_offset \
       "
 
  set edb(idx_file) [ file tail $edb(idx_file) ]
  set row 0
  foreach {lbl x} $v {
    label .edb.$x\lbl -text "$lbl:" -relief sunken -anchor e -padx 5
    label .edb.v$x    -text  $edb($x) -relief sunken -padx 5
    grid  .edb.$x\lbl -column 0  -row $row -sticky ew
    grid  .edb.v$x    -column 1  -row $row -sticky ew
    incr row
  }
  button .edb.dismiss -text Dismiss -command { destroy .edb }
  grid .edb.dismiss -row $row -columnspan 2 -sticky ew
 
}

proc load_edb {} {
 global data_path
   exp_send "load_edb, update=0\r"
  expect "load_edb_completed"
  expect ">"
  after 2000 {
  edb_status
  if { [sf_exists] } {
     send_sf "set dir $data_path"
  }
  }
}

#####################################################################
# main
# Set the source code path for this invocation.  It can 
# then be used to load the other modules.
#####################################################################
   set data_path "/data/"
   # send ytk process id to yorick global variable _pid.
   ybkg require \"eaarl.i\"

####   exp_send "#include \"edb_access.i\"\r"
####   exp_send "#include \"map.i\"\r"

   ybkg require \"rbgga.i\"

#############
#   Nav
#############


 set gga_color black

 set clist "black red blue green cyan magenta yellow white"

#############
#   Deprecated
#############

# Since ybkg is used, some output may go to the console (especially Yeti), so
# this gives the user back their prompt.
exp_send \r
expect ">"

source [file join $src_path l1pro.ytk]
wm deiconify .l1wid
