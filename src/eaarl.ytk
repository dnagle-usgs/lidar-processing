#
#  eaarl.ytk 
#
# To Do
#  Default and option settings.
#
#  1/4/2002  
#  WW Added "Edit notes.txt" option in file.  Use this for quick access
#  to the mission notes with your favorit editor. It uses the editor selected
#  in the Ytk Edit menu.
#
#
#

package require sf

proc load_dmars {} { 
  global data_path
      if { [ info exists data_path ] } {
       set tpath "$data_path/trajectories/";
       if { [ expr ![ file isdirectory $tpath ]] } {
         set tpath $data_path;
       }
    } else {
       set tpath "";
    }

  set _ytk_fn [ tk_getOpenFile \
	-initialdir $tpath \
	-filetypes \
        {
           {{Yorick PBD file} {.pbd}  }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".pbd" {
	     exp_send "load_iexpbd,\"$_ytk_fn\"";
#            exp_send "_ytk_pbd_f = openb(\"$_ytk_fn\"); restore, _ytk_pbd_f;\r"
#            exp_send "show, _ytk_pbd_f\r"
#            exp_send "iex2tans;\r"
               toplevel .stby
            exp_send "\r\n"
   set sz [ wm maxsize . ]
               label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
               pack .stby.lbl
   set wz "50 50"
   set sx [ expr [ lindex $sz 0 ] / 2  - [lindex $wz 0]/2 ]
   set sy [ expr [ lindex $sz 1 ] / 2  - [lindex $wz 1]/2 ]
   wm geometry .stby "+$sx+$sy"
               update
            expect ">"
               destroy .stby
           }
    }
  }
}

proc load_ops_conf {} { 
  global data_path
      if { [ info exists data_path ] } {
       set tpath "$data_path/";
       if { [ expr ![ file isdirectory $tpath ]] } {
         set tpath $data_path;
       }
    } else {
       set tpath "";
    }

  set _ytk_fn [ tk_getOpenFile \
	-initialdir $tpath \
	-filetypes \
        {
           {{Yorick .i files} {.i}  }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".i" {
	     exp_send "#include \"$_ytk_fn\"";
            toplevel .stby
            exp_send "\r\n"
   set sz [ wm maxsize . ]
               label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
               pack .stby.lbl
   set wz "50 50"
   set sx [ expr [ lindex $sz 0 ] / 2  - [lindex $wz 0]/2 ]
   set sy [ expr [ lindex $sz 1 ] / 2  - [lindex $wz 1]/2 ]
   wm geometry .stby "+$sx+$sy"
               update
            expect ">"
               destroy .stby
         }
    }
  }
}

proc edb_loaded { } {
 global edb 
 if { [ info exists edb ] == 0 } {
   tk_messageBox -type ok \
        -icon warning \
        -message { edb_loaded: No EDB (EAARL Data Base) is loaded }
  set rv 0;
 } else { 
   set rv  1;
 } 
 return $rv;
}

proc edb_status { } {
 global edb;
 destroy .edb
 if { [ edb_loaded ] == 0 } {
   return;
 }
 
 toplevel .edb
 set v " \
        Year                            year \
        {Day of Year}                   day \
         Path                           path \
        {Index File}                    idx_file \
        {Total Data (GB)}               gb \
        {Number of Files}               number_of_files \
        {Total Rasters}                 nbr_rasters \
        {First Good Raster}             data_begins \
        {Last Good Raster}              data_ends \
        {Mission Duration (Hours)}      mission_duration \
        {Seconds of the Epoch at day start}          soe \
        {eaarl_time_offset}          	eaarl_time_offset \
       "
 
  set edb(idx_file) [ file tail $edb(idx_file) ]
  set row 0
  foreach {lbl x} $v {
    label .edb.$x\lbl -text "$lbl:" -relief sunken -anchor e -padx 5
    label .edb.v$x    -text  $edb($x) -relief sunken -padx 5
    grid  .edb.$x\lbl -column 0  -row $row -sticky ew
    grid  .edb.v$x    -column 1  -row $row -sticky ew
    incr row
  }
  button .edb.dismiss -text Dismiss -command { destroy .edb }
  grid .edb.dismiss -row $row -columnspan 2 -sticky ew
 
}

proc load_edb {} {
 global data_path
   exp_send "load_edb, update=0\r"
  expect "load_edb_completed"
  expect ">"
  after 2000 {
  edb_status
  }
}

#####################################################################
# main
# Set the source code path for this invocation.  It can 
# then be used to load the other modules.
#####################################################################
set data_path "/data/"
ybkg require \"eaarl.i\"

# Since ybkg is used, some output may go to the console (especially Yeti), so
# this gives the user back their prompt.
exp_send \r
expect ">"

source [file join $src_path l1pro.ytk]
wm deiconify .l1wid
