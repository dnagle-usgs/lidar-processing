#
# $Id$
#
#
#
#  eaarl.ytk 
#
# To Do
#  Default and option settings.
#
#  1/4/2002  
#  WW Added "Edit notes.txt" option in file.  Use this for quick access
#  to the mission notes with your favorit editor. It uses the editor selected
#  in the Ytk Edit menu.
#
#
#

package require comm
set sf_a_id -1
set cir_id -1

proc send_sf { args } {
# Send a message to sf_a.tcl safely
    global sf_a_id
    if { $sf_a_id != -1 } {
        if { [catch { eval ::comm::comm send $sf_a_id $args }] } {
            set sf_a_id -1
        }
    }
}

proc send_cir { args } {
# Send a message to cir.tcl safely
    global cir_id
    if { $cir_id != -1 } {
        if { [catch { eval ::comm::comm send $cir_id $args }] } {
            set cir_id -1
        }
    }
}

proc sf_exists { } {
# See if sf_a exists
    global sf_a_id
    return [expr {$sf_a_id != -1}]
}

proc cir_exists { } {
# See if cir exists
	global cir_id
	return [expr {$cir_id != -1}]
}

# Center a window.
proc center_win { win } {
 set lx [ expr [winfo screenwidth  $win]/2 - [winfo width  $win]/2 ]
 set ly [ expr [winfo screenheight $win]/2 - [winfo height $win]/2 ]
 wm geometry $win "+$lx+$ly"
 wm deiconify $win
 update
}


# Load
proc ycbar { } {
  global cmax cmin cdelta
  if { ![ info exists cmax ] } {
    set cmax 0;
    set cmin 0;
    set cdelta 0;
  }
  exp_send "cbar.cmax=$cmax; cbar.cmin=$cmin; cbar.cdelta=$cdelta\r"
}


proc display_mission_constants { l } {
  global w1
  array set ary $l
  set w1 .$ary(VarName)
  destroy $w1
  toplevel $w1
  set row 0
  foreach {lbl x} $l {
    label $w1.l$lbl -text "$lbl:" -relief sunken -anchor e -padx 5
    label $w1.v$lbl{v}    -text  $x -relief sunken -padx 5
    grid  $w1.l$lbl -column 0  -row $row -sticky ew
    grid  $w1.v$lbl{v}    -column 1  -row $row -sticky ew
    incr row
  }
  button $w1.dismiss -text "Dismiss" -command { 
	destroy $w1 }
  button $w1.set     -text "Use these" -command "eval { 
     exp_send ops_conf=$ary(VarName)\\r; 
     destroy $w1 }" 
  grid  $w1.dismiss -row $row -column 0
  grid  $w1.set -row $row -column 1 -sticky ew
  center_win $w1
}

proc load_dmars {} { 
  global data_path
      if { [ info exists data_path ] } {
       set tpath "$data_path/trajectories/";
       if { [ expr ![ file isdirectory $tpath ]] } {
         set tpath $data_path;
       }
    } else {
       set tpath "";
    }

  set _ytk_fn [ tk_getOpenFile \
	-initialdir $tpath \
	-filetypes \
        {
           {{Yorick PBD file} {.pbd}  }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".pbd" {
            set ytk_pbd_dir [ file dirname $_ytk_fn ]
	     exp_send "load_iexpbd,\"$_ytk_fn\"";
#            exp_send "_ytk_pbd_f = openb(\"$_ytk_fn\"); restore, _ytk_pbd_f;\r"
#            exp_send "show, _ytk_pbd_f\r"
#            exp_send "iex2tans;\r"
               toplevel .stby
            exp_send "\r\n"
   set sz [ wm maxsize . ]
               label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
               pack .stby.lbl
   set wz "50 50"
   set sx [ expr [ lindex $sz 0 ] / 2  - [lindex $wz 0]/2 ]
   set sy [ expr [ lindex $sz 1 ] / 2  - [lindex $wz 1]/2 ]
   wm geometry .stby "+$sx+$sy"
               update
            expect ">"
               destroy .stby
           }
    }
  }
}


proc load_ops_conf {} { 
  global data_path
      if { [ info exists data_path ] } {
       set tpath "$data_path/";
       if { [ expr ![ file isdirectory $tpath ]] } {
         set tpath $data_path;
       }
    } else {
       set tpath "";
    }

  set _ytk_fn [ tk_getOpenFile \
	-initialdir $tpath \
	-filetypes \
        {
           {{Yorick .i files} {.i}  }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".i" {
	     exp_send "#include \"$_ytk_fn\"";
            toplevel .stby
            exp_send "\r\n"
   set sz [ wm maxsize . ]
               label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
               pack .stby.lbl
   set wz "50 50"
   set sx [ expr [ lindex $sz 0 ] / 2  - [lindex $wz 0]/2 ]
   set sy [ expr [ lindex $sz 1 ] / 2  - [lindex $wz 1]/2 ]
   wm geometry .stby "+$sx+$sy"
               update
            expect ">"
               destroy .stby
           }
    }
  }
}

proc send_sod_to_sf { somd } {
  catch {
   send_sf set timern sod
   send_sf set hsr $somd
   send_sf gotoImage
  }
}

proc send_tans_to_sf {somd p r h} {
   catch {
    send_sf set pitch $p
    send_sf set roll $r
    send_sf set head $h
    send_sf gotoImage
   }
}


#
# Test if a path exists, and pop up warning if not.
#
proc path_exists { path } {
  if { [ file isdirectory $path ]  == 0 } {
    tk_messageBox \
	-icon warning \
	-type ok \
	-message "$path doesn't exist."
  }
}

#
# Do a screen capture of a mouse selected window.
proc scap { } {
# DOCUMENT scap
#
# Capture a mouse selected window to an image file.  This proc
# uses the xwd command to capture a selected window to an 
# /tmp/*.xwd file and then uses the convert command to covert
# that file to any number of different formats.  Once the image
# has been stored in the desired format, the /tmp/*.xwd file
# is deleted.
#  global capture_path data_path capture_name _ytk
 global capture_path data_path capture_name
  if { [ info exists capture_path ] == 0 } {
    if { [ info exists data_path ] } {
       set capture_path $data_path
    } else {
       set capture_path "";
    }
  }
  if { [info exists capture_name ] == 0 } {
    set capture_name "";
  }
  tk_messageBox -type ok \
	-message {Raise the window you want to capture, \
click OK, and then click on the desired window.}
  update
  exec /usr/X11R6/bin/xwd -out /tmp/junk.xwd;
  set fn [tk_getSaveFile  -initialdir $capture_path \
	-defaultextension .png \
	-initialfile $capture_name \
 	 ]
  if { $fn != "" } {
    set capture_name [ file tail $fn ]
    set ext [ file extension $fn ]
    set n [ lsearch ".jpg .gif .png .bmp .pnm .tif .tiff" $ext ]
    set capture_path [ file dirname $fn ]
    if { $n == -1 } {
      set fn "[ file rootname $fn ].png"
    }
    update
    # Require the user to get their unix path right.
    exec convert /tmp/junk.xwd $fn
    # exec $_ytk(convert) /tmp/junk.xwd $fn
    file delete -force /tmp/junk.xwd
  }
}

proc restore_eaarl_defaults { } {

} 

proc restore_eaarl_options { fn opt_array } {
# DOCUMENT restore_eaarl_options fn opt_array
# 
# fn		File name to restore options from.
# opt_array	The name of the option array you want to restore.
#
# This procedure is intended to be used by any eaarl module for restoring it's
# options.
#
 upvar $opt_array ary
 global $opt_array
 set dir "~/.eaarl";
 set f "$dir/$fn"
 if { [ file exists $f ] == 0 } {
#      tk_messageBox  -icon warning \
#	-message "$f Doesn't exist. Click on \"Save Map Options\" to establish the file."  \
#	-type ok
    return
 }
 source $f

} 

proc save_eaarl_options { fn opt_array } {
# DOCUMENT save_eaarl_options fn opt_array
# 
# fn		File name to save options to.
# opt_array	The option array you want to save.
#
# This procedure is intended to be used by any eaarl module for saving it's
# options.
#
 upvar $opt_array ary
 
 set dir "~/.eaarl";
 if { [ file exists $dir ] == 0 } {
      tk_messageBox  -message "Creating $dir subdirectory to store program options"  -type ok
      file mkdir $dir
 }

 set f "$dir/$fn"
 if { [ file exists $f ] == 0 } {
      tk_messageBox  -message "Creating $f to store eaarl options"  -type ok
 }
 set fd [ open $f "w+" ];

 set names [ array names ary ] 
 puts $fd "#   EAARL Settings"
 foreach x $names {
   set s [ format "set %32s    %-32s"  "$opt_array\($x\)" $ary($x) ];
   puts $fd "$s"
 }
 close $fd
 tk_messageBox -icon info -message "Options saved to: $f" -type ok
}

proc load_cmd { start_dir } {
 global _ytk_fn y_codedir ytk_codedir _ytk_mrl _ytk_mrl_idx
  set _ytk_fn [ tk_getOpenFile \
        -initialdir $start_dir \
        -filetypes \
        {
           {{Yorick Programs} {.i}  }
           {{Yorick or Tcl/tk program} {.i .ytk}  }
           {{Yorick Specfic Tcl/Tk Programs} {.ytk} }
           {{Tcl/Tk Programs} {.tcl .tk} }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".tcl" -
    ".tk"  -
    ".ytk" {
            uplevel { source $_ytk_fn }
           }
    ".i"   {
            set ycode_dir [ file dirname $_ytk_fn ]
            cd $ycode_dir;
            exp_send "cd, \"$ycode_dir\"\r"
            exp_send "load_cmd, \"$_ytk_fn\"\r"
           }

    }
  }
}



proc start_sf {} {
 global cir_id
    exec ./sf_a.tcl -parent [::comm::comm self] -cir $cir_id &
}

proc init_sf {} {
 global data_path
    send_sf set dir $data_path
}

proc start_cir {} {
 global sf_a_id
    exec ./cir.tcl -parent [::comm::comm self] -sf $sf_a_id &
}

proc init_cir {} {
 global data_path
    send_cir cirdir "$data_path/cir"
}

proc edb_loaded { } {
 global edb 
 if { [ info exists edb ] == 0 } {
   tk_messageBox -type ok \
        -icon warning \
        -message { edb_loaded: No EDB (EAARL Data Base) is loaded }
  set rv 0;
 } else { 
   set rv  1;
 } 
 return $rv;
}

proc edb_status { } {
 global edb;
 destroy .edb
 if { [ edb_loaded ] == 0 } {
   return;
 }
 
 toplevel .edb
 set v " \
        Year                            year \
        {Day of Year}                   day \
         Path                           path \
        {Index File}                    idx_file \
        {Total Data (GB)}               gb \
        {Number of Files}               number_of_files \
        {Total Rasters}                 nbr_rasters \
        {First Good Raster}             data_begins \
        {Last Good Raster}              data_ends \
        {Mission Duration (Hours)}      mission_duration \
        {Seconds of the Epoch at day start}          soe \
        {eaarl_time_offset}          	eaarl_time_offset \
       "
 
  set edb(idx_file) [ file tail $edb(idx_file) ]
  set row 0
  foreach {lbl x} $v {
    label .edb.$x\lbl -text "$lbl:" -relief sunken -anchor e -padx 5
    label .edb.v$x    -text  $edb($x) -relief sunken -padx 5
    grid  .edb.$x\lbl -column 0  -row $row -sticky ew
    grid  .edb.v$x    -column 1  -row $row -sticky ew
    incr row
  }
  button .edb.dismiss -text Dismiss -command { destroy .edb }
  grid .edb.dismiss -row $row -columnspan 2 -sticky ew
 
}

proc load_edb {} {
 global data_path
   exp_send "load_edb, update=0\r"
  expect "load_edb_completed"
  expect ">"
  edb_status
  if { [sf_exists] } {
     send_sf "set dir $data_path"
  } else {
      set sfrun [ tk_messageBox  \
           -message "Digital Camera Playback Software\
 isn\'t running. Would you like to run it now?  " \
           -type yesno ]
      switch  -- $sfrun {
	yes start_sf;
      }
  }
}

#####################################################################
# main
# Set the source code path for this invocation.  It can 
# then be used to load the other modules.
#####################################################################
   set data_path "/data/"
   set src_path  [ file dirname [ info script ] ]
   cd $src_path
   exp_send "cd, \"$src_path\"\r"
   exp_send "src_path= \"$src_path\"\r"
   # send ytk process id to yorick global variable _pid.
   exp_send "_pid = [pid]\r";

   exp_send "#include \"eaarl.i\"\r"

####   exp_send "#include \"edb_access.i\"\r"
####   exp_send "#include \"map.i\"\r"

   set w .eaarl
   global w
   destroy  $w
   toplevel $w
   frame $w.f -width 450
   pack $w.f

  $w configure -menu $w.mb
   menu $w.mb
   menu $w.mb.file
   menu $w.mb.nav
   menu $w.mb.attitude
   menu $w.mb.rasters
   menu $w.mb.images
   menu $w.mb.time
   menu $w.mb.new
   menu $w.mb.help

 $w.mb add cascade -label File     -underline 0 -menu $w.mb.file
 $w.mb add cascade -label "Maps/Nav"     -underline 0 -menu $w.mb.nav
 $w.mb add cascade -label "Settings"     -underline 0 -menu $w.mb.attitude
 $w.mb add cascade -label Rasters  -underline 0 -menu $w.mb.rasters
 $w.mb add cascade -label Images   -underline 0 -menu $w.mb.images
 $w.mb add cascade -label Time     -underline 0 -menu $w.mb.time
 $w.mb add cascade -label New      -underline 0 -menu $w.mb.new
 $w.mb add cascade -label Help     -underline 0 -menu $w.mb.help

 $w.mb.file add command -label "Load EAARL Database Index (Edb)..." -command { load_edb } \
	-underline 5
 $w.mb.file add command -label "Load EAARL from Conf..." -command { source "$src_path/confload.ytk" } -underline 16

 exp_send "require, \"rbgga.i\"\r"
 source rbgga.ytk
 $w.mb.file add command -label "Coastlines & Flight tracks"   -underline 13 \
	-command rbgga_menu
 $w.mb.file add command -label "Load DMARS Attitude data..."   -underline 5 \
   -command  load_dmars;
 $w.mb.file add command -label "Load Tans Attitude data..."   -underline 5 \
   -command { exp_send "require, \"rbtans.i\"\r"
   	      expect ">"
    	      exp_send "tans = rbtans() \r" }
 $w.mb.file add command -label "Load GPS PNAV data..."   -underline 9 \
   -command { exp_send "require, \"rbpnav.i\"\r"
    	      expect ">"
     	      exp_send "pnav = rbpnav() \r" }

  $w.mb.file add separator

 $w.mb.file add command -label "Edb Status" -command  edb_status 

 $w.mb.file add command -label "Load command file..." -command { 
   load_cmd $data_path 
 }
 $w.mb.file add command -label "Edit missions notes..." -command  {
   if { [ edb_loaded ] } { 
     ytk_kick_off_editor  $_ytk(editor) "$edb(path)/notes.txt"    
   }
 } 
 $w.mb.file add command -label Dismiss -command { destroy $w }

 source "$src_path/map.ytk"
 restore_eaarl_options "map.options" _map

#############
#   Rasters
#############
 $w.mb.rasters add command -label "Examine Rasters..." -command {
   source "$src_path/drast.ytk"
 }

#############
#   Images
#############
 $w.mb.images add command -label "Load Images in Yorick..." -command {
 	source "$src_path/image_load_tool.ytk"
 	ytk_image_load_tool 
 }
 $w.mb.images add command -label "Capture a display..." -command {
    scap
 }
 $w.mb.images add command -label "1-Hz RGB Low-Res Images..." -command {
    start_sf
 }
 $w.mb.images add command -label "1-Hz CIR High-Res Images..." -command {
    start_cir
 }
 $w.mb.images add command -label "Process Lidar Data..." -command {
    source "$src_path/l1pro.ytk"
 }
 $w.mb.images add command -label "Lidar First Return Surface..." -command {
 }
 $w.mb.images add command -label "Lidar Last Return Sub-aerial Surface..." -command {
 }
 $w.mb.images add command -label "Lidar Bathymetric Surface..." -command {
 }


##############################
#   Attitude Sensors
#############################9
 $w.mb.attitude add command -label "Load Ops_conf Settings..." \
	-command load_ops_conf 
 $w.mb.attitude add command -label "Current Ops_conf Settings..." \
	-command { exp_send "display_mission_constants, ops_conf, ytk=1\r"; }
 $w.mb.attitude add command -label "TANS Settings..." \
	-command { exp_send "display_mission_constants, ops_tans, ytk=1\r"; }
 $w.mb.attitude add command -label "DMARS Settings..." \
	-command { exp_send "display_mission_constants, ops_IMU2, ytk=1\r"; }
 $w.mb.attitude add command -label "Applanix 510 Settings..." \
	-command { exp_send "display_mission_constants, ops_IMU1, ytk=1\r"; }

#############
#   Nav
#############


 $w.mb.nav add command -label "Yorick Flight Planning..." \
	-command { exp_send "require, \"nav.i\"\r" }


 set gga_color black

 exp_send "require, \"rbgga.i\"\r"
 menu $w.mb.nav.rbgga
 $w.mb.nav add command -label "Flight Tracks & Coastlines..."   -underline 0 \
	-command rbgga_menu
 $w.mb.nav add command -label "Load Tans Attitude data..."   -underline 5 \
   -command { exp_send "require, \"rbtans.i\"\r"
   	      expect ">"
    	      exp_send "tans = rbtans() \r" }
 $w.mb.nav add command -label "Load GPS PNAV data..."   -underline 9 \
   -command { exp_send "require, \"rbpnav.i\"\r"
    	      expect ">"
     	      exp_send "pnav = rbpnav() \r" }
 $w.mb.nav add command -label "Load DMARS data..."   -underline 5 \
   -command load_dmars

 set clist "black red blue green cyan magenta yellow white"







#############
#   Time
#############
 $w.mb.time add command -label "Time..." -command {  

 }
 $w.mb.time add command -label "Check and correct EDB time..." -command {
  source "$src_path/ts_check.ytk"; ts_check;
 }

#############
#   New
#############
 $w.mb.new add command -label "mtransect"     -command {  
      exp_send "require,\"transect.i\"; help,mtransect\r" 
 }
 $w.mb.new add command -label "batch_process" -command {  
      exp_send "require, \"batch_process.i\"; help,batch_process\r" 
 }

#############
#   help
#############
 $w.mb.help add command \
   -label "Version:\$Id$"
 $w.mb.help add command -label "Yorick Graphics Window Use"
 $w.mb.help add command -label "0 Waveform Display"
 $w.mb.help add command -label "1 Laser Rasters"
 $w.mb.help add command -label "2 "
 $w.mb.help add command -label "3 "
 $w.mb.help add command -label "4 "
 $w.mb.help add command -label "5 Laser point plots"
 $w.mb.help add command -label "6 Coast maps, NMEA GGA nav data"
 $w.mb.help add command -label "7 Geographic maps and Nav data"




## disabled unused menu options
$w.mb.nav entryconfigure 1 -state normal
$w.mb.images entryconfigure 6 -state disabled
$w.mb.images entryconfigure 7 -state disabled
$w.mb.images entryconfigure 8 -state disabled

