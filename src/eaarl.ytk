#
#  eaarl.ytk 
#
# To Do
#  Default and option settings.
#
#  1/4/2002  
#  WW Added "Edit notes.txt" option in file.  Use this for quick access
#  to the mission notes with your favorit editor. It uses the editor selected
#  in the Ytk Edit menu.
#
#
#

package require sf

package require comm
set sf_a_id -1
set cir_id -1

proc send_sf { args } {
# Send a message to sf_a.tcl safely
    global sf_a_id
    if { $sf_a_id != -1 } {
        if { [catch { eval ::comm::comm send $sf_a_id $args }] } {
            set sf_a_id -1
        }
    }
}

proc send_cir { args } {
# Send a message to cir.tcl safely
    global cir_id
    if { $cir_id != -1 } {
        if { [catch { eval ::comm::comm send $cir_id $args }] } {
            set cir_id -1
        }
    }
}

proc sf_exists { } {
# See if sf_a exists
    global sf_a_id
    return [expr {$sf_a_id != -1}]
}

proc cir_exists { } {
# See if cir exists
	global cir_id
	return [expr {$cir_id != -1}]
}

proc center_win { win } {
# Center a window.
 set lx [ expr [winfo screenwidth  $win]/2 - [winfo width  $win]/2 ]
 set ly [ expr [winfo screenheight $win]/2 - [winfo height $win]/2 ]
 wm geometry $win "+$lx+$ly"
 wm deiconify $win
 update
}

proc display_mission_constants { l } {
  global w1
  array set ary $l
  set w1 .$ary(VarName)
  destroy $w1
  toplevel $w1
  set row 0
  foreach {lbl x} $l {
    label $w1.l$lbl -text "$lbl:" -relief sunken -anchor e -padx 5
    label $w1.v$lbl{v}    -text  $x -relief sunken -padx 5
    grid  $w1.l$lbl -column 0  -row $row -sticky ew
    grid  $w1.v$lbl{v}    -column 1  -row $row -sticky ew
    incr row
  }
  button $w1.dismiss -text "Dismiss" -command {
       destroy $w1 }

  button $w1.set     -text "Use these" -command "eval { 
     exp_send ops_conf=$ary(VarName)\\r; 
     destroy $w1 }" 
  grid  $w1.dismiss -row $row -column 0
  grid  $w1.set -row $row -column 1 -sticky ew
  center_win $w1
}

proc load_dmars {} { 
  global data_path
      if { [ info exists data_path ] } {
       set tpath "$data_path/trajectories/";
       if { [ expr ![ file isdirectory $tpath ]] } {
         set tpath $data_path;
       }
    } else {
       set tpath "";
    }

  set _ytk_fn [ tk_getOpenFile \
	-initialdir $tpath \
	-filetypes \
        {
           {{Yorick PBD file} {.pbd}  }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".pbd" {
	     exp_send "load_iexpbd,\"$_ytk_fn\"";
#            exp_send "_ytk_pbd_f = openb(\"$_ytk_fn\"); restore, _ytk_pbd_f;\r"
#            exp_send "show, _ytk_pbd_f\r"
#            exp_send "iex2tans;\r"
               toplevel .stby
            exp_send "\r\n"
   set sz [ wm maxsize . ]
               label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
               pack .stby.lbl
   set wz "50 50"
   set sx [ expr [ lindex $sz 0 ] / 2  - [lindex $wz 0]/2 ]
   set sy [ expr [ lindex $sz 1 ] / 2  - [lindex $wz 1]/2 ]
   wm geometry .stby "+$sx+$sy"
               update
            expect ">"
               destroy .stby
           }
    }
  }
}


proc load_ops_conf {} { 
  global data_path
      if { [ info exists data_path ] } {
       set tpath "$data_path/";
       if { [ expr ![ file isdirectory $tpath ]] } {
         set tpath $data_path;
       }
    } else {
       set tpath "";
    }

  set _ytk_fn [ tk_getOpenFile \
	-initialdir $tpath \
	-filetypes \
        {
           {{Yorick .i files} {.i}  }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".i" {
	     exp_send "#include \"$_ytk_fn\"";
            toplevel .stby
            exp_send "\r\n"
   set sz [ wm maxsize . ]
               label .stby.lbl -text "Loading\n$_ytk_fn\nplease wait.."
               pack .stby.lbl
   set wz "50 50"
   set sx [ expr [ lindex $sz 0 ] / 2  - [lindex $wz 0]/2 ]
   set sy [ expr [ lindex $sz 1 ] / 2  - [lindex $wz 1]/2 ]
   wm geometry .stby "+$sx+$sy"
               update
            expect ">"
               destroy .stby
         }
    }
  }
}

proc send_sod_to_sf { somd } {
  catch {
   send_sf set timern sod
   send_sf set hsr $somd
   send_sf gotoImage
  }
  ybkg sf_mediator_broadcast_somd $somd
}

proc send_tans_to_sf {somd p r h} {
   catch {
    send_sf set pitch $p
    send_sf set roll $r
    send_sf set head $h
    send_sf gotoImage
   }
}


proc path_exists { path } {
# Test if a path exists, and pop up warning if not.
  if { [ file isdirectory $path ]  == 0 } {
    tk_messageBox \
	-icon warning \
	-type ok \
	-message "$path doesn't exist."
  }
}

proc scap { } {
# DOCUMENT scap
# Do a screen capture of a mouse selected window.
#
# Capture a mouse selected window to an image file.  This proc
# uses the xwd command to capture a selected window to an 
# /tmp/*.xwd file and then uses the convert command to covert
# that file to any number of different formats.  Once the image
# has been stored in the desired format, the /tmp/*.xwd file
# is deleted.
#  global capture_path data_path capture_name _ytk
 global capture_path data_path capture_name
  if { [ info exists capture_path ] == 0 } {
    if { [ info exists data_path ] } {
       set capture_path $data_path
    } else {
       set capture_path "";
    }
  }
  if { [info exists capture_name ] == 0 } {
    set capture_name "";
  }
  tk_messageBox -type ok \
	-message {Raise the window you want to capture, \
click OK, and then click on the desired window.}
  update
  exec xwd -out /tmp/junk.xwd;
  set fn [tk_getSaveFile  -initialdir $capture_path \
	-defaultextension .png \
	-initialfile $capture_name \
 	 ]
  if { $fn != "" } {
    set capture_name [ file tail $fn ]
    set ext [ file extension $fn ]
    set n [ lsearch ".jpg .gif .png .bmp .pnm .tif .tiff" $ext ]
    set capture_path [ file dirname $fn ]
    if { $n == -1 } {
      set fn "[ file rootname $fn ].png"
    }
    update
    # Require the user to get their unix path right.
    exec convert /tmp/junk.xwd $fn
    # exec $_ytk(convert) /tmp/junk.xwd $fn
    file delete -force /tmp/junk.xwd
  }
}

proc restore_eaarl_defaults { } {

} 

proc restore_eaarl_options { fn opt_array } {
# DOCUMENT restore_eaarl_options fn opt_array
# 
# fn		File name to restore options from.
# opt_array	The name of the option array you want to restore.
#
# This procedure is intended to be used by any eaarl module for restoring it's
# options.
#
 upvar $opt_array ary
 global $opt_array
 set dir "~/.eaarl";
 set f "$dir/$fn"
 if { [ file exists $f ] == 0 } {
#      tk_messageBox  -icon warning \
#	-message "$f Doesn't exist. Click on \"Save Map Options\" to establish the file."  \
#	-type ok
    return
 }
 source $f

} 

proc save_eaarl_options { fn opt_array } {
# DOCUMENT save_eaarl_options fn opt_array
# 
# fn		File name to save options to.
# opt_array	The option array you want to save.
#
# This procedure is intended to be used by any eaarl module for saving it's
# options.
#
 upvar $opt_array ary
 
 set dir "~/.eaarl";
 if { [ file exists $dir ] == 0 } {
      tk_messageBox  -message "Creating $dir subdirectory to store program options"  -type ok
      file mkdir $dir
 }

 set f "$dir/$fn"
 if { [ file exists $f ] == 0 } {
      tk_messageBox  -message "Creating $f to store eaarl options"  -type ok
 }
 set fd [ open $f "w+" ];

 set names [ array names ary ] 
 puts $fd "#   EAARL Settings"
 foreach x $names {
   set s [ format "set %32s    %-32s"  "$opt_array\($x\)" $ary($x) ];
   puts $fd "$s"
 }
 close $fd
 tk_messageBox -icon info -message "Options saved to: $f" -type ok
}

proc load_cmd { start_dir } {
 global _ytk_fn y_codedir ytk_codedir _ytk_mrl _ytk_mrl_idx
  set _ytk_fn [ tk_getOpenFile \
        -initialdir $start_dir \
        -filetypes \
        {
           {{Yorick Programs} {.i}  }
           {{Yorick or Tcl/tk program} {.i .ytk}  }
           {{Yorick Specfic Tcl/Tk Programs} {.ytk} }
           {{Tcl/Tk Programs} {.tcl .tk} }
           {{All Files}       {*}   }
        }  ]
  if { $_ytk_fn != "" } {
    switch [ file extension $_ytk_fn ] {
    ".tcl" -
    ".tk"  -
    ".ytk" {
            uplevel { source $_ytk_fn }
           }
    ".i"   {
            set ycode_dir [ file dirname $_ytk_fn ]
            cd $ycode_dir;
            exp_send "cd, \"$ycode_dir\"\r"
            exp_send "#include \"$_ytk_fn\"\r"
            exp_send "cd, src_path\r"
           }

    }
  }
}

proc init_sf {} {
 global data_path
    send_sf set dir $data_path
}

proc init_cir {} {
 global data_path
    send_cir cirdir "$data_path/cir"
}

proc edb_loaded { } {
 global edb 
 if { [ info exists edb ] == 0 } {
   tk_messageBox -type ok \
        -icon warning \
        -message { edb_loaded: No EDB (EAARL Data Base) is loaded }
  set rv 0;
 } else { 
   set rv  1;
 } 
 return $rv;
}

proc edb_status { } {
 global edb;
 destroy .edb
 if { [ edb_loaded ] == 0 } {
   return;
 }
 
 toplevel .edb
 set v " \
        Year                            year \
        {Day of Year}                   day \
         Path                           path \
        {Index File}                    idx_file \
        {Total Data (GB)}               gb \
        {Number of Files}               number_of_files \
        {Total Rasters}                 nbr_rasters \
        {First Good Raster}             data_begins \
        {Last Good Raster}              data_ends \
        {Mission Duration (Hours)}      mission_duration \
        {Seconds of the Epoch at day start}          soe \
        {eaarl_time_offset}          	eaarl_time_offset \
       "
 
  set edb(idx_file) [ file tail $edb(idx_file) ]
  set row 0
  foreach {lbl x} $v {
    label .edb.$x\lbl -text "$lbl:" -relief sunken -anchor e -padx 5
    label .edb.v$x    -text  $edb($x) -relief sunken -padx 5
    grid  .edb.$x\lbl -column 0  -row $row -sticky ew
    grid  .edb.v$x    -column 1  -row $row -sticky ew
    incr row
  }
  button .edb.dismiss -text Dismiss -command { destroy .edb }
  grid .edb.dismiss -row $row -columnspan 2 -sticky ew
 
}

proc load_edb {} {
 global data_path
   exp_send "load_edb, update=0\r"
  expect "load_edb_completed"
  expect ">"
  after 2000 {
  edb_status
  if { [sf_exists] } {
     send_sf "set dir $data_path"
  }
  wm title .eaarl "Current Data: $data_path"
  }
}

#####################################################################
# main
# Set the source code path for this invocation.  It can 
# then be used to load the other modules.
#####################################################################
   set data_path "/data/"
   set src_path  [ file dirname [ info script ] ]
   cd $src_path
   ybkg cd \"$src_path\"
   ybkg funcset src_path \"$src_path\"
   # send ytk process id to yorick global variable _pid.
   ybkg require \"eaarl.i\"

   source [file join $src_path mission_conf.ytk]

####   exp_send "#include \"edb_access.i\"\r"
####   exp_send "#include \"map.i\"\r"

   set w .eaarl
   global w
   destroy  $w
   toplevel $w
   wm protocol $w WM_DELETE_WINDOW [list wm withdraw $w]
   frame $w.f -width 440
   pack $w.f

  $w configure -menu $w.mb
   menu $w.mb
   menu $w.mb.file
   menu $w.mb.nav
   menu $w.mb.attitude
   menu $w.mb.rasters
   menu $w.mb.images
   menu $w.mb.time
   menu $w.mb.deprecated

   ybkg require \"rbgga.i\"

 $w.mb add cascade -label File     -underline 0 -menu $w.mb.file
 $w.mb add cascade -label "Maps/Nav"     -underline 0 -menu $w.mb.nav
 $w.mb add cascade -label "Settings"     -underline 0 -menu $w.mb.attitude
 $w.mb add cascade -label "Lidar"  -underline 0 -menu $w.mb.rasters
 $w.mb add cascade -label Imagery   -underline 0 -menu $w.mb.images
 $w.mb add cascade -label Time     -underline 0 -menu $w.mb.time
 $w.mb add cascade -label Deprecated -underline 0 -menu $w.mb.deprecated

 $w.mb.file add command -label "Load command file..." -command { 
   load_cmd $data_path 
 }
 $w.mb.file add command -label "Edit missions notes..." -command  {
   if { [ edb_loaded ] } { 
     ytk_kick_off_editor  $_ytk(editor) "$edb(path)/notes.txt"    
   }
 } 

 source "$src_path/map.ytk"
 restore_eaarl_options "map.options" _map

#############
#  Lidar / Rasters 
#############
 $w.mb.rasters add command -label "Examine Lidar Rasters..." -command {
   source "$src_path/drast.ytk"
 }
 $w.mb.rasters add command -label "Process Lidar Data..." -command {
    wm deiconify .l1wid
 }

#############
#   Images
#############
 $w.mb.images add command -label "Load Images in Yorick..." -command {
 	source "$src_path/image_load_tool.ytk"
 	ytk_image_load_tool $data_path
 }
 $w.mb.images add command -label "Launch new SF viewer..." \
   -command [list ::sf::controller %AUTO%]

##############################
#   Attitude Sensors
#############################9
 $w.mb.attitude add command -label "Load Ops_conf Settings..." \
	-command load_ops_conf 
 $w.mb.attitude add command -label "Current Ops_conf Settings..." \
	-command { exp_send "display_mission_constants, ops_conf, ytk=1\r"; }
 $w.mb.attitude add command -label "TANS Settings..." \
	-command { exp_send "display_mission_constants, ops_tans, ytk=1\r"; }
 $w.mb.attitude add command -label "DMARS Settings..." \
	-command { exp_send "display_mission_constants, ops_IMU2, ytk=1\r"; }
 $w.mb.attitude add command -label "Applanix 510 Settings..." \
	-command { exp_send "display_mission_constants, ops_IMU1, ytk=1\r"; }

#############
#   Nav
#############


 $w.mb.nav add command -label "Yorick Flight Planning..." \
	-command { exp_send "require, \"nav.i\"\r" }


 set gga_color black

 $w.mb.nav add command -label "Load Ground PNAV (gt_pnav) data..."   -underline 12 \
   -command {
     	        exp_send "gt_pnav = load_pnav() \r" }

 $w.mb.nav add command -label "Load Ground PNAV2FS (gt_fs) data..."   -underline 12 \
   -command { 
              exp_send "\r"
     	        expect ">"
     	        exp_send "gt_fs = load_pnav2FS(); grow, gt_fsall, gt_fs\r"
              append_varlist gt_fs
              append_varlist gt_fsall
            }

 set clist "black red blue green cyan magenta yellow white"

#############
#   Time
#############
 $w.mb.time add command -label "Check and correct EDB time..." -command {
  source "$src_path/ts_check.ytk"; ts_check;
 }

#############
#   Deprecated
#############

## disabled unused menu options
$w.mb.nav entryconfigure 1 -state normal

# Since ybkg is used, some output may go to the console (especially Yeti), so
# this gives the user back their prompt.
exp_send \r
expect ">"

source "$src_path/l1pro.ytk"
if {[yget alpsrc.l1pro_startup]} {
   wm deiconify .l1wid
   wm withdraw .eaarl
}
