#
# $Id$
#
#
#
#  eaarl.ytk 
#
# To Do
#  Default and option settings.
#
#  1/4/2002  
#  WW Added "Edit notes.txt" option in file.  Use this for quick access
#  to the mission notes with your favorit editor. It uses the editor selected
#  in the Ytk Edit menu.
#
#  edb_access update option
#  save offset changes to edb files
#  time check options
#  check for numberof(edb) in time check
#
#

proc restore_eaarl_defaults { } {

} 

proc restore_eaarl_options { fn opt_array } {
# DOCUMENT restore_eaarl_options fn opt_array
# 
# fn		File name to restore options from.
# opt_array	The name of the option array you want to restore.
#
# This procedure is intended to be used by any eaarl module for restoring it's
# options.
#
 upvar $opt_array ary
 global $opt_array
 set dir "~/.eaarl";
 set f "$dir/$fn"
 if { [ file exists $f ] == 0 } {
      tk_messageBox  -icon warning \
	-message "$f Doesn't exist. Click on \"Save Map Options\" to establish the file."  \
	-type ok
    return
 }
 source $f

} 

proc save_eaarl_options { fn opt_array } {
# DOCUMENT save_eaarl_options fn opt_array
# 
# fn		File name to save options to.
# opt_array	The option array you want to save.
#
# This procedure is intended to be used by any eaarl module for saving it's
# options.
#
 upvar $opt_array ary
 
 set dir "~/.eaarl";
 if { [ file exists $dir ] == 0 } {
      tk_messageBox  -message "Creating $dir subdirectory to store program options"  -type ok
      file mkdir $dir
 }

 set f "$dir/$fn"
 if { [ file exists $f ] == 0 } {
      tk_messageBox  -message "Creating $f to store eaarl options"  -type ok
 }
 set fd [ open $f "w+" ];

 set names [ array names ary ] 
 puts $fd "#   EAARL Settings"
 foreach x $names {
   set s [ format "set %32s    %-32s"  "$opt_array\($x\)" $ary($x) ];
   puts $fd "$s"
 }
 close $fd
 tk_messageBox -icon info -message "Options saved to: $f" -type ok
}


proc start_sf {} {
 global data_path
    exec "./sf_a.tcl" &
    after 2000 " send sf_a.tcl \"set dir $data_path\" " 
}

proc edb_loaded { } {
 global edb 
 if { [ info exists edb ] == 0 } {
   tk_messageBox -type ok \
        -icon warning \
        -message { No EDB (EAARL Data Base) is loaded }
  set rv 0;
 } else { 
   set rv  1;
 } 
 return $rv;
}

proc edb_status { } {
 global edb;
 destroy .edb
 if { [ edb_loaded ] == 0 } {
   return;
 }
 
 toplevel .edb
 set v " \
        Year                            year \
        {Day of Year}                   day \
         Path                           path \
        {Index File}                    idx_file \
        {Total Data (GB)}               gb \
        {Number of Files}               number_of_files \
        {Total Rasters}                 nbr_rasters \
        {First Good Raster}             data_begins \
        {Last Good Raster}              data_ends \
        {Mission Duration (Hours)}      mission_duration \
        {Seconds of the Epoch at day start}          soe \
        {eaarl_time_offset}          	eaarl_time_offset \
       "
 
  set edb(idx_file) [ file tail $edb(idx_file) ]
  set row 0
  foreach {lbl x} $v {
    label .edb.$x\lbl -text "$lbl:" -relief sunken -anchor e -padx 5
    label .edb.v$x    -text  $edb($x) -relief sunken -padx 5
    grid  .edb.$x\lbl -column 0  -row $row -sticky ew
    grid  .edb.v$x    -column 1  -row $row -sticky ew
    incr row
  }
  button .edb.dismiss -text Dismiss -command { destroy .edb }
  grid .edb.dismiss -row $row -columnspan 2 -sticky ew
 
}

proc load_edb {} {
 global data_path
   exp_send "load_edb, update=0\r"
  expect "load_edb_completed"
  edb_status
  if { [ lsearch -exact [ winfo interps ] sf_a.tcl ] != -1 } {
     send sf_a.tcl "set dir $data_path"
  } else {
      set sfrun [ tk_messageBox  \
           -message "Digital Camera Playback Software\
 isn\'t running. Would you like to run it now?  " \
           -type yesno ]
      switch  -- $sfrun {
	yes start_sf;
      }
  }
}

# Set the source code path for this invocation.  It can 
# then be used to load the other modules.
   set src_path  [ file dirname [ info script ] ]
   cd $src_path
   exp_send "cd, \"$src_path\"\r"

   exp_send "#include \"edb_access.i\"\r"
   exp_send "#include \"map.i\"\r"

   set w .eaarl
   global w
   destroy  $w
   toplevel $w
   frame $w.f -width 450
   pack $w.f

  $w configure -menu $w.mb
   menu $w.mb
   menu $w.mb.file
   menu $w.mb.map
   menu $w.mb.nav
   menu $w.mb.rasters
   menu $w.mb.images
   menu $w.mb.time
   menu $w.mb.help

 $w.mb add cascade -label File     -underline 0 -menu $w.mb.file
 $w.mb add cascade -label Map      -underline 0 -menu $w.mb.map
 $w.mb add cascade -label Nav/Attitude      -underline 0 -menu $w.mb.nav
 $w.mb add cascade -label Rasters  -underline 0 -menu $w.mb.rasters
 $w.mb add cascade -label Images   -underline 0 -menu $w.mb.images
 $w.mb add cascade -label Time     -underline 0 -menu $w.mb.time
 $w.mb add cascade -label Help     -underline 0 -menu $w.mb.help

 $w.mb.file add command -label "Load Edb..." -command { load_edb }
 $w.mb.file add command -label "Edb Status" -command  edb_status 
 $w.mb.file add command -label "Edit missions notes..." -command  {
   if { [ edb_loaded ] } { 
     ytk_kick_off_editor  $_ytk(editor) "$edb(path)/notes.txt"    
   }
 } 
 $w.mb.file add command -label Dismiss -command { destroy $w }

 source map.ytk

#############
#   Rasters
#############
 $w.mb.rasters add command -label "Examine Rasters..." -command {
   source drast.ytk
 }

#############
#   Images
#############
 $w.mb.images add command -label "1-Hz Digital Camera Images..." -command {
    start_sf
 }
 $w.mb.images add command -label "Process Level 1 Lidar Data..." -command {
    source l1pro.ytk 
 }
 $w.mb.images add command -label "Lidar First Return Surface..." -command {
 }
 $w.mb.images add command -label "Lidar Last Return Sub-aerial Surface..." -command {
 }
 $w.mb.images add command -label "Lidar Bathymetric Surface..." -command {
 }

#############
#   Nav
#############


 $w.mb.nav add command -label "Flight Planning..." \
	-command { exp_send "#include \"nav.i\"\r" }


 set gga_color black

 exp_send "#include \"rbgga.i\"\r"
 menu $w.mb.nav.rbgga
 $w.mb.nav add command -label "Rbgga..."   -underline 2 \
	-command rbgga_menu
#####	-menu $w.mb.nav.rbgga
 $w.mb.nav add command -label "Rbtans..."   -underline 2 \
   -command { exp_send "#include \"rbtans.i\"\r"
   	      expect ">"
    	      exp_send "tans = rbtans() \r" }
 $w.mb.nav add command -label "Rbpnav..."   -underline 2 \
   -command { exp_send "#include \"rbpnav.i\"\r"
    	      expect ">"
     	      exp_send "pnav = rbpnav() \r" }

#####  $w.mb.nav.rbgga add command -label "Rbgga..." -command rbgga_menu

 set clist "black red blue green cyan magenta yellow white"



proc request_heading {psf inhd_count} {
   ## this procedure requests heading information for sf_a.tcl
   ## amar nayegandhi
   if {($inhd_count == 1)} {
     exp_send "#include \"rbtans.i\"\r" 
     expect ">"
     exp_send "if (is_void(tans)) tans=rbtans(); pkt_sf = prepare_sf_pkt(tans); \r"
     ## function prepare_sf_pkt is defined in rbtans.i
   } else { exp_send "pkt_sf = prepare_sf_pkt(tans); \r"}

   ## write pkt_sf to a temp file
   set tmpfile "/tmp/sf_tans.txt.$psf"
   #exp_send "make_sf_tans_file(\"$tmpfile\");"

   }


proc mark_pos { lat lon } {
  global utm
  scan $lat "%1s%2f%f" df dd mm
  set lat [ expr $dd + $mm/60.0 ]
  if { $df == "S" } {
    set lat [ expr -$lat ]
  }
  scan $lon "%1s%3f%f" df dd mm
  set lon [ expr $dd + $mm/60.0 ]
  if { $df == "W" } {
    set lon [ expr -$lon ]
  }
  if {$utm == 0} {
  exp_send "wsav=window();window,6; plmk, $lat, $lon, msize=.5, marker=1, color=\"red\"; window,wsav\r"
  } else {
  exp_send "ll2utm, $lat, $lon; \r"
  expect ">"
  exp_send "wsav=window();window,6; plmk, UTMNorthing, UTMEasting, msize=.5, marker=1, color=\"red\"; window,wsav\r"
  }
}


proc rbgga_menu {} {
 global ytk_PLMK_marker
 global data_path
 global _ytk utm
 set gga(null) ""
 set mw .rbgga
 destroy $mw
 toplevel $mw
 wm title $mw "eaarl.rbgga: "
 frame $mw.g1 -relief groove -borderwidth 3
 label $mw.g1.lulb -text "Coordinates:" -anchor e
 tk_optionMenu $mw.g1.lu gga(llu) latlon utm
 grid $mw.g1.lulb $mw.g1.lu -sticky ew

 label $mw.g1.lwlb -text "Line Width:" -anchor e
 tk_optionMenu $mw.g1.lw   gga(linewidth) 1 3 5 7 10 12 15 20 25
 grid $mw.g1.lwlb $mw.g1.lw -sticky ew

 label $mw.g1.lclb -text "Line Color:" -anchor e
 tk_optionMenu $mw.g1.lc   gga(linecolor) black red blue green cyan magenta yellow white
 grid $mw.g1.lclb $mw.g1.lc -sticky ew

 label $mw.g1.skiplb -text "Points to skip:" -anchor e
 tk_optionMenu $mw.g1.skip gga(skip) 0 1 2 5 10 15 20 25 50 75 100  
 grid $mw.g1.skiplb $mw.g1.skip -sticky ew

# label $mw.g1.markerslb -text "Use Markers:" -anchor e
# tk_optionMenu $mw.g1.markers gga(markers) Yes No
# grid $mw.g1.markerslb $mw.g1.markers -sticky ew

 label $mw.g1.mshapelb -text "Marker shape:" -anchor e
 tk_optionMenu $mw.g1.mshape gga(mshape) None Square Cross \
	Triangle Circle Diamond Cross45 "Inverted-Triangle"
 grid $mw.g1.mshapelb $mw.g1.mshape -sticky ew

 label $mw.g1.msizelb -text "Marker size:" -anchor e
 tk_optionMenu $mw.g1.msize gga(msize) .1 .2 .3 .4 .5 \
	.6 .7 1.0 1.5 2.0 2.5 3.0 5.0 10.0 
 grid $mw.g1.msizelb $mw.g1.msize -sticky ew

 frame $mw.f1 -relief groove -borderwidth 3
 button $mw.f1.load -text "Load" -command { 
   if {$gga(llu) == "utm"} {
      set utm 1
   } else {
      set utm 0
   }
   exp_send "gga=rbgga()\r" 
 }
 button $mw.f1.plot -text "Plot" -command {
   if { $gga(mshape) == "None" } {
      set marker ",marker=0";
   } else {
      set marker ",marker=$ytk_PLMK_marker($gga(mshape))"
   }
   if {$gga(llu) == "utm"} {
      set utm 1
   } else {
      set utm 0
   }
    exp_send "window,6;\r"
    exp_send "show_gga_track, color=\"$gga(linecolor)\", skip=$gga(skip)$marker,msize=$gga(msize), utm=$utm; \n\r" 
    expect ">"
    exp_send "\n"
    expect ">"
    exp_send "utm= $utm; \r"
    expect ">"
 }
 button $mw.f1.info -text "Info"
 button $mw.f1.fma -text "Fma" -command { exp_send "window,6; fma\r\n" }
 button $mw.f1.jump -text "Jump" -command { 
   exp_send "wsav=window();window,6; gga_click_start_isod()\n" 
   tk_messageBox  -message "Drag out a rectangular seclection over a section 
 of a flightline in Yorick window-6."  -type ok
   expect "region_selected"
   exp_send "window(wsav)\r"
 }
 button $mw.f1.limits -text "Limits" \
	-command { exp_send "window,6; limits\r\n" }
 button $mw.f1.dismiss -text "Dismiss" -command "destroy $mw "
 pack $mw.f1.load $mw.f1.plot $mw.f1.info $mw.f1.limits \
	$mw.f1.fma $mw.f1.jump -side top -fill x
 pack $mw.f1.dismiss -side bottom -anchor s -fill both

 frame $mw.f2 -relief groove -borderwidth 3
 label $mw.f2.title -text "Map controls"
 button $mw.f2.mapredraw  -text "Replot" -command {
   if {$gga(llu) == "utm"} {
      set utm 1
   } else {
      set utm 0
   }
   plot_last_map $utm 
 }
 button $mw.f2.mapload    -text "Load" -command {
   if {$gga(llu) == "utm"} {
      set utm 1
   } else {
      set utm 0
   }
   load_map $utm 
 }
 pack  $mw.f2.title -side top
 pack  $mw.f2.mapload $mw.f2.mapredraw -fill both -expand 1 -side left

 frame $mw.f3 -relief groove -borderwidth 3
 button $mw.f3.fpload    -text "Load" -command {
    load_fp
 }
 label $mw.f3.title -text "Flight Plans"

 pack $mw.f3.title -side top
 pack $mw.f3.fpload -side left
### pack $mw.f3 -side bottom -anchor n -fill both -expand 1


 pack $mw.f3 -side bottom -expand 1 -fill both
 pack $mw.f2 -side bottom -expand 1 -fill both
 pack $mw.f1 $mw.g1 -side left -anchor n -fill both -expand 1

}




#############
#   Time
#############
 $w.mb.time add command -label "Time..." -command {  

 }
 $w.mb.time add command -label "Check and correct EDB time..." -command {
  source ts_check.ytk; ts_check;
 }



#############
#   help
#############
 $w.mb.help add command \
   -label "Version:\$Id$"
 $w.mb.help add command -label "Yorick Graphics Window Use"
 $w.mb.help add command -label "0 Waveform Display"
 $w.mb.help add command -label "1 Raster Images"
 $w.mb.help add command -label "2 "
 $w.mb.help add command -label "3 "
 $w.mb.help add command -label "4 "
 $w.mb.help add command -label "5 "
 $w.mb.help add command -label "6 Lat/Lon Coast maps, GGA nav data"
 $w.mb.help add command -label "7 Geographic maps and Nav data"




